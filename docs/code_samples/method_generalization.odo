module trivial_generalization

def Pet = Cat | Dog

def Cat(name: String)
def Dog(name: String)

for Cat:
    def happy(self) -> String = "{self.name} purrs!"
    def unhappyWith(self, intruder: String) -> String = "{self.name} hisses at {intruder}!"

for Dog:
    def happy(self) -> String = "{self.name} wags their tail!"
    def unhappyWith(self, intruder: String) -> String = "{self.name} barks at {intruder}!"

let example! =
    mut pet: Cat | Dog

    pet <- Cat("Spot")
    print!(pet.happy)
    --> Spot purrs!
    print!(pet.unhappyWith("owner"))
    --> Spot hisses at owner!

    pet <- Dog("Ash")
    print!(pet.happy)
    --> Ash wags their tail!
    print!(pet.unhappyWith("owner"))
    --> Ash hisses at owner!


-- NOTE: only instance methods are generalized.
-- Type methods (aka static methods) cannot be generalized
-- (since there is no way to tell at runtime which version to call)
for Cat:
    def sounds: String = ["meow", "purr", "yowl", "hiss"]
for Dog:
    def sounds: String = ["bark", "growl", "whimper", "howl"]

--- The following does not compile:
--(
let incorrect_example =
    print!(Pet.sounds)
)--

-- Instead, you must define the method on the union type directly:
for Cat | Dog:
    def petSounds: String = ["meow", "bark", ...]


------
module simple_generalization

def Foo
def Bar

for Foo:
    def generalized(self, x: Int) -> Int = 2 * x
    def notGeneralized(self, x: Int) -> Int = 3 * x


for Bar:
    def generalized(self, x: Int) -> String = "4 * {x}"
    def notGeneralized(self, x: String) -> Int = 5 * x.toInt

let example! =
    mut a: Foo | Bar

    a <- Foo
    print!(a.generalized(10))
    --> 20
    a <- Bar
    print!(a.generalized(10))
    --> 4 * 10
    print!(a.generalized.type)
    --> Func(Bar | Foo, Int) -> Int | String

    -- But the following cannot compile:
    -- print!(a.notGeneralized(10))
    -- print!(a.notGeneralized("ten"))

