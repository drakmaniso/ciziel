------
module std'list

use std'iter: #iterator, #asIterator


union List[T #any] =
    ref Node[T] | Empty
with
    #eq for List[T #eq]
    #functor, #iterable


struct Node[T #any] =
    item: T
    tail: List[T]
with
    #eq for Node[T #eq]
    #functor, #iterable


struct Empty
with
    #eq, #functor, #iterable


func list(...items: Array[T]) -> List[T] =
    result = mut Empty
    for item in items.iterator.reverse do
        result <- Node(item, result)
    result


for Empty:
    method == (other: Empty) -> Bool =
        True

    method == (other: Node[_]) -> Bool =
        False


for Node[T #eq]:
    method == (other: Empty) -> Bool =
        False

    method == (other: Node[T]) -> Bool =
        self.item == other.item and self.tail == other.tail


-- Pushing and poping


for Empty:
    func push(item: T) -> Node[T] =
        Node(item, Empty)

    func pop -> None =
        None


for Node[T]:    
    method push(item: T) -> Node[T] =
        Node(item, self)

    method pop -> Some[T] =
        Some(self.item)


-- Functor implementation


for Empty:
    method map(f: T -> U) -> Empty =
        Empty


for Node[T]:
    method map(f: T -> U) -> Node[U] =
        Node(
            item: f(self.item),
            tail: self.tail.map(f))
        )


-- Iterator stuff


for Empty:
    alias Iterator = Iterator[_]

    method iter -> Iterator[_] =
        Iterator(Empty)


for Node[T]:
    alias Iterator = Iterator[T]

    method iter -> Iterator[T] =
        Iterator(self)


struct Iterator[T] =
    current: List[T]
with
    #iterator


for Iterator[T]:
    alias Item = T

    mut method next! -> Option[T] =
        match self.current
        case Empty then
            None
        case Node(item, tail) then
            self.current <- tail
            Some(item)
    

------
module std'list'test


use std'list (List, Node, Empty)


func double(list: List[Int]) -> List[Int] =
    list.map(x => x * 2)


func main!(io: only Console) =
    a = ListNode(1, ListNode(2, ListNode(3, EmptyList)))
    b = List.new(1, 2, 3)

    io.print!(a.type)
    --> ListNode[Int] | EmptyList

    io.print!(b.type)
    --> ListNode[Int] | EmptyList

    io.print!(a.map.type)
    --> Func(ListNode[Int] | EmptyList, Int -> A) -> ListNode[A] | EmptyList
