module /std/vec2


trait #vec2 =
    struct Self =
        x: Float
        y: Float
    end
    -- func Self(x: Float, y: Float)
    -- func (Self).x -> Float
    -- func (Self).y -> Float
    const Self.zero -> Point
    func (Self).length -> Float
    func (Self).normalize -> Self
    func (Self) + (other: #vec2) -> Self
    func (Self) - (other: #vec2) -> Self
    func (Self) * (other: Float) -> Self
    func (Float) * (other: Self) -> Self
end


func length(vector: #vec2) -> Float =
    math'sqrt((vector.x ^ 2) + (vector.y ^ 2))
end


func normalize(vector: V #vec2) -> V =
    l = self.length
    V(x: self.x / l, y: self.y / l)
end


func zero(static T #vec2) -> T =
    T(x: 0, y: 0)
end


func add(vector: T #vec2, other: U #vec2) -> T =
    T(x: vector.x + other.x, y: vector.y + other.y)
end


func sub(vector: T #vec2) - (other: U #vec2) -> T =
    T(x: vector.x - other.x, y: vector.y - other.y)
end


func mul(vector: T #vec2, scalar: Float) -> T =
    T(x: vector.x * scalar, y: vector.y * scalar)
end


module geom


struct Point =
    x: Float
    y: Float
end


ensure
    Point is #tuple
    Point is #vec2
end


const Point.zero = Point(0, 0)


func (Point).length -> Float =
    vec2'length(self)
end


func (Point).normalize -> Point =
    vec2'normalize(self)
end


func (Point) + (other: #vec2) -> Point =
    vec2'add(self, other)
end


func (Point) - (other: #vec2) -> Point =
    vec2'sub(self, other)
end


func (Point) * (other: Float) -> Point =
    vec2'mul(self, other)
end


func (Float) * (other: Point) -> Point =
    vec2'mul(other, self)
end


union Shape =
    Circle | Square | Rectangle
end


ensure
    Shape is #movable
    Shape is #scalable
end


trait #movable =
    func (Self).move-to(destination: Point) -> Self
end


trait #scalable =
    func (Self).scale-by(factor: Float) -> Self
end


trait #with-center =
    struct Self =
        center: Point
        ...
    end
end


func move-shape-to(shape: mut T #with-center, destination: Point) =
    shape with (center: destination)
end


struct Circle =
    center: Point
    radius: Float
end


ensure
    Circle is #with-center
    Circle is #movable
    Circle is #scalable
end


func (Circle).diameter -> Float =
    self.radius * 2
end


func (Circle).perimeter -> Float =
    math'pi * self.diameter
end


func (Circle).area -> Float =
    math'pi * self.radius * self.radius
end


func (Circle).move-to(destination: Point) -> Circle =
    move-shape-to(self, destination)
end


func (Circle).scale-by(factor: Float) -> Circle =
    self with (radius: self.radius * factor)
end


struct Square =
    center: Point
    side: Int
end


struct Rectangle =
    center: Point
    width: Int
    height: Int
end


struct Polygon =
    ...points: Array[Point]
end


------


union Artist =
    Person | Band
end


struct Person =
    name: String
end


struct Band =
    name: String
end


struct Album =
    artist: Artist
    title: String
    release-date: Date
    songs: Array[Song]
end


-------


func (Foo).fn1(arg: String | Float) -> Bool = ...
func (Foo).fn2(arg: T #stringable) -> U #stringable #comparable = ...


func (Bar).fn1(arg: String | Int) -> Char = ...
func (Bar).fn2(arg: T #comparable) -> U #stringable #numeric = ...


-- implicitly:
func (Foo | Bar).fn1(arg: String) -> Bool | Char = ...
func (Foo | Bar).fn2(arg: T #stringable #comparable) -> U #stringable #comparable | V #stringable #numeric = ...


-------

struct PrivateFoo =
    private-field: Int
end

---

public
struct TransparentFoo =
    public-field: Int
end

---

struct OpaqueFoo =
    private-field: Int
end


public
func OpaqueFoo.new(public-parameter: Float) -> OpaqueFoo =
    OpaqueFoo(private-field: public-parameter.rounded)
end

---

struct TranslucenFoo =
    public public-field: Int
    private-field: Int
end


public
func TranslucentFoo.new(public-field: Int) -> TranslucentFoo =
    TranslucentFoo(public-field: public-field, private-field: 0)
end
