module /std/vec2

def #vec2 =
    has Self(x: Float, y: Float)

def length(a: A #vec2) -> Float =
    math'sqrt((a.x ^ 2) + (a.y ^ 2))

def normalize(a: A #vec2) -> A =
    l = a.length
    A(x: a.x / l, y: a.y / l)

def add(a: A #vec2, b: B #vec2) -> C #vec2 =
    C(a.x + b.x, a.y + b.y)

def sub(a: A #vec2, b: B #vec2) -> C #vec2 =
    C(a.x - b.x, a.y - b.y)


module geom

def Point(x: Float, y: Float)

for Point:
    def length(self) -> Float = vec2'length(self)
    def normalize(self) -> Point = vec2'normalize(self)
    def add(self, other: O #vec2) -> Point = vec2'add(self, other)
    def zero = Point(0, 0)

let test_Point() =
    assert Point has #vec2
    assert Point has #length
    assert Point has #add

def Shape = Circle | Square | Rectangle

def #movable =
    has move-to!(mut self, position: Point)

def #scalable =
    has scale-by!(mut self, factor: Float)


def #center =
    has Self{center: Point, ...}

let move-shape-to!(mut shape: T #center, destination: Point) =
    shape.center <- destination


def Circle{
        center: Point,
        radius: Float,
    }

for Circle:
    def diameter(self) -> Float =
        self.radius * 2

    def perimeter(self) -> Float =
        math'pi * self.diameter

    def area(self) -> Float =
        math'pi * self.radius * self.radius

for Circle as #movable:
    def move-to!(mut self, destination: Point) =
        move-shape-to!(self, destination)

for Circle as #scalable:
    def scale-by!(mut self, factor: Float) =
        self.radius <- self.radius * factor


let test-circle() =
    assert Circle has #movable
    assert Circle has #scalable

def Square{
        center: Point,
        side: Int,
    }

def Rectangle{
        center: Point,
        width: Int,
        height: Int,
    }

def Polygon{
        ...points: Array[Point]
    }


------
def Artist = Person | Band
def Person(name: String)
def Band(name: String)
def Album{
        artist: Artist,
        title: String,
        release-date: Date,
        songs: Array[Song],
    }


-------
for Foo:
    def fn1(self, arg: String | Float) -> Bool = ...
    def fn2(self, arg: T #stringable) -> U #stringable #comparable = ...

for Bar:
    def fn1(self, arg: String | Int) -> Char = ...
    def fn2(self, arg: T #comparable) -> U #stringable #numeric = ...

-- implicitly:
for Foo | Bar:
    def fn1(self, arg: String) -> Bool | Char = ...
    def fn2(self, arg: T #stringable #comparable) -> U #stringable = ...


-------

-- A type is public if its constructor is public.
def PublicFoo{public-field: Int}


-- A type is private if its constructor definition is private,
-- and no public functions in the module return it.
let PrivateFoo{private-field: Int}


-- A type is opaque (publicly visible but fields are private) if
-- its constructor is private but some public functions in the
-- module return it.
let OpaqueFoo{private-field: Int}

for OpaqueFoo:
    def new(public-parameter: Float) -> OpaqueFoo =
        OpaqueFoo{private-field: public-parameter.rounded}
    
    def public-field(self) -> Int =
        self.private-field
