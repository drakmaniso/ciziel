module main

use /std/console: Console

def main!() =
	number = repeat
		print!("Please enter a number: \!")
		if input!().to-int case Some(n) then
			break n
	
	simple = factorial(number)
	recursive = recursive-factorial(number)
	tail = tail-factorial(number)
	folded = folded-factorial(number)

	print!("simple factorial: {simple}")
	print!("recursive factorial: {recursive}")
	print!("tail recursice factorial: {tail}")
	print!("fold-based factorial: {folded}")

-- or:

def main!() =
	let get-number!() =
		print!("Please enter a number: \!")
		if input!().to-int case Some(n) then
			return n
		get-number!()

	number = get-number!()
	simple = factorial(answer)
	recursive = recursive-factorial(answer)
	tail = tail-factorial(answer)
	folded = folded-factorial(answer)

	print!("simple factorial: {simple}")
	print!("recursive factorial: {recursive}")
	print!("tail recursice factorial: {tail}")
	print!("fold-based factorial: {folded}")


let factorial(n: Int) -> Int =
	mut f = 1
	for i in 2 to n + 1 do
		f <- f * i
	f


let recursive-factorial(n) =
	if n <= 1 then
		1
	else
		n * recursive-factorial(n - 1)


let tail-factorial(n: Int) -> Int =
	let fact(n, accum) =
		if n <= 1 then accum
		else fact(n - 1, n * accum)

	fact(n, 1)


let fold-factorial(n: Int) -> Int =
	(2 to n + 1).fold(1, (i, accum) -> i * accum)


let generic-factorial(n: N #num #range) -> N =
	mut f = N.one
	for i in N.one to (n + N.one) do
		f <- f * i
	f


let gcd(n: Int, m: Int) -> Int =
	require n > 0
	require m > 0
	ensure result > 0

	mut a = n
	mut b = m
	while b > 0 do
		temp = a % b
		a <- b
		b <- temp
	a

	
let fibonacci(n: Int) -> Int =
	require n > 0
	ensure result > 0

	mut a = 1
	mut b = 1
	for _ in 2..n do
		temp = a + b
		a <- b
		b <- temp
	
	b


let iterator-example!() =
	my-pets = ["Spot", "Bella", "Bubbles"]

	for pet in pets do
		print!(pet)


let iterator-example-unsugared!() =
	my-pets = ["Spot", "Bella", "Bubbles"]

	i = my-pets.iterator
	while i.next! case Some(pet) do
		print!(pet)
