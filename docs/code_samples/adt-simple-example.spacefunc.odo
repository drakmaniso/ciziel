module /std/vec2


trait Vec2[V] =
    struct V =
        x: Float
        y: Float
    -- func Self(x: Float, y: Float)
    -- func (Self).x -> Float
    -- func (Self).y -> Float


trait Vector[V] =
    func Scalar (type V) -> type N where Num[N]
    func zero (type V) -> V
    func length (vector: V) -> Float
    func normalize  -> Self
    func (Self) + (other: #vec2) -> Self
    func (Self) - (other: #vec2) -> Self
    func (Self) * (other: Float) -> Self
    func (Float) * (other: Self) -> Self


func length(vector: #vec2) -> Float =
    math'sqrt((vector.x ^ 2) + (vector.y ^ 2))


func normalize(vector: V #vec2) -> V =
    l = self.length
    V(x: self.x / l, y: self.y / l)


func zero(static T #vec2) -> T =
    T(x: 0, y: 0)


func add(vector: T #vec2, other: U #vec2) -> T =
    T(x: vector.x + other.x, y: vector.y + other.y)


func sub(vector: T #vec2) - (other: U #vec2) -> T =
    T(x: vector.x - other.x, y: vector.y - other.y)


func mul(vector: T #vec2, scalar: Float) -> T =
    T(x: vector.x * scalar, y: vector.y * scalar)


module geom


struct Point =
    x: Float
    y: Float


ensure
    Point is #tuple
    Point is #vec2


implement Vector[Point]

    alias Scalar = Float


    const zero = Point(0, 0)


    func length (p: Point) -> Float =
        vec'length p


    func normalize (p: Point) -> Point =
        vec'normalize p


    func `+` (p1: Point) (p2: #vec2) -> Point =
        vec'add p1 p2


    func `-` (p1: Point) (p2: #vec2) -> Point =
        vec'sub p1 p2


    func `*` (p: Point) (scalar: Float) -> Point =
        vec'mul p scalar


    func `*` (scalar: Float) (p: Point) -> Point =
        vec'mul p scalar


union Shape =
    Circle | Square | Rectangle


ensure
    Shape is #movable
    Shape is #scalable


trait #movable =
    func move-to (shape: Self) (destination: Point) -> Self


trait #scalable =
    func scale-by (shape: Self) (factor: Float) -> Self


trait #with-center =
    struct Self =
        center: Point
        ...


func move-shape-to(shape: mut T #with-center, destination: Point) =
    shape with (center: destination)


struct Circle =
    center: Point
    radius: Float


ensure
    Circle is #with-center
    Circle is #movable
    Circle is #scalable


func diameter (c: Circle) -> Float =
    c.radius * 2


func perimeter (c: Circle) -> Float =
    math'pi * c.diameter


func (Circle).area -> Float =
    math'pi * self.radius * self.radius


func (Circle).move-to(destination: Point) -> Circle =
    move-shape-to(self, destination)


func (Circle).scale-by(factor: Float) -> Circle =
    self with (radius: self.radius * factor)


struct Square =
    center: Point
    side: Int


struct Rectangle =
    center: Point
    width: Int
    height: Int


struct Polygon =
    ...points: Array[Point]


------


union Artist =
    Person | Band


struct Person =
    name: String


struct Band =
    name: String


struct Album =
    artist: Artist
    title: String
    release-date: Date
    songs: Array[Song]


-------


func (Foo).fn1(arg: String | Float) -> Bool = ...
func (Foo).fn2(arg: T #stringable) -> U #stringable #comparable = ...


func (Bar).fn1(arg: String | Int) -> Char = ...
func (Bar).fn2(arg: T #comparable) -> U #stringable #numeric = ...


-- implicitly:
func (Foo | Bar).fn1(arg: String) -> Bool | Char = ...
func (Foo | Bar).fn2(arg: T #stringable #comparable) -> U #stringable #comparable | V #stringable #numeric = ...


-------

struct PrivateFoo =
    private-field: Int

---

public
struct TransparentFoo =
    public-field: Int

---

struct OpaqueFoo =
    private-field: Int


public
func OpaqueFoo.new(public-parameter: Float) -> OpaqueFoo =
    OpaqueFoo(private-field: public-parameter.rounded)

---

struct TranslucenFoo =
    public public-field: Int
    private-field: Int


public
func TranslucentFoo.new(public-field: Int) -> TranslucentFoo =
    TranslucentFoo(public-field: public-field, private-field: 0)
