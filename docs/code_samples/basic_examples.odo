module main

use /std/console: Console

def main! =
	def getNumber! =
		loop:
			print!("Please enter a number: \!")
			answer = input!.toInt
			if answer is Int:
				return answer

	number = getNumber!
	simple = factorial(number)
	recursive = recursiveFactorial(number)
	tail = tailFactorial(number)
	folded = foldedFactorial(number)

	print!("simple factorial: |simple|")
	print!("recursive factorial: |recursive|")
	print!("tail recursice factorial: |tail|")
	print!("fold-based factorial: |folded|")

-- or:

def main!(mut io: Console) =
	def getNumber! =
		loop:
			io.print!("Please enter a number: \!")
			answer = Int.fromString(io.input!)
			if answer is Int:
				return answer

	number = getNumber!
	simple = factorial(number)
	recursive = recursiveFactorial(number)
	tail = tailFactorial(number)
	folded = foldedFactorial(number)

	io.print!("simple factorial: |simple|")
	io.print!("recursive factorial: |recursive|")
	io.print!("tail recursice factorial: |tail|")
	io.print!("fold-based factorial: |folded|")


let factorial(n: Int) -> Int =
	mut result = 1
	for i in (2 to n + 1) loop
		result <- result * i
	result


let recursiveFactorial(n) =
	if n <= 1 then
		1
	else
		n * recursiveFactorial(n - 1)


let tailFactorial(n: Int) -> Int =
	let loop(n, accum) =
		if n <= 1: accum
		else: loop(n - 1, n * accum)
	loop(n, 1)


let foldFactorial(n: Int) -> Int =
	(2 to n + 1).fold(1, (i, accum) -> i * accum)


let genericFactorial(n: N #num #range) -> N =
	mut result = N.one
	for i in N.one to n + N.one:
		result <- result * i
	result


let gcd(a: Int, b: Int) -> Int =
	require a > 0
	require b > 0
	ensure result > 0
 	
	 let loop(a, b) =
		if b == 0 then
			return a
		let (c, d) = if a <= b then (a, b) else (b, a)
		return loop(c, d mod c)

	return loop(a, b)

