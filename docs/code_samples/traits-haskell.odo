def [T] #functor =
    has map(self, transform: T -> A) -> Self[A]
    def replace(self, constant: A) -> Self[A] =
        self.fmap(_ -> constant)

def [T] #applicative =
    has #functor
    has wrap(value: T) -> Self[T]
    has apply(self, operation: Self[T -> A]) -> Self[A]
    def and-then(self, other: Self[A]) -> Self[A] =
        ...
    def or-else(self, other: Self[A]) -> Self[T] =
        ...

def [T] #monad =
    has #applicative
    has bind(self, operation: T -> Self[A]) -> Self[A]

def [T] #monad-fail =
    has #monad
    has fail(msg: String) -> Self[T]

--TODO: is this correct?
def [T[U]] #monad-trans =
    has lift(monad: T[U]) -> Self[T[U]]


------

def #semigroup =
    has append(self, other: Self) -> Self

has #monoid =
    has #semigroup
    has empty: Self
    def concat(values: A[Self] #functor) -> Self =
        values.fold(Self.append, Self.empty)


------

def [T] #alternative =
    has Self[T] #applicative
    has #monoid

def [T] #monad-plus =
    has Self[T] #monad
    has #monoid


------

def [T #monoid] #reduce =
    has reduce(self, operation: (T, T) -> T) -> T
    has fold-map(self, operation: T -> A) -> A

-- Catamorphisms
def [T] #foldable =
    has fold(self, initial: A, operation: (A, T) -> A) -> A
    has rev-fold(self, initial: A, operation: (T, A) -> A) -> A

-- Anamorphisms
def [T] #unfoldable =
    has unfold(initial: A, operation: A -> Option[(T, A)]) -> Self[T]

def [T] #traversable =
    has Self[T] #functor
    has Self[T] #foldable -- or #reduce?
    has traverse(self, operation: T -> F[B] #functor) -> F[Self[B]]
    has sequence(stuff: Self[F[T] #functor]) -> F[Self[T]]


------

def [T, U] #bifunctor =
    has bimap(self, left-operation: T -> A, right-operation: U -> B) -> Self[A, B]
    has left-map(self, left-operation: T -> A) -> Self[A, U] =
        self.bimap(left-operation, identity)
    has right-map(self, right-operation: U -> A) -> Self[T, A] =
        self.bimap(identity, right-operation)


------

def [T, U] #category =
    has id: Self[T, T]
    has compose(self, other: Self[U -> A]) -> Self[T -> A]

def [T, U] #arrow =
    has Self[T, U] #category
    has arrow(operation: T -> U) -> Self[T, U]
    has first(self) -> Self[(T, A), (U, A)]
    has parrallel-compose(self, other: Self[A, B]) -> Self[(T, A), (U, B)]
    has fanout-compose(self, other: Self[T, A]) -> Self[T, (U, A)]

def [T, U] #arrow-apply =
    has Self[T, U] #arrow
    has application: Self[(Self[A, B], A), B]

def [T, U] #arrow-loop =
    has Self[T, U] #arrow
    has loop(Self[(A, C), (B, C)]) -> Self[A, B]


------

def [T] #comonad =
    has Self[T] #functor
    has extract(self) -> T
    has duplicate(self) -> Self[Self[T]]
    def extend(self, operation: Self[T] -> A) -> Self[A] =
        self.duplicate.map(operation)

