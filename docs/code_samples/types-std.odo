def Nil

union Bool = False | True
struct False
struct True

--- The "maybe" monad
union Option[T] = Some[T] | None
struct Some[T] = item: T
struct None

func (Some[T]).map(f: Func[T -> U]) -> Some[U] =
    Some(f(self.item))

func (None).map(f: Func[_ -> _]) -> None =
    None

func Some[T].wrap(item: T) -> Some[T] =
    Some(item)

func None.wrap(item: T) -> Some[T] =
    Some(item)

func (Some[T]).chain(f: Func[T -> Option[U]]) -> Option[U] =
    f(self.item)

func (None).chain(f: Func[_ -> Option[_]]) -> None =
    None

---

union Result[A, E #error] = Ok[A] | Error[E]
struct Ok[A] = value: A
struct Error[E #error] = error: E

check Result[A, E] is #monad

func Result[A, E].wrap(value: A) -> Result[A, E] =
    Ok(value)

func (Result[A, E]).chain(operation: A -> Result[A, E]) -> Result[A, E] =
    match self
    case Ok(value) then operation(value)
    case e = Error(...) then e


---

struct Map[T#iterator, U] =
    iterator: T
    function: Func[T.Item -> U]
with
    #iterator

func Map[T#iterator, U].new(iterator: T, function: Func[T.Item -> U]) -> Map[T, U] =
    Map(iterator, function)

alias Map[T#iterator, U].Item = U

func (mut Map[T#iterator, U]).next! -> Option[U] =
    match self.iterator.next!
    case None then None
    case Some(item) then Some(self.function(item))


---

func (Array[A]).fold(accum: B, function: Func(B, T) -> B]) -> B =
    ...

func Array[B].unfold(first: A, function: Func[A -> Option[(B, A)]) -> Array[B] =
    ...