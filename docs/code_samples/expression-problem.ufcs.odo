module foo


trait #eval =
	func (Self).eval -> Int


struct Literal =
	value: Int
with
	#eval


struct Addition[T] =
	left: Expr[T]
	right: Expr[T]
with
	#eval


func eval(self: Literal) -> Int =
	self.value


func eval(self: Addition[T]) -> Int =
	self.left.eval + self.right.eval


------
module bar

use foo (#eval, Literal, Addition)


trait #pretty
	func pretty(Self) -> String


struct Negation[T] =
	subexpr: T
with
	#eval, #pretty


func eval(self: Negation[T#eval]) -> Int =
	- self.subexpr.eval


func pretty(self: Literal) -> String =
	self.eval.as-string


func pretty(self: Addition[T#pretty]) -> String =
	"{self.left.pretty} + {self.right.pretty}"


func pretty(self: Negation[T#pretty]) -> String =
	match self.subexpr
	case e = Literal(...):
		"-{e.pretty}"
	else
		"- ({self.subexpr.pretty})"
	end


------
module main

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)

union Expr = Literal | Addition[Expr] | Negation[Expr]

func main!(io: sole Console):
	e1 = Addition(Literal(77), Negation(Literal(12))
	io.print!("{e1.pretty} = {e1.eval}")
