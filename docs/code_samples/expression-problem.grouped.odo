module foo


trait #eval =
	func (Self).eval -> Int


struct Literal =
	value: Int


struct Addition[T] =
	left: Expr[T]
	right: Expr[T]


ensure
	Literal is #eval
	Addition[#eval] is #eval


for Literal
    func .eval -> Int =
        self.value


for Addittion[#eval]
    func .eval -> Int =
        self.left.eval + self.right.eval


------
module bar

use foo (#eval, Literal, Addition)


trait #pretty
	func (Self).pretty -> String


struct Negation[T] =
	subexpr: T


ensure
	Negation[#eval] is #eval
	Literal is #pretty
	Addition[#pretty] is #pretty
	Negation[#pretty] is #pretty


for Negation[#eval]
    func .eval -> Int =
        - self.subexpr.eval


for Literal
    func .pretty -> String =
        self.eval.as-string


for Addition[#pretty]
    func .pretty -> String =
        "{self.left.pretty} + {self.right.pretty}"


for Negation[#pretty]
    func .pretty -> String =
        match self.subexpr
        case e = Literal(...) then
            "-{e.pretty}"
        else
            "- ({self.subexpr.pretty})"


------
module main

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)

use foo (Literal, Addition)
use bar (Negation, +Literal, +Addition)

union Expr = Literal | Addition[Expr] | Negation[Expr]

func main!(io: sole Console):
	e1 = Addition(Literal(77), Negation(Literal(12))
	io.print!("{e1.pretty} = {e1.eval}")
