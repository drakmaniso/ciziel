def Nil

def Bool = False | True
def False
def True

--- The "maybe" monad
def Maybe[T](item: T | Nil)
for Maybe[T]:
    def wrap(item: T) -> Maybe[T] =
        Maybe(item)

    def map(self, f: T -> U) -> Maybe[U] =
        match self.item
        case some :: T: Maybe(f(some))
        case Nil: Maybe(Nil)
    
    def bind(self, f: T -> Maybe[U]) -> Maybe[U] =
        match self.item
        case some :: T: f(some)
        case Nil: Maybe(Nil)


-- Or this?
def Option[T] = Some[T] | Nil
def Some[T](item: T)
def Nil

for Option[T]:
    def wrap(item: T) -> Option[T] =
        Some(item)

for Some[T]:
    def map(self, f: T -> U) -> Some[U] =
        Some(f(self.item))
    def bind(self, f: T -> Option[U]) -> Option[U] =
        f(self.item)

for Nil:
    def map(self, f: _ -> _) -> Nil =
        Nil
    def bind(self, f: _ -> Option[_]) -> Nil =
        Nil





------
let Map[I #iterator, U](
        iter: I,
        f: I.Item -> U,
    )

for Map[I #iterator, T]:
    def new(iter: I, f: I.Item -> U) -> Map[I, U] =
        Map(iter, f)
    
    def Item = I.Item

    def next!(self) -> T | Nil =
        match self.iter.next!
        case Nil: Nil
        case item: self.f(item)

    def next!(self) -> T | Nil =
        let item? = self.iter.next!
        return self.f(item)
