--- From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type)
module gadt_example_1

def Expr = Boolean | Integer | Equality | Addition
def IntegerExpr = Integer | Addition
def BooleanExpr = Boolean | Equality

def Boolean(eval: Bool)
def Integer(eval: Int)
def Equality(left: IntegerExpr, right: IntegerExpr)
def Addition(left: IntegerExpr, right: IntegerExpr)


-------------------------------------------------------------------------------
--- GADT example: phantom types
--- From "Fun with phantom types" by R. Hinze
module

def TermInt = Zero | Succ | Pred | If[TermInt]
def TermBool = IsZero | If[TermBool]

def Zero
def Succ(arg: TermInt)
def Pred(arg: TermInt)
def IsZero(arg: TermInt)
def If[T](condition: TermBool, thenBranch: T, elseBranch: T)

for Zero: def eval(self) -> Int = 0
for Succ: def eval(self) -> Int = self.arg.eval + 1
for Pred: def eval(self) -> Int = self.arg.eval - 1
for IsZero: def eval(self) -> Int = self.arg.eval == 0
for If[T]: def eval(self) -> T =
    if self.condition.eval: self.thenBranch.eval
    else: self.elseBranch.eval


-------------------------------------------------------------------------------
--- GADT example: higher-order abstract syntax
--- From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
module

def Lift[T](eval: T)

def Pair[T, U](first: T, second: U)
for Pair[T, U]:
    def eval(self) -> (T, U) =
        (self.first.eval, self,second.eval)

def Lambda[T, U](function: T -> U)
for Lambda[T, U]:
    def eval(self) -> (T -> U) =
        x => self.function(Lift(x)).eval

def App[T, U](function: Lam[T, U], argument: U)
for App[T, U]:
    def eval(self) -> U =
        self.f.eval(self.argument.eval)

def Fix[T](function: Lam[T, T])
for Fix[T]:
    def eval(self) -> T =
        self.function.eval(Fix(self.function).eval)


let example! =
    factorial = Fix(Lam(f => Lam(y => Lift(if y.eval == 0 then 1 else y.eval * f.eval(y.eval - 1)))))
    print!(factorial.eval(10))
