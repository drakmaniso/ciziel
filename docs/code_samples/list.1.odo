------
module std'list

use std'iter: #iterator, #asIterator


union List[T] =
    ref Node[T] | Empty


check
    List[#eq] is #eq
    List[_] is #functor
    List[_] is #iterable


struct Node[T #any] =
    item: T
    tail: List[T]


check
    Node[#eq] is #eq
    Node[_] is #functor #iterable


struct Empty


check
    Empty is #eq #functor #iterable


method List[T].new(...items: Array[T]) -> List[T] =
    items.fold-rev(
        Empty,
        func (item, acc) => Node(item, acc)
    )


method (Empty) == (other: Empty) -> Bool =
    True


method (Empty) == (other: Node[_]) -> Bool =
    False


method (Node[_]) == (other: Empty) -> Bool =
    False


method (Node[T #eq]) == (other: Node[T]) -> Bool =
    self.item == other.item and self.tail == other.tail


-- Pushing and poping

    
method (Node[T]).push(item: T) -> Node[T] =
    Node(item, self)


method (Empty).push(item: T) -> Node[T] =
    Node(item, Empty)


method (Node[T]).pop -> Some[T] =
    Some(self.item)


method (Empty).pop -> None =
    None


-- Functor implementation


method (Empty).map(f: T -> U) -> Empty =
    Empty


method (Node[T]).map(f: T -> U) -> Node[U] =
    Node(
        item: f(self.item),
        tail: self.tail.map(f))
    )


-- Iterator stuff


alias Empty.Iterator = Iterator[_]


alias Node[T].Iterator = Iterator[T]


method (Empty).iter -> Iterator[_] =
    Iterator(Empty)


method (Node[T]).iter -> Iterator[T] =
    Iterator(self)


struct Iterator[T] =
    current: List[T]


check
    Iterator[_] is #iterator


alias Iterator[T].Item = T


method (Iterator[T]).next -> (Iterator[T], Option[T]) =
    match self.current
    case Empty then
        (self, None)
    case Node(item, tail) then
        (self with (current: tail), Some(item))
    

------
module std'list'test


use std'list (List, Node, Empty)


func double(list: List[Int]) -> List[Int] =
    list.map(x => x * 2)


func main!(io: Console) =
    a = Node(1, Node(2, Node(3, Empty)))
    b = List.new(1, 2, 3)

    io.print!(a.type)
    --> ListNode[Int] | EmptyList

    io.print!(b.type)
    --> ListNode[Int] | EmptyList

    io.print!(a.map.type)
    --> Func(ListNode[Int] | EmptyList, Int -> A) -> ListNode[A] | EmptyList
