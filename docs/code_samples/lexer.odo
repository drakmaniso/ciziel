module lexer


let Lexer{
        filepath: String,
        input: String,
        start: UInt,
        pos: UInt,
    }

def new-lexer(filepath: String, input: String) -> Lexer =
    Lexer{
        filepath,
        input,
        start = 0,
        pos = 0,
    }

def lexer-run!(mut self: Lexer) =
    self.start <- 0
    self.pos <- 0

    mut tag: TokenTag = scan!(self)
    while tag =/= token'EndOfFile do
        token = Token{
            value = str-slice(self.input, self.start, self.pos)
            tag,
            pos = self.start,
        }
        self.start <- self.pos
        token'print(token)
        tag = scan(self)

let next!(mut self: Lexer) -> Option[Char] =
    result = self.input[self.pos]?
    self.pos <- self.pos + 1
    return result

let ignore!(mut self: Lexer) =
    self.start <- self.pos

let backtrack!(mut self: Lexer) =
    self.pos <- self.pos - 1

let peek(self: Lexer) -> Option[Char] =
    self.input[self.pos + 1]?


-- Old version:

module lexer

let Lexer{
        filepath: String,
        input: String,
        start: UInt,
        pos: UInt,
    }

let State! = Func![mut Lexer -> State!] | Nil

for Lexer:
    def new(filepath: String, input: String) -> Lexer =
        Lexer{
            filepath,
            input,
            start = 0,
            pos = 0,
        }

    def run!(mut self) =
        mut state! = state_between
        while state! =/= Nil do
            state! <- state!(self)

    let next!(mut self) -> Char | OutOfBounds =
        result = self.input.at(self.pos)?
        self.pos <- self.pos++
        result

    let ignore!(mut self) =
        self.start <- self.pos
    
    let backtrack!(mut self) =
        self.pos <- self.pos - 1
    
    let peek(self) -> Char | OutOfBounds =
        self.input.at(self.pos + 1)?