------ Standard traits for iterators
module std/iter

def #next =
    has Item
    has next!(mut self) -> Option[Self.Item]

def #iter =
    has Iterator #next
    has iter(self) -> Self.Iterator


------ Simple iterator example
module counter

let Counter{
        count: Int,
        limit: Int,
    }

for Counter:
    def new(limit: Int) -> Counter =
        Counter{count: 0, limit: limit}
    
    def limit(self) -> Int =
        self.limit

    def Item = Int

    def next!(self) -> Option[Int] =
        if self.count >= self.limit then
            return None
        self.count <- self.count + 1
        return Some(self.count)

let test_Counter_traits() =
    assert Counter is std'iter'#iterator

let test_Counter() =
    counter = Counter.new(6)
    assert counter.next! == Some(1)
    assert counter.next! == Some(2)
    assert counter.next! == Some(3)
    assert counter.next! == Some(4)
    assert counter.next! == Some(5)
    assert counter.next! == None

let example-for!() =
    counter = Counter.new(7)
    for n in counter do
        print!(n)

let example-while!() =
    counter = Counter.new(7)
    while counter.next! case Some(n) do
        print!(n)

let example-desugared!() =
    counter = Counter.new(7)
    repeat
        match counter.next!
        case Some(n) then
            print!(n)
        case None then
            break 


----
module main

use
    std'iter for Iterator

func foo(iterator: I#iterator, f: I.Item -> Int) -> Array[Int] =
    result: mut []
    for elem in iterator do
        result.push!(f(elem))
    result

func compare(first: I#iterator, second: J[Item = I.Item]#iterator) -> Bool =
    mut first = first
    mut second = second
    repeat
        match (first.next!, second.next!)
        case (Some, Some) then continue
        case (None, None) then return True
        case _ then return False
