---- Monadic Bind -------------------------------------------------------------


fun example-1(numbers: Array[Int]) -> Option[Int] =
	first ?= numbers.at(0)
	second ?= numbers.at(1)

	Some(first + second)


fun example-1-desugared(numbers: Array[Int]) -> Option[Int] =
	numbers.at(0).and-then(first =>
		numbers.at(1).and-then(second =>
			Some(first + second)
		)
	)


fun example-1-desugared'(numbers: Array[Int]) -> Option[Int] =
	numbers.at(0) <and-then> first =>
		numbers.at(1) <and-then> second =>
			Some(first + second)


fun example-2(numbers: Array[String]) -> Result[Int, None | Int.Parse-Error] =
	first ?= numbers.at(0)
	a ?= Int.parse(first)

	second ?= numbers.at(1)
	b ?= Int.parse(second)

	Ok(a + b)


fun example-2(numbers: Array[String]) -> Result[Int, String] =
	first ?= numbers.at(0)
		.ok-or("empty array")
	a ?= Int.parse(first)
		.map-err(e => "parse error: {e}")

	second ?= numbers.at(1)
		.ok-or("array too small")
	b ?= Int.parse(second)
		.map-err(e => "parse error: {e}")

	Ok(a + b)


fun example-2(numbers: Array[String]) -> Result[Int, String] =
	numbers.at(0)
		.ok-or("empty array")
		.and-then(first =>
			Int.parse(first)
				.map-err(e => "parse error: {e}")
				.and-then(a =>
					numbers.at(1)
						.ok-or("array too small")
						.and-then(second =>
							Int.parse(second)
								.map-err(e => "parse error: {e}")
								.and-then(b =>
									Ok(a + b)
								)
						)
				)
		)


fun example-3(numbers: Array[String]) -> Result[Int, String] =
	first ?= numbers.at(0) <fail> => "empty array"
	a ?= Int.parse(first) <fail> e => "parse error: {e}"
	second ?= numbers.at(1) <fail> => "array too small"
	b ?= Int.parse(second) <fail> e => "parse error: {e}"
	Ok(a + b)


fun example-3'(numbers: Array[String]) -> Result[Int, String] =
	first ?= numbers.at(0) !! => "empty array"
	a ?= Int.parse(first) !! e => "parse error: {e}"
	second ?= numbers.at(1) !! => "array too small"
	b ?= Int.parse(second) !! e => "parse error: {e}"
	Ok(a + b)


fun example-3-desugared(numbers: Array[String]) -> Result[Int, String] =
	numbers.at(0)
		.<fail>(=> "empty array")
		.and-then(first =>
			Int.parse(first)
				.<fail>(e => "parse error: {e}")
				.and-then(a =>
					numbers.at(1)
						.<fail>(=> "array too small")
						.and-then(second =>
							Int.parse(second)
								.<fail>(e => "parse error: {e}")
								.and-then(b =>
									Ok(a + b)
								)
						)
				)
		)


---- Chaining Operator --------------------------------------------------------


fun example-4(numbers: Array[String]) -> Option[Int] =
	numbers.at(0)?.to-Int?.abs


fun example-4-desugared(numbers: Array[Int]) -> Option[String] =
	numbers.at(0).and-then(=> ___.to-int.and-then(=> ___.abs))


---- Monadic Bind with failure wrapping ---------------------------------------


<<
From a Rust RFC:
	fn get_count_item(s: &str) -> (u64, &str) {
		let mut it = s.split(' ');
		let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
			panic!("Can't segment count item pair: '{s}'");
		};
		let Ok(count) = u64::from_str(count_str) else {
			panic!("Can't parse integer: '{count_str}'");
		};
		(count, item)
	}
>>


fun get-count-item(s: String) -> Result[(Int, String), None | Int.Parse-Error] =
	it = s.split(Char " ")
	count-str ?= it.item.ok-or(Error(None))
	it' = it.next
	item ?= it'.item.ok-or(Error(None))
	count ?= Int.parse(count-str)

	Ok((count, item))


fun get-count-item(s: String) -> Result[(Int, String), String] =
	it = s.split(Char " ")
	count-str ?= it.item
		.ok-or(Error("can't segment count/item pair: '{s}'"))
	it' = it.next
	item ?= it'.item
		.ok-or(Error("can't segment count/item pair: '{s}'"))
	count ?= Int.parse(count-str)
		.or-else(e => Error("can't parse integer '{count_str}': {e}"))

	Ok((count, item))


type Segment-Error = Error[struct _]
type Parse-Error = Error[struct _(cause: Int.Parse-Error)]
fun get-count-item(s: String) -> Result[(Int, String), Segment-Error | Parse-Error] =
	it = s.split(Char " ")
	count-str ?= it.item.ok-or(Segment-Error)
	it' = it.next
	item ?= it'.item.ok-or(Segment-Error)
	count ?= Int.parse(count-str).or-else(e => Parse-Error(e))

	(count, item)


---- Or Refutable patterns? ---------------------------------------------------


fun get-count-item(s: String) -> Ok[(Int, String)] | Segment-Error | Int.Parse-Error =
	it = s.split(Char " ")
	Some(count-str) ?= it.item
	it' = it.next
	Some(item) ?= it'.item
	Ok(count) ?= Int.parse(count-str)

	Ok((count, item))


fun get-count-item(s: String) -> Result[(Int, String), Segment-Error | Int.Parse-Error] =
	it = s.split(Char " ")
	Some(count-str) ?= it.item.or(Segment-Error)
	it' = it.next
	Some(item) ?= it'.item.or(Segment-Error)
	Ok(count) ?= Int.parse(count-str)

	Ok((count, item))


fun get-count-item(s: String) -> (Int, String) ?? String =
	it = s.split(Char " ")
	Ok(count-str) ?= it.item
		.or(Error("can't segment count item pair: '{s}'."))
	it' = it.next
	Ok(item) ?= it'.item
		.or(Error("can't segment count item pair: '{s}'."))
	Ok(count) ?= Int.parse(count-str)
		.or-else(e => Error("can't parse integer '{count_str}': {e}"))

	(count, item)
