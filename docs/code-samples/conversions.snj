module std


def #to[A] {
    has (Self) <to> A -> A
}


def #from[A] {
    has (A) <to> Self -> Self
}



/*****/
module float


def #to[Float64] for Int32
def #from[Int32] for Float64
def (Int32) <to> Float64 -> Float64 {
    ...
}


def #to[String] for Float64
def #from[Float64] for String
def (Float64) <to> String -> String {
    ...
}


extend Int32 as #try-from[Float64] {
    def <try-from>(value: Float64) -> Option[Int32] {
        ...
    }
}


/*****/


def sum(values: Array[A]) -> B
    forall A #to[B], B #add
{
    values.fold(B.zero) {
        accum, v =>
            let b = v <to> B
            accum + b
    }
    values.fold(B.zero) { ___ + (___ <to> B) }
}
