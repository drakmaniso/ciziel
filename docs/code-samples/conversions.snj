module std


def #to[A] {
    has (Self) <to> A -> A
}


def #from[A] {
    has (A) <to> Self -> Self
}


-------------------------------------------------------------------------------


def Cartesian = struct {
    data x: Float64
    data y: Float64
}


def Polar = struct {
    data radius: Float64
    data angle: Float64
}


def (Polar) <to> Cartesian -> Cartesian {
    Cartesian(
        x = radius * math::cos(angle),
        y = radius * math::sin(angle),
    )
}


def (Cartesian) <to> Polar -> Polar {
    Polar(
        radius = math::sqrt((self.x ^ 2) + (self.y ^ 2))
        angle = math::atan2(self.y, self.x)
    )
}


-------------------------------------------------------------------------------


module float


def #to[Float64] for Int32
def #from[Int32] for Float64
def (Int32) <to> Float64 -> Float64 {
    ...
}


def #to[String] for Float64
def #from[Float64] for String
def (Float64) <to> String -> String {
    ...
}


extend Int32 as #try-from[Float64] {
    def <try-from>(value: Float64) -> Option[Int32] {
        ...
    }
}


/*****/


def sum(values: Array[A]) -> B
    forall A #to[B], B #add
{
    values.fold(B.zero) {
        accum, v =>
            let b = v <to> B
            accum + b
    }
    values.fold(B.zero) { ___ + (___ <to> B) }
}
