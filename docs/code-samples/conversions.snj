module std


def #to[A] {
    has (Self) <to> A -> A
}


module vectors


def Cartesian = struct {
    data x: Float64
    data y: Float64
}


def Polar = struct {
    data radius: Float64
    data angle: Float64
}


def #to[Cartesian] for Polar
def (Polar) <to> Cartesian -> Cartesian {
    Cartesian(
        x = self.radius * math::cos(self.angle),
        y = self.radius * math::sin(self.angle),
    )
}


def #to[Polar] for Cartesian
def (Cartesian) <to> Polar -> Polar {
    Polar(
        radius = math::sqrt((self.x ^ 2) + (self.y ^ 2))
        angle = math::atan2(self.y, self.x)
    )
}


module usage


use #to, #add from std


forall A #to[B], B #add
def sum(values: Array[A]) -> B {
    values.fold(B.zero) {
        accum, value =>
            accum + (value <to> B)
    }
}


-- #from ----------------------------------------------------------------------


module std


def #from[A] = trait {
    has Self <from> (other: A) -> Self
}



def #from[Polar] for Cartesian
def Cartesian <from> (other: Polar) -> Cartesian {
    Cartesian(
        x = other.radius * math::cos(other.angle),
        y = other.radius * math::sin(other.angle),
    )
}


def #from[Cartesian] for Polar
def Polar <from> (other: Cartesian) -> Polar {
    Polar(
        radius = math::sqrt((other.x ^ 2) + (other.y ^ 2))
        angle = math::atan2(other.y, other.x)
    )
}


module usage


use #to, #add from std


forall A, B #from[A], B #add
def sum(values: Array[A]) -> B {
    values.fold(B.zero) {
        accum, value =>
            accum + (B <from> value)
    }
}


-- Custom Constructors --------------------------------------------------------


module std


def #from[A] = trait {
    has Self(any: A) -> Self
}


def #from[Polar] for Cartesian
def Cartesian(polar: Polar) -> Cartesian {
    Cartesian(
        x = polar.radius * math::cos(polar.angle),
        y = polar.radius * math::sin(polar.angle),
    )
}


def #from[Cartesian] for Polar
def Polar(cartesian: Cartesian) -> Polar {
    Polar(
        radius = math::sqrt((cartesian.x ^ 2) + (cartesian.y ^ 2))
        angle = math::atan2(cartesian.y, cartesian.x)
    )
}


module usage


use #to, #add from std


forall A, B #from[A], B #add
def sum(values: Array[A]) -> B {
    values.fold(B.zero) {
        accum, value =>
            accum + (B <from> value)
    }
}
