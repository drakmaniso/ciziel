-- With Single Dispatch Only --------------------------------------------------


module vectors
public


struct Cartesian(x: Float64 y: Float64)
struct Polar(radius: Float64 angle: Float64)


fun (Polar).to-Cartesian -> Cartesian =
    Cartesian {
        x = self.radius * math::cos(self.angle),
        y = self.radius * math::sin(self.angle),
	}


fun (Cartesian).to-Polar -> Polar =
    Polar {
        radius = math::sqrt((self.x ^ 2) + (self.y ^ 2)),
        angle = math::atan2(self.y, self.x),
	}


module usage
import /std(#add)
public


forall B #add
fun sum(values: Array[A], to-B: A -> B) -> B =
	values.fold(
		B.zero,
		(accum, value) => accum + to-B(value)
	)


-- With Single Dispatch and Magic Methods -------------------------------------


module std
public


trait #to[A] {
	-- (Self).to-A -> A
}


-- -- forall A #to[B]
-- fun (A) to B -> B =
-- 	self.to-B


module vectors


-- (same as above)


module usage


use /std(#to, #add)


public


forall A #to[B], B #add
fun sum(values: Array[A]) -> B =
	values.fold(
		B.zero,
		(accum, value) => accum + (value <to> B)
	)



-- With Double-Dispatch -------------------------------------------------------


module /std
public


trait #to[A] {
	fun (Self) <to> A -> A
}


module vectors


public


struct Cartesian(x: Float64 y: Float64)
struct Polar(radius: Float64 angle: Float64)


trait #to[Cartesian] for Polar
fun (Polar) <to> Cartesian -> Cartesian =
    Cartesian {
        x = self.radius * math::cos(self.angle),
        y = self.radius * math::sin(self.angle),
	}


trait #to[Polar] for Cartesian
fun (Cartesian) <to> Polar -> Polar =
    Polar {
        radius = math::sqrt((self.x ^ 2) + (self.y ^ 2)),
        angle = math::atan2(self.y, self.x),
	}


module usage
import /std (#to, #add)
public


forall A #to[B], B #add
fun sum(values: Array[A]) -> B =
	values.fold(
		B.zero,
		(accum, value) => accum + (value <to> B)
	)


-- #from ----------------------------------------------------------------------


module std


trait #from[A] {
	fun Self <from> (other: A) -> Self
}


module vectors


struct Cartesian(x: Float64 y: Float64)
struct Polar(radius: Float64 angle: Float64)


trait #from[Polar] for Cartesian


fun Cartesian <from> (other: Polar) -> Cartesian =
    Cartesian {
        x = other.radius * math::cos(other.angle),
        y = other.radius * math::sin(other.angle),
	}


trait #from[Cartesian] for Polar


fun Polar <from> (other: Cartesian) -> Polar =
    Polar {
        radius = math::sqrt((other.x ^ 2) + (other.y ^ 2))
        angle = math::atan2(other.y, other.x)
	}


module usage
import /std(#from, #add)


forall B #from[A] #add
fun sum(values: Array[A]) -> B =
	values.fold(
		B.zero,
		(accum, value) =>
			accum + (B <from> value)
	)


-- Magic Constructors ---------------------------------------------------------


module std


trait #from[A] {
	fun Self.from(A) -> Self
}


module vectors


struct Cartesian(x: Float64 y: Float64)
struct Polar(radius: Float64 angle: Float64)


trait #from[Polar] for Cartesian
fun Cartesian.from(polar: Polar) -> Cartesian =
    Cartesian {
        x = polar.radius * math::cos(polar.angle),
        y = polar.radius * math::sin(polar.angle),
	}


trait #from[Cartesian] for Polar
fun Polar.from(cartesian: Cartesian) -> Polar =
    Polar {
        radius = math::sqrt((cartesian.x ^ 2) + (cartesian.y ^ 2)),
        angle = math::atan2(cartesian.y, cartesian.x),
	}


module usage
import /std(#from, #add)


forall B #from[A], B #add
fun sum(values: Array[A]) -> B =
	values.fold(
		B.zero,
		(accum, value) => accum + (B <from> value)
	)
