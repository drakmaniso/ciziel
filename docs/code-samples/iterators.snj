------ Standard traits for iterators ------------------------------------------
module std/iter

trait #iterable =
    Self'Iterator #next
    (Self).iterator -> Self'Iterator

trait #iterator =
    Self'Item #any
    (Self).next -> (Self, Option[Self'Item])


------ Simple iterator example ------------------------------------------------
module counter

unique struct Counter =
    count: Int
    limit: Int
    implement #iterator

func Counter'new(limit: Int) -> Counter =
    Counter{count: 0, limit: limit}

alias Counter'Item = Int

func (Counter).next -> (Counter, Option[Int]) =
    if counter.count >= counter.limit then
        (counter, None)
    else
        count = &counter.count
        (
            counter.with{count: count + 1},
            Some(count),
        )

func test_Counter() =
    counter = Counter.new(6)
    assert counter.next! == Some(1)
    assert counter.next! == Some(2)
    assert counter.next! == Some(3)
    assert counter.next! == Some(4)
    assert counter.next! == Some(5)
    assert counter.next! == None

let example-loop() -> Io[()] =
    counter = Counter'new(7)
    step(counter)
    where
        step(counter) =
            match counter.next
            case (_, None) then
                Io'print("Done!")
            case (rest, Some(number)) then
                do Io'print("{number}...")
                step(rest)


----
module main

use std'iter (Iterator)

forall I #iterator
func foo(iterator: I, f: I.Item -> Int) -> Array[Int] =
    iterator.fold(
        [],
        \(array, item) =>
            [...array, item]
    )

forall I #iterator, J #iterator, I.Item == J.Item
func compare(i: I, j: J) -> Bool =
    match (i.next, j.next)
    case
        ((rest-i, Some(item-i),
            (rest-j, Some(item-j))
    then
        if item-i == item-j then
            compare(rest-i, rest-j)
        else
            False

    case ((_, None), (_, None)) then True

    case _ then False
