/*
## Standard traits for iterators ##############################################
*/


module std::iter


def #iterable {
    has ::Iterator: #iterator
    has .iterator() -> Self::Iterator
}


def #iterator {
    has ::Item
    has .next() -> (Self, Maybe[Self::Item])
}


/*
## Simple iterator example ####################################################
*/


module counter


use std::iter { #iterator }


def Counter(
    let count: Int,
    def limit: Int,
)


extend Counter {
    def ::new(limit: Int) -> Counter {
        Counter(count: 0, limit: limit)
    }
}


extend Counter as #iterator {
    def ::Item = Int

    def .next() -> (Counter, Maybe[Int]) {
        if self.count >= self.limit {
            ( self, None )
        } else {
            let count = self.count
            let new-counter = self.with(count: count + 1)
            ( new-counter, Some(count) )
        }
    }
}


let example() -> Io[] {
    let step(c) {
        match c.next {
            case (_, None) =>
                Io::print("Done!")
            case (rest, Some(number)) =>
                Io::print("{number}, ")
                step(rest)
        }
    }
    
    let counter = Counter::new(7)
    step(counter)
}


-------------------------------------------------------------------------------


module main


use std::iter { #iterator }


forall I: #iterator
let foo(iterator: I, f: fun(I::Item) -> Int) -> Array[Int] {
    iterator.fold(Array(), Array::push)
}


forall
    I: #iterator,
    J: #iterator,
    I::Item == J::Item,
    I::Item: #eq
let compare(i: I, j: J) -> Bool {
    match (i.next(), j.next()) {
        case ( (_, None), (_, None) ):
            True

        case ( (i-next, Some(a)), (j-next, Some(b)) ):
            if a == b {
                compare(i-next, j-next)
            } else {
                False
            }

        case _:
            False
    }
}