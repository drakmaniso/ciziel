------ Standard traits for iterators ------------------------------------------

module std/iter

public #iterable =
    has Self.Iterator #iterator
    has (Self).iterator -> Self.Iterator

public #iterator =
    has Self.Item
    has (Self).next -> (Self, Maybe[Self.Item])

------ Simple iterator example ------------------------------------------------

module counter

public Counter =
    struct {
        opaque count: Int,
        limit: Int,
    }
    impl #iterator

public Counter.new(limit: Int) -> Counter =
    Counter { count: 0, limit: limit }

public Counter.Item = alias Int

public (Counter).next -> (Counter, Maybe[Int]) =
    if self.count >= self.limit then
        (self, None)
    else
        count = self.count
        new-counter = self.with { count = count + 1 }
        (new-counter, Some(count))

local example() -> Io[] =
    step = fun(c) ->
        match c.next
        case (_, None) then
            Io.print("Done!")
        case (rest, Some(number)) then
            Io.do {
                Io.print("{number}, ")
                step(rest)
            }
        end
    
    counter = Counter.new(7)
    step(counter)

----

module main

use std::iter (Iterator)

local foo(iterator: I, f: Func(I.Item) -> Int) -> Array[Int]
    forall I #iterator
=
    iterator.fold([], => [...___, ___])

local compare(i: I, j: J) -> Bool
    forall I #iterator, J #iterator, I.Item == J.Item
=
    match (i.next, j.next)
    case ((_, None), (_, None)) then
        True

    case ((i-next, Some(a), (j-next, Some(b)) then
        if a == b then
            compare(i-next, j-next)
        else
            False

    else False
