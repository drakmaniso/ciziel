module /std --- Standard traits for iterators ---------------------------------


public


trait #iterable {
    type Self.Iterator #iterator
    fun (Self).iterator -> Self.Iterator
}


trait #iterator {
    type Self.Item
	fun (Self).peek -> Self.Item?
	fun (Self).next -> Self
    fun (Self).peek-next -> (Self, Self.Item?)
}


module counter --- Simple iterator example ------------------------------------


use /std (#iterator)
use /std/io (&io)


public


struct Counter {
    count: Int
    limit: public Int
}


fun Counter.new(limit: Int) -> Counter =
    Counter { count = 0, limit = limit }


Counter: #iterator


type Counter.Item = Int


fun (Counter).peek -> Int? =
	if self.count >= self.limit then None
	else Ok(self.count)


fun (Counter).next -> Counter =
	if self.count >= self.limit then self
	else self.with { count = count + 1 }


fun (Counter).next -> (Counter, Int?) =
    if self.count >= self.limit then
        (self, None)
    else
        count = self.count
        new-counter = self.with(count: count + 1)
        (new-counter, Ok(count))


fun example() -> Nil &io =
    fun step(c) =
        case c.next()
		of (_, None) =>
			io.print("Done!")
		of (rest, Ok(number)) =>
			io.print("{number}, ")
			step(rest)

    counter = Counter.new(7)
    step(counter)


module main --- Usage ---------------------------------------------------------


use /std/iter (#iterator)


private


fun foo(iterator: I, f: I.Item -> Int) -> Array[Int]
	forall I: #iterator
	=
    iterator.fold(Array(), Array.push)


fun compare(i: I, j: J) -> Bool =
	forall I: #iterator
		and J: #iterator
		and I.Item == J.Item
		and I.Item #eq
	=
    case (i.peek, j.peek)
	of (None, None) then True
	of (Ok(a), Ok(b)) and (a == b) then compare(i-next, j-next)
	else False
