------ Standard traits for iterators ------------------------------------------
module std/iter

define #iterable =
    trait {
        Self.Iterator #iterator
        (Self).iterator -> Self.Iterator
    }

define #iterator =
    trait {
        Self.Item
        (Self).next -> (Self, Maybe[Self.Item])
    }

------ Simple iterator example ------------------------------------------------
module counter

define Counter =
    struct {
        opaque count: Int,
        limit: Int,
    }
    impl #iterator

define Counter.new(limit: Int) -> Counter =
    Counter { count: 0, limit: limit }

define Counter.Item = alias Int

define (Counter).next -> (Counter, Maybe[Int]) =
    if self.count >= self.limit then
        (self, None)
    else
        count = self.count
        new-counter = self.with { count = count + 1 }
        (new-counter, Some(count))

local example() -> Io[] =
    step = fun(c) ->
        match c.next
        case (_, None) then
            Io.print("Done!")
        case (rest, Some(number)) then
            Io.do {
                Io.print("{number}, ")
                step(rest)
            }
    
    counter = Counter.new(7)
    step(counter)


----
module main

use std'iter (Iterator)

local foo(iterator: I, f: Func(I.Item) -> Int) -> Array[Int]
        forall I #iterator
    =
    iterator.fold([], => [...___, ___])

local compare(i: I, j: J) -> Bool
        forall I #iterator, J #iterator, I.Item == J.Item
    =
    match (i.next, j.next)
    case ((_, None), (_, None)) then
        True

    case ((i-next, Some(a), (j-next, Some(b)) then
        if a == b then
            compare(i-next, j-next)
        else
            False

    else False
