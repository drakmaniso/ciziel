module geom
use std::vec { Point }


def Shape = 
    | Circle
    | BBox
    | Square
    | Rectangle
    | Polygon


def Circle {
    var .center: Point
    var .radius: Float6
}


def BBox {
    def .min: Point
    def .max: Point
}


def Square {
    var .origin: Point
    var .side: Int
}


def Rectangle {
    var .origin: Point
    var .width: Int
    var .height: Int
}


def Polygon {
    def .points: Array[Point]
}


def #movable {
    has .move-to(destination: Point) -> Type
}


def #scalable {
    has .scale-by(factor: Float64) -> Type
}


def #origin {
    has Self(origin: Point, ...)

    for Self as #movable {
        def .move-to(destination: Point) -> Self {
            self.with(origin = destination)
        }
    }
}


def switch-places(shape-1: S1, shape-2: S2) -> (S1, S2)
forall S1: #origin, S2: #origin {
    let o1 = shape-1.origin
    let o2 = shape-2.origin
    ( shape-1.with(origin = o2), shape-2.with(origin = o1) )
}


for Circle {
    def ::bounding-of(points: Array[Point]) -> Circle {
        let welzl(points, boundary) {
            match points {
            case _ and boundary.length() == 3 =>
                trivial(boundary)

            case Array() =>
                trivial(boundary)

            case Array(p, rest) =>
                let d = welzl(points.remove(p), boundary)
                if d.encloses(p) {
                    d
                } else {
                    welzl(points.remove(p), boundary.push(p))
                }
            }
        }

        welzl(points, [])
    }

    def .diameter -> Float64 {
        self.radius * 2
    }

    def .perimeter -> Float64 {
        math::pi * self.diameter
    }

    def .area -> Float64 {
        math::pi * (self.radius ** 2)
    }
}


for Circle as #origin #movable {
    def .origin -> Point {
        self.center
    }
}


for Circle as #scalable {
    def .scale-by(factor: Float64) -> Circle {
        self.with(radius = self.radius * factor)
    }
}


for BBox {
    def ::new(a: Point, b: Point) -> BBox {
        let (min-x, max-x) = (a.x, b.x).sorted()
        let (min-y, max-y) = (a.y, b.y).sorted()
        
        BBox(
            min = Point(min-x, min-y),
            max = Point(max-x, max-y),
        )
    }
}


for BBox as #movable {    
    def .move-to(destination: Point) -> BBox {
        let size = self.max - self.min
        self.with(
            min = destination
            max = destination + size
        )
    }
}


for Polygon {
    def ::new(...points: Array[Point]) -> Polygon {
        Polygon(points)
    }

    def [index: Int] -> Point {
        self.points[index]
    }
}
