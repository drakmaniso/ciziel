module geom --- A simple example of algebraic types ---------------------------


import /std/vec (Point)
import /std/math


public ------------------------------------------------------------------------


type Basic-Shape =
	| Circle
	| Triangle
	| Rectangle
	| BBox


struct Circle {
	center: data Point,
	radius: data Float64,
	require radius >= 0
}


struct Triangle {
	a: data Point,
	b: data Point,
	c: data Point,
}


struct Rectangle {
	origin: data Point,
	width: data Float64,
	height: data Float64,
	angle: data Float64,
	require width >= 0
	require height >= 0
	require 0 <= angle <= 2 * math.pi
}


struct BBox {
	min: data Point,
	max: data Point,
	require min <= max
}


struct Polygon {
	points: data Array[Point],
	require points.length >= 3
}


trait #shape {
	fun (Self).perimeter -> Float64
	fun (Self).area -> Float64
	fun (Self).move-by(delta: Point) -> Self
	fun (Self).scale-by(factor: Float64) -> Self
}


trait #shape for Basic-Shape


public --- Circle Methods -----------------------------------------------------


fun Circle.around(points: Array Point) -> Circle =
	fun welzl(points, boundary) =
		case points
		of []
		of _ and (boundary.length == 3) then
			trivial(boundary)

		of [p, ...rest] then
			c = welzl(rest, boundary)
			if c.encloses(p) then c
			else welzl(rest, boundary.push(p))
		end

	welzl(points, [])


fun (Circle).diameter -> Float64 =
	self.radius * 2


trait #shape for Circle


fun (Circle).perimeter -> Float64 =
	math.pi * self.diameter


fun (Circle).area -> Float64 =
	math.pi * (self.radius ** 2)


fun (Circle).move-by(delta: Point) -> Circle =
	self.with { center += delta }


fun (Circle).scale-by(factor: Float64) -> Circle =
	self.with { radius *= factor }


public --- Triangle Methods ---------------------------------------------------


trait #shape for Triangle


fun (Triangle).perimeter -> Float64 =
	distance(a, b) + distance(b, c) + distance(c, a)


fun (Triangle).area -> Float64 =
	0.5 * math.abs(
		(a.x * (b.y - c.y))
		+ (b.x * (c.y - a.y))
		+ (c.x * (a.y - b.y))
	)


fun (Triangle).move-by(delta: Vec2) -> Triangle =
	self.with { a += delta, b += delta, c += delta }


fun (Triangle).scale-by(factor: Vec2) -> Triangle =
	center = self.center
	self.with {
		a = center + (factor * (self.a - center)),
		b = center + (factor * (self.b - center)),
		c = center + (factor * (self.c - center)),
	}


public --- BBox Methods -------------------------------------------------------


fun BBox.new(a: Point, b: Point) -> BBox =
	xs = (a.x, b.x)
	ys = (a.y, b.y)

	BBox {
		min = Point(min(...xs), min(...ys)),
		max = Point(max(...xs), max(...ys)),
	}


fun (BBox).width -> Float64 =
	self.max.x - self.min.x


fun (BBox).height -> Float64 =
	self.max.y - self.min.y


fun (BBox).size -> Vec2 =
	Vec2(self.width, self.height)


trait #shape for BBox


fun (BBox).perimeter -> Float64 =
	2 * (self.width + self.height)


fun (BBox).area -> Float64 =
	self.width * self.height


fun (BBox).move-by(delta: Vec2) -> BBox =
	self.with {
		min += delta,
		max += delta
	}


fun (BBox).scale-by(factor: Float64) -> BBox =
	size-delta = (factor * self.size) - self.size

	self.with {
		min -= size-delta / 2,
		max += size-delta / 2,
	}


public --- Rectangle Methods --------------------------------------------------


fun Rectangle.new {
	origin: Point,
	width: Float64,
	height: Float64,
	angle: Float64,
} -> Rectangle =
	val (ox', width') =
		if width < 0 then
			(origin.x - width, - width)
		else
			(origin.x, width)

	val (oy', height') =
		if height < 0 then
			(origin.y - height, - height)
		else
			(origin.y, height)

	Rectangle {
		origin = Point(ox', oy'),
		width = width',
		height = height',
		angle = angle <mod> (2 * math.pi),
	}


fun (Rectangle).size -> Vec2 =
	Vec2(self.width, self.height)


trait #shape for Rectangle


fun (Rectangle).perimeter -> Float64 =
	2 * (self.width + self.height)


fun (Rectangle).area -> Float64 =
	self.width * self.height


fun (Rectangle).move-by(delta: Point) -> Rectangle =
	self.with { origin += delta }


fun (Rectangle).scale-by(factor: Float64) -> Rectangle =
	self.with {
		width *= factor,
		height *= factor,
	}


public --- Polygon Methods ----------------------------------------------------


fun Polygon.new(...points: Array[Point]) =
	require points.length >= 3
	Polygon(points)


fun (Polygon)[index: Int] -> Point =
	require 0 <= index < self.points.length
	self.points[index]


fun (Polygon)[range: Range[Int]] -> Array[Point] =
	self.points[range]
