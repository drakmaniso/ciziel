module geom

use std::vec (Point)


def Shape =
	| Circle
	| BBox
	| Square
	| Rectangle
	| Polygon


def Circle {
	var center: Point
	var radius: Float64
}


def Triangle {
	var a: Point
	var b: Point
	var c: Point
}


def Rectangle {
	var origin: Point
	def width: Float64
	def height: Float64
	def angle: Float64
}


def BBox {
	def min: Point
	def max: Point
}


def Polygon {
	def points: Array[Point]
}


def #shape {
	has perimeter(self) -> Float64
	has area(self) -> Float64
}


def #movable {
	has move-to(self, destination: Point) -> Self
}


def #scalable {
	has scale-by(self, factor: Float64) -> Self
}


// Circle /////////////////////////////////////////////////////////////////////


extend Circle {
	def around(points: Array[Point]) -> Circle {
		let welzl(points, boundary) {
			match points {
			case _ and boundary.length() == 3:
				trivial(boundary)

			case []:
				trivial(boundary)

			case [p, ...rest]:
				d = welzl(points.remove(p), boundary)
				if d.encloses(p) {
					d
				} else {
					welzl(points.remove(p), boundary.push(p))
				}
			}
		}

		welzl(points, [])
	}

	def diameter(self) -> Float64 {
		self.radius * 2
	}
}


extend Circle as #shape {
	def perimeter(self) -> Float64 {
		math::pi * self.diameter()
	}

	def area(self) -> Float64 {
		math::pi * (self.radius ** 2)
	}
}


extend Circle as #movable {
	def move(self, destination: Point) -> Circle {
		self.with(center: destination)
	}
}


extend Circle as #scalable {
	def scale-by(self, factor: Float64) -> Circle {
		self.with(radius: self.radius * factor)
	}
}


// BBox ///////////////////////////////////////////////////////////////////////


extend BBox {
	def new(a: Point, b: Point) -> BBox {
		xs = (a.x, b.x)
		ys = (a.y, b.y)

		BBox(
			min = Point(min(...xs), min(...ys)),
			max = Point(max(...xs), max(...ys)),
		)
	}


	def width(self) -> Float64 {
		self.max.x - self.min.x
	}


	def height(self) -> Float64 {
		self.max.y - self.min.y
	}


	def size(self) -> Vec2 {
		Vec2(self.width(), self.height())
	}
}



extend BBox as #shape {
	def perimeter(self) -> Float64 {
		(2 * self.width()) + (2 * self.height())
	}


	def area(self) -> Float64 {
		self.width() * self.height()
	}
}


extend BBox as #movable {
	def move-to(destination: Point) -> BBox {
		self.with(min: destination, max: destination + self.size())
	}
}


extend BBox as #scalable {
	def scale-by(self, factor: Float64) -> BBox {
		delta = (factor * self.size) - self.size
		self.with(
			min: self.min - (delta / 2),
			max: self.max + (delta / 2),
		)
	}
}


// Rectangle //////////////////////////////////////////////////////////////////



extend Rectangle {
	def new(
		origin: Point,
		width: Float64,
		height: Float64,
		angle: Float64,
	) {
		Rectangle(
			origin,
			width: min(0, width),
			height: min(0, height),
			angle: angle <mod> (2 * math::pi),
		)
	}


	def size(self) -> Vec2 {
		Vec2(self.width, self.height)
	}
}


extend Rectangle as #shape {
	def perimeter(self) -> Float64 {
		2 * (self.width + self.height)
	}


	def area(self) -> Float64 {
		self.width * self.height
	}
}


extend Rectangle as #movable {
	def move-to(self, destination: Point) -> Rectangle {
		self.with(origin: destination)
	}
}


extend Rectangle as #scalable {
	def scale-by(self, factor: Float64) -> Rectangle {
		self.with(
			width: self.width * factor,
			height: self.height * factor,
		)
	}
}


// Polygon ////////////////////////////////////////////////////////////////////


extend Polygon {
	def new(...points: Array[Point]) {
		Polygon(points)
	}


	def [](self, index: Int) -> Point {
		self.points[index]
	}
}
