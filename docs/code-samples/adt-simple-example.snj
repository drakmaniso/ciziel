module geom
use std::vec (Point)


public Shape =
    enum(Circle | Square | Rectangle)


public #movable =
    has (Self).move-to(destination: Point) -> Self
    implement Circle, BBox


public #scalable =
    has (Self).scale-by(factor: Float32) -> Self
    implement Circle, BBox


local #with-center =
    has Self { center: Point, ... }

    has (Self).move-to(destination: Point) =
        self.with { center = destination }
    
    implement Circle


local switch-places(shape-1: A, shape-2: B) -> (A, B)
    forall A #with-center, B #with-center
=
    let c1 = shape-1.center
    let c2 = shape-2.center
    (shape-1.with { center = c2 }, shape-2.with { center = c1 })


public Circle =
    struct {
        center: Point,
        radius: Float32,
    }
    has #movable, #scalable
    has #with-center


public Circle.bounding-of(points: Array[Point]) -> Circle =
    let welzl(points, boundary) =
        match points
        case _ and boundary.length() == 3 then
            trivial(boundary)

        case [] then
            trivial(boundary)

        case [p, rest] then
            d = welzl(points.remove(p), boundary)
            if d.encloses(p) then
                d
            else
                welzl(points.remove(p), boundary.push(p))
        end

    welzl(points, [])


public (Circle).diameter() -> Float32 =
    self.radius * 2


public (Circle).perimeter() -> Float32 =
    math::pi * self.diameter()


public (Circle).area() -> Float32 =
    math::pi * (self.radius ** 2)


public (Circle).scale-by(factor: Float32) -> Circle =
    self.with{radius: self.radius * factor}


public BBox =
    struct {
        min: Point,
        max: Point,
        local _: () = (),
    }
    has #movable, #scalable


public BBox.new(a: Point, b: Point) -> BBox =
    min-x, max-x = ...((a.x, b.x).sorted)
    min-y, max-y = ...((a.y, b.y).sorted)
    
    BBox {
        min = Point(min-x, min-y),
        max = Point(max-x, max-y),
    }


public Square =
    struct {
        center: Point,
        side: Int,
    }
    has #movable
    has #scalable
    has #with-center


public Rectangle =
    struct {
        center: Point,
        width: Int,
        height: Int,
    }
    has #movable
    has #scalable
    has #with-center


public Polygon =
    struct {
        ...points: Array[Point]
    }
    has #movable
    has #scalable
