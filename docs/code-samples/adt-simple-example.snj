module geom
use std::vec { Point }


def Shape =
    | Circle
    | BBox
    | Square
    | Rectangle
    | Polygon


def Circle(
    var center: Point,
    var radius: Float64,
)


def Triangle(
    var a: Point,
    var b: Point,
    var c: Point,
)


def Rectangle(
    var origin: Point,
    var width: Float64,
    var height: Float64,
    def angle: Float64,
)


def BBox(
    def min: Point,
    def max: Point,
)


def Polygon(
    def ...points: Array[Point],
)


def #shape {
    has .perimeter() -> Float64
    has .area() -> Float64
}


def #movable {
    has .move-to(destination: Point) -> Self
}


def #scalable {
    has .scale-by(factor: Float64) -> Self
}


-- Circle ---------------------------------------------------------------------


extend Circle {
    def ::bounding-of(points: Array[Point]) -> Circle {
        let welzl(points, boundary) {
            match points {
            case _ and boundary.length() == 3:
                trivial(boundary)

            case Array():
                trivial(boundary)

            case Array(p, rest):
                let d = welzl(points.remove(p), boundary)
                if d.encloses(p) {
                    d
                } else {
                    welzl(points.remove(p), boundary.push(p))
                }
            }
        }

        welzl(points, [])
    }

    def .diameter() -> Float64 {
        self.radius * 2
    }
}


extend Circle as #shape {
    def .perimeter() -> Float64 {
        math::pi * self.diameter()
    }

    def .area() -> Float64 {
        math::pi * (self.radius ** 2)
    }
}


extend Circle as #movable {
    def .move(destination: Point) -> Circle {
        self.with(center = destination)
    }
}


extend Circle as #scalable {
    def .scale-by(factor: Float64) -> Circle {
        self.with(radius = self.radius * factor)
    }
}


-- BBox -----------------------------------------------------------------------


extend BBox {
    def ::new(a: Point, b: Point) -> BBox {
        let xs = (a.x, b.x)
        let ys = (a.y, b.y)

        BBox(
            min = Point(min(...xs), min(...ys)),
            max = Point(max(...xs), max(...ys)),
        )
    }


    def .width() -> Float64 {
        self.max.x - self.min.x
    }
    
    
    def .height() -> Float64 {
        self.max.y - self.min.y
    }
    

    def .size() -> Vec2 {
        Vec2(self.width(), self.height())
    }


    def .perimeter() -> Float64 {
        (2 * self.width()) + (2 * self.height())
    }


    def .area() -> Float64 {
        self.width() * self.height()
    }
}


extend BBox as #movable {    
    def .move-to(destination: Point) -> BBox {
        self.with(
            min = destination
            max = destination + self.size()
        )
    }
}


extend BBox as #scalable {    
    def .scale-by(factor: Float64) -> BBox {
        let delta = (factor * self.size()) - self.size()
        self.with(
            min = self.min - (delta / 2)
            max = self.max + (delta / 2)
        )
    }
}


extend Polygon {
    def ::new(...points: Array[Point]) -> Polygon {
        Polygon(points)
    }

    def [index: Int] -> Point {
        self.points[index]
    }
}
