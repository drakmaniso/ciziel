<< A simple example using algebraic data types >>
module geom
use /std/vec (Point)
use /std/math


public ------------------------------------------------------------------------


#vector =
	has Self.Scalar: #num
	has Self.zero: Self.Scalar
	has (Self).length -> Float
	has (Self).normalized -> Self
	has (Self) + (other: Self) -> Self
	has (Self) - (other: Self) -> Self
	has (Self) * (other: Self.Scalar) -> Self


#vec2 =
	has Self: #vector

	has Self(x: Self.Scalar, y: Self.Scalar) -> Self

	has Self.zero: Self =
		Self(Self.Scalar.zero, Self.Scalar.zero)

	has (Self).length -> Self.Scalar =
		math.sqrt((self.x * self.x) + (self.y * self.y))

	has (Self).normalized -> Self.Scalar =
		l = self.length
		Self(self.x / l, self.y / l)

	has (Self) + (other: Self) -> Self =
		Self(self.x + other.x, self.y + other.y)

	has (Self) - (other: Self) -> Self =
		Self(self.x - other.x, self.y - other.y)

	has (Self) * (other: Self.Scalar) -> Self =
		Self(self.x * other, self.y * other)


Vec2: #vec2 #vector =
	struct(
		x: data Float,
		y: data Float,
	)


Vec2.Scalar =
	Float64


Point =
	struct(
		x: data Float,
		y: data Float,
	)


Point.Scalar =
	Float64


(Point) + (other: Vec2) -> Point =
	Point(self.x + other.x, self.y + other.y)


(Point) - (other: Vec2) -> Point =
	Point(self.x - other.x, self.y - other.y)


(Point).distance(other: Point) -> Float =
	self' = self as Vec2
	other' = other as Vec2
	(self' - other').length


(Point).as-Vec2 -> Vec2 =
	Vec2(self.x, self.y)


(Vec2).as-Point -> Point =
	Point(self.x, self.y)


public ------------------------------------------------------------------------


Basic-Shape =
	| Circle
	| Triangle
	| Rectangle
	| BBox


Circle =
	struct {
		center: data Point,
		radius: data Float64,
	}
	require radius >= 0


Triangle =
	struct {
		a: data Point,
		b: data Point,
		c: data Point,
	}


Rectangle =
	struct {
		origin: data Point,
		width: data Float64,
		height: data Float64,
		angle: data Float64,
	}
	require width >= 0
		and height >= 0
		and 0 <= angle <= 2 * math.pi


BBox =
	struct {
		min: data Point,
		max: data Point,
	}
	require min <= max


Polygon =
	struct {
		points: data Array[Point],
	}
	require points.length >= 3


#shape =
	trait {
		(Self).perimeter -> Float64
		(Self).area -> Float64
		(Self).move-by(delta: Point) -> Self
		(Self).scale-by(factor: Float64) -> Self
	}


Basic-Shape: #shape


public --- Circle Methods -----------------------------------------------------


Circle.around(points: Array Point) -> Circle =
	welzl(points, boundary) =
		case points
		of []
		of _ and (boundary.length == 3) then
			trivial(boundary)

		of [p, ...rest] then
			c = welzl(rest, boundary)
			if c.encloses(p) then c
			else welzl(rest, boundary.push(p))
		end

	welzl(points, [])


(Circle).diameter -> Float64 =
	self.radius * 2


Circle: #shape


(Circle).perimeter -> Float64 =
	math.pi * self.diameter


(Circle).area -> Float64 =
	math.pi * (self.radius ** 2)


(Circle).move-by(delta: Vec2) -> Circle =
	self.with { center += delta }


(Circle).scale-by(factor: Float64) -> Circle =
	self.with { radius *= factor }


public --- Triangle Methods ---------------------------------------------------


(Triangle).perimeter -> Float64 =
	distance(a, b) + distance(b, c) + distance(c, a)


(Triangle).area -> Float64 =
	0.5 * math.abs(
		(a.x * (b.y - c.y))
		+ (b.x * (c.y - a.y))
		+ (c.x * (a.y - b.y))
	)


(Triangle).move-by(delta: Vec2) -> Triangle =
	self.with { a += delta, b += delta, c += delta }


(Triangle).scale-by(factor: Vec2) -> Triangle =
	center = self.center

	self.with {
		a = center + (factor * (self.a - center)),
		b = center + (factor * (self.b - center)),
		c = center + (factor * (self.c - center)),
	}


public --- BBox Methods -------------------------------------------------------


BBox.new(a: Point, b: Point) -> BBox =
	xs = (a.x, b.x)
	ys = (a.y, b.y)

	BBox {
		min = Point(min(...xs), min(...ys)),
		max = Point(max(...xs), max(...ys)),
	}


(BBox).width -> Float64 =
	self.max.x - self.min.x


(BBox).height -> Float64 =
	self.max.y - self.min.y


(BBox).size -> Vec2 =
	Vec2(self.width, self.height)


BBox: #shape


(BBox).perimeter -> Float64 =
	2 * (self.width + self.height)


(BBox).area -> Float64 =
	self.width * self.height


(BBox).move-by(delta: Vec2) -> BBox =
	self.with {
		min += delta,
		max += delta
	}


(BBox).scale-by(factor: Float64) -> BBox =
	size-delta = (factor * self.size) - self.size

	self.with {
		min -= size-delta / 2,
		max += size-delta / 2,
	}


public --- Rectangle Methods --------------------------------------------------


Rectangle.new {
	origin: Point,
	width: Float64,
	height: Float64,
	angle: Float64,
} -> Rectangle =
	(ox', width') =
		if width < 0 then
			(origin.x - width, - width)
		else
			(origin.x, width)
		end

	(oy', height') =
		if height < 0 then
			(origin.y - height, - height)
		else
			(origin.y, height)
		end

	Rectangle {
		origin = Point(ox', oy'),
		width = width',
		height = height',
		angle = angle <mod> (2 * math.pi),
	}


(Rectangle).size -> Vec2 =
	Vec2(self.width, self.height)


Rectangle: #shape


(Rectangle).perimeter -> Float64 =
	2 * (self.width + self.height)


(Rectangle).area -> Float64 =
	self.width * self.height


(Rectangle).move-by(delta: Point) -> Rectangle =
	self.with { origin += delta }


(Rectangle).scale-by(factor: Float64) -> Rectangle =
	self.with {
		width *= factor,
		height *= factor,
	}


public --- Polygon Methods ----------------------------------------------------


Polygon.new(...points: Array[Point]) =
	require points.length >= 3
	Polygon(points)


(Polygon).[](index: Int) -> Point =
	require 0 <= index < self.points.length
	self.points[index]


(Polygon).[](range: Range[Int]) -> Array[Point] =
	self.points[range]
