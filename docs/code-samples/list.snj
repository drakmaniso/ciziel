[[ # Linked List ]]


module std::list


use std::iter { #iterator, #iterable }


def List[A] = union(Empty | *Node[A])
def Empty = struct()
def Node[A] = struct(var item: A, var tail: List[A])


for List[A] {
    def ::new(...items: Array[A]) -> List[A] {
        items.rev-fold(Empty) \ item, acc {
            List.Node(item, acc)
        }
    }
}


[[ ## Equality ############################################################# ]]


for List[A] as #eq forall A: #eq {
    def operator self == (other: List[A]) -> Bool {
        match (self, other) {
            case (Empty, Empty) =>
                True
            case (a: Node, b: Node) =>
                a == b
            case (_, _) =>
                False
    }
}


for Empty as #eq {
    def operator self == (other: Empty) -> Bool {
        True
    }
}


for Node[A] as #eq forall A: #eq {
    def operator self == (other: Node[A]) -> Bool {
        self.item == other.item
            and self.tail == other.tail
    }
}


[[ ## Pushing and Poping ################################################### ]]


for List[A] {
    def .push(item: A) -> *Node[A] {
        Node(item, self)
    }

    def .head -> Option[A] {
        match self {
            case Empty => None
            case Node(item, ...) => Some(item)
        }
    }

    derive .tail -> List[A]
}


for Empty {
    def .tail -> List[A] {
        Empty
    }
}


[[ ## Functor Implementation ############################################### ]]


for List[A] as #functor forall A {
    def .map(transform: func(A) -> B) -> List[B] forall B {
        match self {
            case Empty =>
                Emtpy
            
            case Node(item, tail) =>
                Node(transform(item), tail)
        }
    }
}


[[ ## Iterator Implementation ############################################## ]]


for List[A] as #iterable {
    def ::Iterator = List-Iterator[A]

    def .iterator -> List-Iterator[A] {
        List-Iterator(self)
    }
}


def List-Iterator[A] {
    let .current: List[A]
}


for List-Iterator[A] as #iterator {
    def ::Item = A

    def .next -> (List-Iterator[A], Option[A]) {
        match self.current {
            case Empty =>
                (self, None)

            case Node(item, tail) =>
                let new-self = self.with(current = tail)
                (new-self, Some(item))
        }
    }
}


[[ ## Usage ################################################################ ]]


module main


use std::list { List, Node, Empty }


let double(list: List[Int]) -> List[Int] {
    list.map(___ * 2)
}


let main() -> Io[] =
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

        Io.print(type-of(a))
        --> Node[Int]

        Io.print(type-of(b))
        --> List[Int]

        Io.print(type-of(a.map))
        --> fun(Node[Int], fun(Int) -> A) -> Node[A]
    }
}
