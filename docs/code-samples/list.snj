[[ # Linked List ]]
module std::list


use std::iter { #iterator, #iterable }


def List[A] = Empty | *Node[A]
def Empty
def Node[A] {
    var .item: A
    var .rest: List[A]
}


for List[A] {
    def ::new(...items: Array[A]) -> List[A] {
        items.rev-fold(Empty) \ item, acc {
            List.Node(item, acc)
        }
    }
}


[[ ## Equality ############################################################## ]]


for List[A] as #eq forall A: #eq {
    def == (other: List[A]) -> Bool {
        match (self, other) {
        case (Empty, Empty) =>
            True
        case (a: Node, b: Node) =>
            a == b
        case (_, _) =>
            False
    }
}


[[ If binary operators have double-dispatch: ]]


for Empty as #eq {
    def == (other: Empty) -> Bool {
        True
    }
}


for Node[A] as #eq forall A: #eq {
    def == (other: Node[A]) -> Bool {
        self.item == other.item
            and self.rest == other.rest
    }
}


[[ ## Pushing and Poping #################################################### ]]


for List[A] {
    def .push(item: A) -> ref Node[A] {
        Node(item, self)
    }

    derive .head -> Option[A]

    derive .tail -> List[A]
}


for Empty[A] {
    def .head -> None {
        None
    }

    def .tail -> Empty {
        Empty
    }
}


for Node[A] {
    def .head -> Some[A] {
        Some(self.item)
    }

    def .tail -> List[A] {
        self.rest
    }
}


[[ ## Functor Implementation ################################################ ]]


for List[A] derive #functor forall A {
    derive .map(transform: func(A) -> B) -> List[B] forall B
}


for Empty as #functor forall A {
    def .map(transform: func(A) -> B) -> Empty forall B {
        Empty
    }
}


for Node[A] as #functor forall A {
    def .map(f: func(A) -> B) -> Node[B] forall B {
        Node(f(self.item), self.rest.map(f))
    }
}


[[ ## Iterator Implementation ############################################### ]]


for List[A] as #iterable {
    def ::Iterator = List-Iterator[A]

    def .iterator -> List-Iterator[A] {
        List-Iterator(self)
    }
}


def List-Iterator[A] {
    let .current: List[A]
}


for List-Iterator[A] as #iterator {
    def ::Item = A

    def .next -> (List-Iterator[A], Option[A]) {
        match self.current {
        case Empty =>
            (self, None)
        case Node(item, rest) =>
            let new-self = self.with(current = rest)
            (new-self, Some(item))
        }
    }
}
    

--------------------------------------------------------------------------------


[[ # Example of Utilisation for Linked List ]]
module std::list::test


use std::list { List, Node, Empty }


let double(list: List[Int]) -> List[Int] {
    list.map(___ * 2)
}


let main() -> Io[] =
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

        Io.print(type-of(a))
        --> Node[Int]

        Io.print(type-of(b))
        --> List[Int]

        Io.print(type-of(a.map))
        --> fun(Node[Int], fun(Int) -> A) -> Node[A]
    }
}
