module /std/lists --- Linked Lists --------------------------------------------


import /std (#iterator, #iterable)


public


type List[A] = Empty[A] | *Link[A]
struct Empty[A]
struct Link[A] {
	head: data A
	tail: data List[A]
}


fun List[A].new(...items: Array[A]) -> List[A] =
    items.rev-fold(
		Empty,
        (item, list) =>
            Link { head = item, tail = list }
	)


public --- Equality -----------------------------------------------------------


trait #eq for List[#eq]
trait #eq for Empty
trait #eq for Link[#eq]


forall A #eq
fun (List[A]) == (other: List[A]) -> Bool =
	case (self, other)
	of (Empty, Empty) then True
	of (a: Link, b: Link) then (a.head == b.item) and (a.tail == b.tail)
	of (_, _) then False
	end


public --- Pushing and Poping -------------------------------------------------


fun (List[A]).push(item: A) -> *Link[A] =
    Link { head = item, tail = self }


auto (List[A]).head -> A?
fun (Empty[A]).head -> None = None


auto (List[A]).tail -> List[A]
fun (Empty[A]).tail -> Empty[A] = Empty


public --- Functor Implementation ---------------------------------------------


tag List[A] as #functor
tag Empty[A] as #functor
tag Link[A] as #functor


auto (List[A]).map(transform: A -> B) -> List[B]


fun (Empty[A]).map(transform: A -> B) -> Empty[B] =
    Empty


fun (*Link[A]).map(transform: A -> B) -> *Link[B] =
    Link {
        head = transform(self.head),
        tail = self.tail.map(transform),
	}


public --- Iterator Implementation --------------------------------------------


trait #iterable for List[A]


struct List[A].Iterator {
	current: List[A]
}


fun (List[A]).iterator -> List[A].Iterator =
    List.Iterator { current = self }


trait #iterator for List[A].Iterator


type List[A].Iterator.Item = A


fun (List[A].Iterator).item -> A? =
    self.current.head


fun (List[A].Iterator).next -> List[A].Iterator =
    case self.current
	of Empty then self
	of Link { tail, ... } then
		self.with { current = tail }
    end


fun (List[A].Iterator).item-next -> (List[A].Iterator, A?) =
    case self.current
	of Empty then (self, None)
	of Link { head, tail } then
		new-self = self.with { current = tail }
		(new-self, Ok(head))
    end


module main --- Usage ---------------------------------------------------------


use /std/io (&io)
use /std/list (List, Link, Empty)


private


fun double(list: List[Int]) -> List[Int] =
    list.map(___ * 2)


fun main() -> Nil &io =
	a = Link(1, Link(2, Link(3, Empty)))
	b = List.new(1, 2, 3)

	do io.print(a.type)
	--> Link[Int]

	do io.print(b.type)
	--> List[Int]

	do io.print(a.map.type))
	--> (Link[Int], Int -> A) -> Link[A]

	Nil
