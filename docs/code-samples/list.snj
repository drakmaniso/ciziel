------
module std'list

use std::iter (#iterator, #iterable)


public List[T] =
    enum(Empty | *Node[T])
    has #eq forall T #eq
    has #functor
    has #iterable


public Node[T] =
    struct(item: T, tail: List[T])
    has #eq forall T #eq
    has #functor
    has #iterable


public Empty =
    struct()
    has #eq
    has #iterable


public List[T].new(...items: Array[T]) -> List[T] =
    items.fold-rev(
        List.Empty,
        fun(item, acc) -> List.Node(item, acc)
    )


-- Equality


public (Empty) == (other: Empty) -> Bool =
    True


public (Node[T]) == (other: Node[T]) -> Bool
    forall T #eq
    =
    self.item == other.item and self.tail == other.tail


public (List[T]) == (other: List[T]) -> Bool
    forall T #eq
    =
    match (self, other)
    case (Empty, Empty) then True
    case (a: Node, b: Node) then a == b
    else False


-- Pushing and poping

    
public (Node[T]).push(item: T) -> Node[T] =
    Node(item, self)


public (Empty).push(item: T) -> Node[T] =
    Node(item, Empty)


public (Node[T]).pop() -> (Some[T], List[T]) =
    (Some(self.item), self.tail)


public (Empty).pop() -> (None, Empty) =
    (None, Empty)


-- Functor implementation


public (Empty).map(f: fun(T) -> U) -> Empty
    forall T, U
    =
    Empty


public (Node[T]).map(f: fun(T) -> U) -> Node[U]
    forall T, U
    =
    Node(f(self.item), self.tail.map(f))


-- Iterator stuff


public List[T].Iterator = alias Iterator[T]


public (List[T]).iterator -> Iterator[T] =
    Iterator(self)


public Iterator[T] =
    opaque struct(current: List[T])
    has #iterator


public Iterator[T].Item = alias T


public (Iterator[T]).next -> (Iterator[T], Option[T]) =
    match self.current
    case Empty then
        (self, None)
    case Node(item, tail) then
        (self.with { current = tail }, Some(item))
    

------
module std::list::test


use std::list (List, Node, Empty)


local double(list: List[Int]) -> List[Int] =
    list.map(___ * 2)


public main() -> Io[] =
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

    Io.do {
        Io.print(a.type)
        --> Node[Int]

        Io.print(b.type)
        --> List[Int]

        Io.print(a.map.type)
        --> fun(Node[Int], fun(Int) -> A) -> Node[A]
    }
