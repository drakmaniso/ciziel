---
# Linked List
---


module std::list


use std::iter (#iterator, #iterable)


def List[A] = union {
    case Empty
    case *Node {
        data head: A
        data tail: List[A]
    }
}


def List[A].new(...items: Array[A]) -> List[A] {
    items.rev-fold(Empty) {
        item, list =>
            Node(head = item, tail = list)
    }
}


---
## Equality ###################################################################
---


def #eq for List[#eq], Empty, Node[#eq]


def (List[A]) == (other: List[A]) -> Bool
    forall A #eq
{
    match self, other {
        case Empty, Empty =>
            True
        case a: Node, b: Node =>
            (a.head == b.item)
                (and a.tail == b.tail)
        case any, any =>
            False
    }
}


---
## Pushing and Poping #########################################################
---


def (List[A]).push(item: A) -> *Node[A] {
    Node(head = item, tail = self)
}


def (List[A]).head -> Option[A]


def (Empty).head -> None {
    None
}


def (List[A]).tail -> List[A]


def (Empty).tail -> Empty {
    Empty
}


---
## Functor Implementation #####################################################
---


def #functor for List[A], Empty, Node[A] forall A


def (List[A]).map(transform: A -> B) -> List[B]
    forall A, B


def (Empty).map(transform: A -> B) -> Empty
    forall A, B
{
    Empty
}


def (*Node[A]).map(transform: A -> B) -> *Node[B]
    forall A, B
{
    Node(
        head = transform(self.head),
        tail = self.tail.map(transform),
    )
}


---
## Iterator Implementation ####################################################
---


def #iterable for List[A]


def List[A].Iterator = struct {
    let current: List[A]
}


def (List[A]).iterator -> List[A].Iterator {
    List.Iterator(current = self)
}


def #iterator for List[A].Iterator


def List[A].Iterator.Item = alias A


def (List[A].Iterator).next -> (List[A].Iterator, Option[A]) {
    match self.current {
        case Empty =>
            (self, None)

        case Node(head, tail) =>
            let new-self = self.with(current = tail)
            (new-self, Some(head))
    }
}


/*
## Usage ######################################################################
*/


module main


use std::list (List, Node, Empty)


let double(list: List[Int]) -> List[Int] {
    list.map { ___ * 2 }
}


let main() -> Io[] {
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

    Io.print(a.Type.name)
    // Node[Int]

    Io.print(b.Type.name)
    // List[Int]

    Io.print(a.map.Type.name))
    // (Node[Int], Int -> A) -> Node[A]
}
