module /std/lists --- Linked Lists --------------------------------------------
use /std (#iterator, #iterable)


public


List[A] = Empty[A] | *Link[A]
Empty[A] = struct
Link[A] =
	struct {
		head: data A
		tail: data List[A]
	}


List[A].new(...items: Array[A]) -> List[A] =
    items.rev-fold(
		Empty,
        (item, list) =>
            Link { head = item, tail = list }
	)


public --- Equality -----------------------------------------------------------


List[#eq]: #eq
Empty: #eq
Link[#eq]: #eq


(List[A]) == (other: List[A]) -> Bool
	forall A: #eq
	=
	case (self, other)
	of (Empty, Empty) then True
	of (a: Link, b: Link) then (a.head == b.item) and (a.tail == b.tail)
	of (_, _) then False
	end


public --- Pushing and Poping -------------------------------------------------


(List[A]).push(item: A) -> *Link[A] =
    Link { head = item, tail = self }


(List[A]).head -> A? = auto
(Empty[A]).head -> None = None


(List[A]).tail -> List[A] = auto
(Empty[A]).tail -> Empty[A] = Empty


public --- Functor Implementation ---------------------------------------------


List[A]: #functor
Empty[A]: #functor
Link[A]: #functor


(List[A]).map(transform: A -> B) -> List[B] =
	auto


(Empty[A]).map(transform: A -> B) -> Empty[B] =
    Empty


(*Link[A]).map(transform: A -> B) -> *Link[B] =
    Link {
        head = transform(self.head),
        tail = self.tail.map(transform),
	}


public --- Iterator Implementation --------------------------------------------


List[A]: #iterable


List[A].Iterator =
	struct {
		current: List[A]
	}


(List[A]).iterator -> List[A].Iterator =
    List.Iterator { current = self }


List[A].Iterator: #iterator


List[A].Iterator.Item = A


(List[A].Iterator).item -> A? =
    self.current.head


(List[A].Iterator).next -> List[A].Iterator =
    case self.current
	of Empty then self
	of Link { tail, ... } then
		self.with { current = tail }
    end


(List[A].Iterator).item-next -> (List[A].Iterator, A?) =
    case self.current
	of Empty then (self, None)
	of Link { head, tail } then
		new-self = self.with { current = tail }
		(new-self, Ok(head))
    end


module main --- Usage ---------------------------------------------------------


use /std/io (&io)
use /std/list (List, Link, Empty)


private


double(list: List[Int]) -> List[Int] =
    list.map(=> ___ * 2)


main() -> Nil &io =
	do
		a = Link(1, Link(2, Link(3, Empty)))
		b = List.new(1, 2, 3)

		io.print(a.type)
		--> Link[Int]

		io.print(b.type)
		--> List[Int]

		io.print(a.map.type))
		--> (Link[Int], Int -> A) -> Link[A]
	end
