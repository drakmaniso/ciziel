-- Linked List


module std/list


use #iterator, #iterable from std/iter


def List[A] = Empty[A] | *Node[A]


def Empty[A] = struct {}


def Node[A] = struct {
    data head: A
    data tail: List[A]
}


def List[A].new(...items: Array[A]) -> List[A] {
    items.rev-fold(Empty) {
        item, list =>
            Node(head = item, tail = list)
    }
}


-- Equality -------------------------------------------------------------------


def #eq for List[#eq], Empty, Node[#eq]


forall A #eq
def (List[A]) == (other: List[A]) -> Bool {
    match self, other {
        | Empty, Empty =>
            True

        | a: Node, b: Node =>
            (a.head == b.item) and (a.tail == b.tail)

        | any, any =>
            False
    }
}


-- Pushing and Poping ---------------------------------------------------------


def (List[A]).push(item: A) -> *List[A].Node {
    Node(head = item, tail = self)
}


def (List[A]).head -> Option[A]


def (Empty[A]).head -> None[A] {
    None
}


def (List[A]).tail -> List[A]


def (Empty[A]).tail -> Empty[A] {
    Empty
}


-- Functor Implementation -----------------------------------------------------


def #functor for List[A], List[A].Empty, List[A].Node forall A


forall A, B
def (List[A]).map(transform: A -> B) -> List[B]


forall A, B
def (Empty[A]).map(transform: A -> B) -> Empty[B] {
    Empty
}


forall A, B
def (*Node[A]).map(transform: A -> B) -> *Node[B] {
    Node(
        head = transform(self.head),
        tail = self.tail.map(transform),
    )
}


-- Iterator Implementation ----------------------------------------------------


def #iterable for List[A]


def List[A].Iterator = struct {
    let current: List[A]
}


def (List[A]).iterator -> List[A].Iterator {
    Iterator(current = self)
}


def #iterator for List[A].Iterator


def List[A].Iterator.Item = alias A


def (List[A].Iterator).next -> (List[A].Iterator, Option[A]) {
    match self.current {
        | Empty =>
            (self, None)

        | Node(head, tail) =>
            let new-self = self.with(current = tail)
            (new-self, Some(head))
    }
}


-- Usage ----------------------------------------------------------------------


module main


use std::list (List, Node, Empty)


let double(list: List[Int]) -> List[Int] {
    list.map { ___ * 2 }
}


let main() -> Io[] {
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

    Io.print(a.Type.name)
    -- Node[Int]

    Io.print(b.Type.name)
    -- List[Int]

    Io.print(a.map.Type.name))
    -- (Node[Int], Int -> A) -> Node[A]
}
