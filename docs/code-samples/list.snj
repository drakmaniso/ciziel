/*
# Linked List
*/


module std::list


use std::iter (#iterator, #iterable)


def List[A] = Empty | *Node[A]
def Empty
def Node[A] {
    var item: A
    var tail: List[A]
}


extend List[A] {
    def new(...items: Array[A]) -> List[A] {
        items.rev-fold(Empty) fun(item, acc) {
            Node(item, acc)
        }
    }
}


/*
## Equality #############################################################
*/


forall A: #eq
extend List[A] as #eq {
    dispatch ==(left: List[A], right: List[A]) -> Bool
}


extend Empty as #eq {
    def == (left: Empty, right: Empty) -> True {
        True
    }


forall A: #eq
extend Node[A] as #eq {
    def == (left: Node[A], right: Node[A]) -> Bool {
        left.item == right.item
            and left.rest == right.rest
    }
}


forall A: #eq
extend Node[A] {
    def == (left: Node[A], right: Empty) -> False {
        False
    }

    def == (left: Empty, right: Node[A]) -> False {
        False
    }
}


/*
## Pushing and Poping ###################################################
*/


extend List[A] {
    def push(self, item: A) -> *Node[A] {
        Node(item, self)
    }

    dispatch head(self) -> Option[A]
    dispatch tail(self) -> List[A]
}


extend Empty {
    def head(self) -> None {
        None
    }

    def tail(self) -> Empty {
        Empty
    }
}


extend Node[A] {
    def head(self) -> Some[A] {
        self.item
    }

    def tail(self) -> List[A] {
        self.rest
    }
}


/*
## Functor Implementation ###############################################
*/


forall A
extend List[A] as #functor {
    forall B
    dispatch map(self, transform: fun(A) -> B) -> List[B]
}


forall A
extend Empty as #functor {
    forall B
    def map(self, transform: fun(A) -> B) -> Empty {
        Empty
    }
}


forall A
extend *Node[A] as #functor {
    forall B
    def map(self, transform: fun(A) -> B) -> *Node[B] {
        Node(transform(self.item), self.rest.map(transform))
    }
}


/*
## Iterator Implementation ##############################################
*/


extend List[A] as #iterable {
    def Iterator = List-Iterator[A]

    def iterator(self) -> List-Iterator[A] {
        List-Iterator(current: self)
    }
}


def List-Iterator[A] {
    let current: List[A]
}


extend List-Iterator[A] as #iterator {
    def Item = A

    def next(self) -> (List-Iterator[A], Option[A]) {
        match self.current {
        case Empty:
            (self, None)

        case Node(item, rest):
            let new-self = self.with(current: rest)
            (new-self, Some(item))
        }
    }
}


/*
## Usage ################################################################
*/


module main


use std::list { List, Node, Empty }


let double(list: List[Int]) -> List[Int] {
    list.map(___ * 2)
}


let main() -> Io[] {
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List.new(1, 2, 3)

    Io.print(a.Type)
    // Node[Int]

    Io.print(b.Type)
    // List[Int]

    Io.print(a.map.Type))
    // fun(Node[Int], fun(Int) -> A) -> Node[A]
}
