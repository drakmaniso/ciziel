[[ # Linked List ]]


module std::list


use std::iter { #iterator, #iterable }


def List[A] = Empty | *Node[A]
def Empty
def Node[A](
    var item: A,
    var tail: List[A],
)


extend List[A] {
    def ::new(...items: Array[A]) -> List[A] {
        items.rev-fold(Empty) \(item, acc) {
            Node(item, acc)
        }
    }
}


[[ ## Equality ############################################################# ]]


forall A: #eq
derive List[A] as #eq


forall A: #eq
extend Empty as #eq {
    def == (right: Empty) -> True {
        True
    }

    def == (right: Node[A]) -> False {
        False
    }
}


forall A: #eq
extend Node[A] as #eq {
    def == (right: Empty) -> False {
        False
    }
    
    def == (right: Node[A]) -> Bool {
        self.item == other.item
            and self.rest == other.rest
    }
}


[[ ## Pushing and Poping ################################################### ]]


extend List[A] {
    def .push(item: A) -> *Node[A] {
        Node(item, self)
    }
}


derive List[A] {
    def .head() -> Option[A]
    def .tail() -> List[A]
}


extend Empty {
    def .head() -> None {
        None
    }

    def .tail() -> Empty {
        Empty
    }
}


extend Node[A] {
    def .head() -> Some[A] {
        self.item
    }

    def .tail() -> List[A] {
        self.rest
    }
}


[[ ## Functor Implementation ############################################### ]]


forall A
derive List[A] as #functor {
    forall B
    def .map(transform: \(A) -> B) -> List[B]
}


forall A
extend Empty as #functor {
    forall B
    def .map(transform: \(A) -> B) -> Empty {
        Empty
    }
}


forall A
extend *Node[A] as #functor {
    forall B
    def .map(transform \(A) -> B) -> *Node[B] {
        Node(transform(self.item), self.rest.map(transform))
    }
}


[[ ## Iterator Implementation ############################################## ]]


extend List[A] as #iterable {
    def ::Iterator = List-Iterator[A]

    def .iterator() -> List-Iterator[A] {
        List-Iterator(self)
    }
}


def List-Iterator[A] {
    let .current: List[A]
}


extend List-Iterator[A] as #iterator {
    def ::Item = A

    def .next() -> (List-Iterator[A], Option[A]) {
        match self.current {
        case Empty:
            (self, None)

        case Node(item, rest):
            let new-self = self.with(current = rest)
            (new-self, Some(item))
        }
    }
}


[[ ## Usage ################################################################ ]]


module main


use std::list { List, Node, Empty }


let double(list: List[Int]) -> List[Int] {
    list.map(___ * 2)
}


let main() -> Io[] {
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List::new(1, 2, 3)

    Io::print(a.Type)
    --> Node[Int]

    Io::print(b.Type)
    --> List[Int]

    Io::print(a.map.Type))
    --> fun(Node[Int], fun(Int) -> A) -> Node[A]
}
