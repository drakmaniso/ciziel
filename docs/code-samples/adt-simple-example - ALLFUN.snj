module geom
use std::vec { Point }


[[ ## Types and Traits ###################################################### ]]


def Shape = Circle | BBox


def Circle(
    var center: Point,
    var radius: Float64,
)


def BBox(
    def min: Point,
    def max: Point,
)


def #shape {
    has perimeter(shape: Self) -> Float64
    has area(shape: Self) -> Float64
}


def #movable {
    has move(shape: Self, destination: Point) -> Self
}


def #scalable {
    has scale(shape: Self, factor: Float64) -> Self
}


ensure {
    Circle is #shape #movable #scalable
    BBox is #shape #movable #scalable
}


[[ ## Circle Functions ###################################################### ]]


def bounding-circle(points: Array[Point]) -> Circle {
    let welzl(points, boundary) {
        match points {
        case _ and boundary.length == 3 =>
            trivial(boundary)

        case Array() =>
            trivial(boundary)

        case Array(p, rest) =>
            let d = welzl(points.remove(p), boundary)
            if d.encloses(p) {
                d
            } else {
                welzl(points.remove(p), boundary.push(p))
            }
        }
    }

    welzl(points, [])
}


def diameter(c: Circle) -> Float64 {
    c.radius * 2
}


def perimeter(c: Circle) -> Float64 {
    math::pi * c.diameter
}


def area(c: Circle) -> Float64 {
    math::pi * (c.radius ** 2)
}


def move(c: Circle, destination: Point) -> Circle {
    c.with(center = destination
}


def scale(c: Circle, factor: Float64) -> Circle {
    c.with(radius = c.radius * factor)
}


[[ ## BBox Functions ######################################################## ]]


def bbox(a: Point, b: Point) -> BBox {
    let (min-x, max-x) = (a.x, b.x).sorted()
    let (min-y, max-y) = (a.y, b.y).sorted()
    
    BBox(
        min = Point(min-x, min-y),
        max = Point(max-x, max-y),
    )
}


def width(b: BBox) -> Float64 {
    b.max-x - b.min-x
}


def height(b: BBox) -> Float64 {
    b.max-y - b.min-y
}


def perimeter(b: BBox) -> Float64 {
    (2 * b.width) + (2 * b.height)
}


def area(b: BBox) -> Float64 {
    b.width * b.height
}


def move(b: BBox, destination: Point) -> BBox {
    let size = b.max - b.min
    b.with(
        min = destination
        max = destination + size
    )
}


def scale(b: BBox, factor: Float64) -> BBox {
    let w = factor * b.width
    let h = factor * b.height
    
    b.with(
        min-x = b.min-x - (w / 2),
        min-y = b.min-y - (h / 2),
        max-x = b.max-x + (w / 2),
        max-y = b.max-y + (h / 2),
    )
}
