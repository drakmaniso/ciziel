module main

use std'console (Console)


func main (io: Console own) -> Console own =>
	let
		get-number = \ io =>
			let io, answer :=
				>> print "Please enter a number: \!"
				>> input
			in
			match answer >> to-int
			case Some n then (io, n)
			else get-number io
	
		io, number := get-number io
		naive = naive-factorial answer
		tail = tail-factorial answer
		folded = folded-factorial answer
	in
	io >> print "naive factorial: {naive}"
		>> print "tail recursice factorial: {tail}"
		>> print "fold-based factorial: {folded}"


func naive-factorial n =
	if n <= 1 then 1
	else n * (naive-factorial (n - 1))


func tail-factorial (n: Int) -> Int =
	let
		step = \ n accum =>
			if n <= 1 then accum
			else step (n - 1) (n * accum)
	in
	step n 1


func fold-factorial (n: Int) -> Int =
	2 >> upto n
		>> fold 1 (\ i accum => i * accum)


func fold-factorial(n: Int) -> Int =
	2 >> upto n
		>> fold 1
			(\ i accum =>
				i * accum
			)


forall (Num N) (Copy N)
func generic-tail-factorial (n: N) -> N =
	let
		step = \ n accum =>
			if n <= Num'one then accum
			else step (n - Num'one) (n * accum)
	in
	step n Num'one


forall (Num N) (Range N) (Copy N)
func generic-fold-factorial (n: N) -> N =
	(Num'one `upto` n)
		>> fold Num'one
			(\ accum x => accum * x)


func gcd (n: Int) (m: Int) -> Int =
	require n > 0
	require m > 0
	ensure result > 0

	(a, b) = (max n m, min n m)
	if b == 0 then a
	else gcd b (a % b)

	
func fibonacci (n: Int) -> Int =
	require n > 0
	ensure result > 0
	let
		step = \ n previous current =>
			if n = 0 then current
			else step (n - 1) current (previous + current)
	in
	step n 1 1


func pipeline-example () -> () =
	my-array = [1, 2, 3, 4, 5, 6, 7]
	my-array
		>> filter (\ n => n `mod` 2 == 0)
		>> map (\ n => n * 2)
		>> fold ""
			(\ string number =>
				string ++ (number >> to-string))
		>> map
			(\ rune =>
				if rune >> is-letter then
					rune >> to-upper
				else
					"?" >> to-rune)
	()