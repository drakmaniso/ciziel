def #setoid {
	has (Self).equals(other: Self) -> Bool
}


def #ord {
	has #setoid
	has (Self).lte(other: Self) -> Bool
}


/*****/

def #semigroupoid {
	has (Self[I, J]).compose(other: Self[J, K]) -> Self[I, K]
}


def #category {
	has #semigroupoid
	has Self[A, A].id() -> Self[A, A]
}


/*****/


def #semigroup {
	has (Self).concat(other: Self) -> Self
}


def #monoid {
	has #semigroup
	has Self.empty -> Self
}


def #group {
	has #monoid
	has (Self).invert -> Self
}


/*****/


def #filterable {
	has (Self[A]).filter(test: A -> Bool) -> Self[A]
}


/*****/


def #contravariant {
	has (Self[A]).contramap(operation: B -> A) -> Self[B]
}


/*****/


def #functor {
	has (Self[A]).map(operation: A -> B) -> Self[B]
}


def #apply {
	has #functor
	has (Self[A]).ap(Self[A -> B]) -> Self[B]
}


def #applicative {
	has #apply
	has Self[A].of(value: A) -> Self[A]
}


def #alt {
	has #functor
	has (Self[A]).alt(other: Self[A]) -> Self[A]
}


def #plus {
	has #alt
	has Self[A].zero -> Self[A]
}


def #alternative {
	has #applicative
	has #plus
}


def #foldable {
	has (Self[A]).reduce(operation: (B, A) -> B, init: B) -> B
}


def #traversable {
	has #functor
	has #foldable
	has (Self[A]).traverse(operation: A -> F[B]) -> F[Self[B]]
		forall F #applicative
}


def #chain {
	has #apply
	has (Self[A]).chain(operation: A -> Self[B]) -> Self[B]
}


def #chain-rec {
	has #chain
	has Self[Any].chain-rec(operation: (A -> C, B -> C, A) -> Self[C], init: A) -> Self[B]
	 	// what???
}


def #monad {
	has #applicative
	has #chain
}


def #extend {
	has #functor
	has (Self[A]).extend(operation: Self[A] -> B) -> Self[B]
}


def #comonad {
	has #extend
	has (Self[A]).extract -> A
}


def #bifunctor {
	has #functor
	has (Self[A, C]).bimap(operation-1: A -> B, operation-2: C -> D) -> Self[B, D]
}


def #profunctor {
	has #functor
	has (Self[B, C]).promap(operation-1: A -> B, operation-2: C -> D) -> Self[A, D]
}
