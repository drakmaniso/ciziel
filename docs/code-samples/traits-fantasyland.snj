def #setoid = trait {
	has (Self).equals(other: Self) -> Bool
}


def #ord = trait {
	has #setoid
	has (Self).lte(other: Self) -> Bool
}


-------------------------------------------------------------------------------


def #semigroupoid = trait {
	has (Self[I, J]).compose(other: Self[J, K]) -> Self[I, K]
}


def #category = trait {
	has #semigroupoid
	has Self[A, A].id() -> Self[A, A]
}


-------------------------------------------------------------------------------


def #semigroup = trait {
	has (Self).concat(other: Self) -> Self
}


def #monoid = trait {
	has #semigroup
	has Self.empty -> Self
}


def #group = trait {
	has #monoid
	has (Self).invert -> Self
}


-------------------------------------------------------------------------------


def #filterable = trait {
	has (Self[A]).filter(test: A -> Bool) -> Self[A]
}


-------------------------------------------------------------------------------


def #contravariant = trait {
	has (Self[A]).contramap(operation: B -> A) -> Self[B]
}


-------------------------------------------------------------------------------


def #functor = trait {
	has (Self[A]).map(operation: A -> B) -> Self[B]
}


def #apply = trait {
	has #functor
	has (Self[A]).ap(Self[A -> B]) -> Self[B]
}


def #applicative = trait {
	has #apply
	has Self[A].of(value: A) -> Self[A]
}


def #alt = trait {
	has #functor
	has (Self[A]).alt(other: Self[A]) -> Self[A]
}


def #plus = trait {
	has #alt
	has Self[A].zero -> Self[A]
}


def #alternative = trait {
	has #applicative
	has #plus
}


def #foldable = trait {
	has (Self[A]).reduce(operation: (B, A) -> B, init: B) -> B
}


def #traversable = trait {
	has #functor
	has #foldable
	has (Self[A]).traverse(operation: A -> F[B]) -> F[Self[B]]
		forall F: #applicative
}


def #chain = trait {
	has #apply
	has (Self[A]).chain(operation: A -> Self[B]) -> Self[B]
}


def #chain-rec = trait {
	has #chain
	has Self[Any].chain-rec(operation: (A -> C, B -> C, A) -> Self[C], init: A) -> Self[B]
	 	-- what???
}


def #monad = trait {
	has #applicative
	has #chain
}


def #extend = trait {
	has #functor
	has (Self[A]).extend(operation: Self[A] -> B) -> Self[B]
}


def #comonad = trait {
	has #extend
	has (Self[A]).extract -> A
}


def #bifunctor = trait {
	has #functor
	has (Self[A, C]).bimap(operation-1: A -> B, operation-2: C -> D) -> Self[B, D]
}


def #profunctor = trait {
	has #functor
	has (Self[B, C]).promap(operation-1: A -> B, operation-2: C -> D) -> Self[A, D]
}
