module foo


trait Eval T =
	eval (expr: T) -> Int


struct Literal =
	value: Int


struct Addition T =
	left: T
	right: T


ensure Eval Literal
forall Eval T ensure Eval (Addition T)


func eval (expr: Literal) -> Int =
	expr.value


forall Eval T
func eval (expr: Addition T) -> Int =
	(eval expr.left) + (eval expr.right)


------
module bar

use foo (#eval, Literal, Addition)


trait Pretty T =
	pretty (expr: T) -> String


struct Negation T =
	subexpr: T


forall Eval T ensure Eval (Negation T)
ensure Pretty Literal
forall Pretty T ensure Pretty (Addition T)
forall Pretty T ensure Pretty (Negation T)


forall Eval T
func eval (expr: Negation[T]) -> Int =
	- (eval expr.subexpr)


func pretty (expr: Literal) -> String =
	to-string (eval expr)


forall Pretty T
func pretty (expr: Addition T) -> String =
	"{pretty expr.left} + {pretty expr.right}"


forall Pretty T
func pretty (expr: Negation T) -> String =
	match expr.subexpr
	case e = Literal(...) then
		"-{pretty e}"
	else
		"- ({pretty expr.subexpr})"


------
module main

use foo (Eval, Literal, Addition)
use bar (Pretty, Negation)

union Expr = Literal | Addition[Expr] | Negation[Expr]

func main(io: Console) -> Console =
	e1 = Addition(Literal(77), Negation(Literal(12))
	io.print("{e1.pretty} = {e1.eval}")
