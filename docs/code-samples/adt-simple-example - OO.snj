module geom
use std::vec { Point }


def Shape =
    | Circle
    | BBox
    | Square
    | Rectangle
    | Polygon


def #shape {
    has perimeter() -> Float64
    has area() -> Float64
}


def #movable {
    has move-to(destination: Point) -> Self
}


def #scalable {
    has scale-by(factor: Float64) -> Self
}


// Circle /////////////////////////////////////////////////////////////////////


def Circle {
    var center: Point
    var radius: Float64


    def Circle.around(points: Array[Point]) -> Circle {
        let welzl(points, boundary) {
            match points {
            case _ and boundary.length() == 3:
                trivial(boundary)

            case Array():
                trivial(boundary)

            case Array(p, rest):
                d = welzl(points.remove(p), boundary)
                if d.encloses(p) {
                    d
                } else {
                    welzl(points.remove(p), boundary.push(p))
                }
            }
        }

        welzl(points, [])
    }


    def diameter() -> Float64 {
        self.radius * 2
    }

    
    has #shape


    def perimeter() -> Float64 {
        math::pi * self.diameter()
    }


    def area() -> Float64 {
        math::pi * (self.radius ** 2)
    }


    has #movable


    def move(destination: Point) -> Circle {
        self.with(center: destination)
    }


    has #scalable
    
    
    def scale-by(factor: Float64) -> Circle {
        self.with(radius: self.radius * factor)
    }
}


// BBox ///////////////////////////////////////////////////////////////////////


def BBox {
    def min: Point
    def max: Point


    def BBox(a: Point, b: Point) {
        xs = (a.x, b.x)
        ys = (a.y, b.y)

        BBox(
            min: Point(min(...xs), min(...ys)),
            max: Point(max(...xs), max(...ys)),
        )
    }


    def width() -> Float64 {
        self.max.x - self.min.x
    }
    
    
    def height() -> Float64 {
        self.max.y - self.min.y
    }
    

    def size() -> Vec2 {
        Vec2(self.width(), self.height())
    }


    def perimeter() -> Float64 {
        2 * (self.width() + self.height())
    }


    def area() -> Float64 {
        self.width() * self.height()
    }


    has #movable


    def move-to(destination: Point) -> BBox {
        self.with(
            min: destination,
            max: destination + self.size(),
        )
    }


    has #scalable


    def scale-by(factor: Float64) -> BBox {
        delta = (factor * self.size()) - self.size()
        self.with(
            min: self.min - (delta / 2),
            max: self.max + (delta / 2),
        )
    }
}


// Triangle ///////////////////////////////////////////////////////////////////


def Triangle {
    var a: Point
    var b: Point
    var c: Point
}


// Rectangle //////////////////////////////////////////////////////////////////


def Rectangle {
    var origin: Point
    def width: Float64
    def height: Float64
    def angle: Float64


    def Rectangle(
        origin: Point,
        width: Float64,
        height: Float64,
        angle: Float64,
    ) {
        width' = min(0, width)
        height' = min(0, height)
        angle' = angle <mod> (2 * math::pi)
        Rectangle(origin, width', height', angle')
    }
    

    def size() -> Vec2 {
        Vec2(self.width, self.height)
    }


    def perimeter() -> Float64 {
        2 * (self.width + self.height)
    }


    def area() -> Float64 {
        self.width * self.height
    }


    has #movable


    def move-to(destination: Point) -> Rectangle {
        self.with(origin: destination)
    }


    has #scalable


    def scale-by(factor: Float64) -> Rectangle {
        self.with(
            width: self.width * factor,
            height: self.height * factor,
        )
    }
}


// Polygon ////////////////////////////////////////////////////////////////////


def Polygon {
    def points: Array[Point]


    def Polygon(...pts: Array[Point]) {
        Polygon(points: pts)
    }


    def [index: Int] -> Point {
        self.points[index]
    }
}