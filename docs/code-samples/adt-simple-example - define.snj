module geom
use std::vec { Point }


define Shape = union(
    | Circle
    | BBox
    | Square
    | Rectangle
    | Polygon
)


define Circle = struct(
    var center: Point,
    var radius: Float64,
)


define Triangle = struct(
    var a: Point,
    var b: Point,
    var c: Point,
)


define Rectangle = struct(
    var origin: Point,
    var width: Float64,
    var height: Float64,
    val angle: Float64,
)


define BBox = struct(
    val min: Point,
    val max: Point,
)


define Polygon = struct(
    val ...points: Array[Point],
)


define #shape {
    has .perimeter -> Float64
    has .area -> Float64
}


define #movable {
    has .move-to(destination: Point) -> Self
}


define #scalable {
    has .scale-by(factor: Float64) -> Self
}


define #origin {
    has Self(origin: Point, ...)
}


forall A: #origin
extend A as #movable {
    define .move-to(destination: Point) -> A {
        self.with(origin = destination)
    }
}


forall S1: #origin, S2: #origin
define switch-places(shape-1: S1, shape-2: S2) -> (S1, S2) {
    let o1 = shape-1.origin
    let o2 = shape-2.origin
    ( shape-1.with(origin = o2), shape-2.with(origin = o1) )
}


[[ ## Circle ################################################################ ]]


extend Circle {
    define ::bounding-of(points: Array[Point]) -> Circle {
        let welzl(points, boundary) {
            match points {
            case _ and boundary.length == 3 =>
                trivial(boundary)

            case Array() =>
                trivial(boundary)

            case Array(p, rest) => 
                let d = welzl(points.remove(p), boundary)
                if d.encloses(p) {
                    d
                } else {
                    welzl(points.remove(p), boundary.push(p))
                }
            }
        }

        welzl(points, [])
    }

    define .diameter -> Float64 {
        self.radius * 2
    }
}


extend Circle as #shape {
    define .perimeter -> Float64 {
        math::pi * self.diameter
    }

    define .area -> Float64 {
        math::pi * (self.radius ** 2)
    }
}


extend Circle as #origin
extend Circle as #movable


extend Circle as #scalable {
    define .scale-by(factor: Float64) -> Circle {
        self.with(radius = self.radius * factor)
    }
}


[[ ## BBox ################################################################## ]]


extend BBox {
    define ::new(a: Point, b: Point) -> BBox {
        let (x-min, x-max) = (a.x, b.x).sorted()
        let (y-min, y-max) = (a.y, b.y).sorted()
        
        BBox(
            min = Point(x-min, y-min),
            max = Point(x-max, y-max),
        )
    }


    define .width -> Float64 { self.max.x - self.min.x }
    define .height -> Float64 { self.max.y - self.min.y }
    define .size -> Vec2 { Vec2(self.width, self.height) }


    define .perimeter -> Float64 {
        (2 * self.width) + (2 * self.height)
    }


    define .area -> Float64 {
        self.width * self.height
    }
}


extend BBox as #movable {    
    define .move-to(destination: Point) -> BBox {
        self.with(
            min = destination
            max = destination + self.size
        )
    }
}


extend BBox as #scalable {    
    define .scale-by(factor: Float64) -> BBox {
        let delta = (factor * self.size) - self.size
        self.with(
            min = self.min - (delta / 2)
            max = self.max + (delta / 2)
        )
    }
}


extend Polygon {
    define [index: Int] -> Point {
        self.points[index]
    }
}
