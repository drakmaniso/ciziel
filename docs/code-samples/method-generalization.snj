
func (Foo).fn1(arg: String) -> Bool = ...
func (Foo).fn2(arg: #stringable) -> #comparable = ...


func (Bar).fn1(arg: String) -> Char = ...
func (Bar).fn2(arg: #stringable) -> #numeric = ...


enum Foo-Bar =
    Foo | Bar
    dispatch fn1, fn2

-- automatically defines:
func (Foo-Bar).fn1(arg: String) -> Bool | Char = ...
func (Foo-Bar).fn2(arg: #stringable) -> #comparable | #numeric = ...


-------------------------------------------------------------------------------


module trivial-generalization

enum Pet = Cat | Dog
    dispatch happy, unhappy

struct Cat = name: String
struct Dog = name: String

func (Cat).happy -> String = "{self.name} purrs!"
func (Cat).unhappy-with(intruder: String) -> String = "{self.name} hisses at {intruder}!"

func (Dog).happy -> String = "{self.name} wags their tail!"
func (Dog).unhappy-with(intruder: String) -> String = "{self.name} barks at {intruder}!"

func example!(io: sole Console) =
    pet: mut Pet

    pet <- Cat("Spot")
    io.print!(pet.happy)
    --> Spot purrs!
    io.print!(pet.unhappy-with("owner"))
    --> Spot hisses at owner!

    pet <- Dog("Ash")
    io.print!(pet.happy)
    --> Ash wags their tail!
    io.print!(pet.unhappy-with("owner"))
    --> Ash hisses at owner!


-- Static methods cannot be automatically dispatched.

const Cat'sounds: String = ["meow", "purr", "yowl", "hiss"]

const Dog'sounds: String = ["bark", "growl", "whimper", "howl"]

-- The following does not compile:
--(
let incorrect_example =
    print!(Pet.sounds)
)--


------
module simple-generalization

enum FooBar = Foo | Bar
    dispatch generalized
struct Foo
struct Bar

-- Methods with the same parameter list are generalized
-- (even if the return type is different)

func (Foo).generalized(x: Int) -> Int =
    2 * x

func (Bar).generalized(x: Int) -> String =
    "4 * {x}"

-- Methods with different parameter list are *not* generalized

func (Foo).not-generalized(x: Int) -> Int =
    3 * x
func (Bar).not-generalized(x: String) -> Int =
    5 * x.toInt


let example! =
    mut a: Foo | Bar

    a <- Foo
    print!(a.generalized(10))
    --> 20
    a <- Bar
    print!(a.generalized(10))
    --> 4 * 10
    print!(a.generalized.type-info)
    --> Func(Bar | Foo, Int) -> Int | String

    -- But the following cannot compile:
    -- print!(a.notGeneralized(10))
    -- print!(a.notGeneralized("ten"))

