--   let rec stack_or_reduce lex stack = match lex , stack with
--      Lint n ,  _      ->  (Texp (ExpInt n))::stack
--    | Lident v ,  _    ->  (Texp (ExpVar v))::stack
--    | Lstring s , _    ->  (Texp (ExpStr s))::stack
--    | Lsymbol "(" , _  ->  Tlp::stack
--    | Lsymbol ")" , (Texp e)::Tlp::st  ->  (Texp e)::st
--    | Lsymbol ")" , _ -> stack_or_reduce lex (reduce 0 stack)
--    | Lsymbol s , _
--         -> let symbol =
--              if s<>"-" then tsymb s
--              (* remove the ambiguity of the ``-'' symbol           *)
--              (* according to the last exp element put on the stack *)
--              else match stack
--                   with (Texp _)::_  ->  Tbin MINUS
--                                 | _ ->  Tunr UMINUS
--            in ( match symbol with
--                   Tunr op  ->  (Tunr op)::stack
--                 | Tbin op  ->
--                     ( try stack_or_reduce lex (reduce (priority_binop op)
--                                                stack )
--                       with ParseError -> (Tbin op)::stack )
--                 | _ -> raise ParseError )
--    | _ , _ -> raise ParseError ;;


fun stack-or-reduce(lex, stack) =
	case (lex, stack)
		of (Lint(n), _) then Ok(stack ++ Texp(ExpInt(n)))
		of (Lident(v), _) then Ok(stack ++ Texp(ExpVar(v)))
		of (Lstring(s), _) then Ok(stack ++ Texp(ExpStr(s)))
		of (Lsymbol("("), _) then Ok(stack ++ Tlp)
		of (Lsymbol(")"), Array(..., Tlp, Texp(e)) then Ok(stack ++ Texp(e)))
		of (Lsymbol(")"), _) then stack-or-reduce(lex, reduce(0, stack))
		of (Lsymbol(s), _) then
			symbol =
				if s != "-" then
					tsymb(s)
					-- remove the ambiguity of the ``-'' symbol
					-- according to the last exp element put on the stack
				else
					case stack
						of Array(..., Texp(_)) then Tbin(minus)
						of _ then Tunr(uminus)
					end
				end
			case symbol
				of Tunr(op) then Ok(stack ++ Tunr(op))
				of Tbin(op) then
					stack-or-reduce(lex, reduce(priority-binop(op), stack))
						.unwrap-or(stack ++ Tbin(op))
				of _ then Err(ParseError)
			end
		of _ then Err(ParseError)
	end



-- More idiomatic:


fun stack-or-reduce(lex, stack) =
	case lex
		of Lex.Int(n) then Ok(stack ++ Term.Exp(Exp.Int(n)))
		of Lex.Ident(v) then Ok(stack ++ Term.Exp(Exp.Var(v)))
		of Lex.String(s) then Ok(stack ++ Term.Exp(Exp.Str(s)))
		of Lex.Symbol("(") then Ok(stack ++ Term.LPar)
		of Lex.Symbol(")") then
			if stack is Array(..., Term.LPar, Term.Exp(e)) then
				Ok(stack ++ Term.Exp(e)))
			else
				stack-or-reduce(lex, reduce(0, stack))
			end

		of Lex.Symbol(s) then
			-- remove the ambiguity of the `-` symbol
			-- according to the last exp element put on the stack
			symbol =
				if s == "-" then
					case stack
						of Array(..., Term.Exp(_)) then Term.Bin(minus)
						of _ then Term.Unr(uminus)
					end
				else
					tsymb(s)
				end

			case symbol
				of Term.Unr(op) then Ok(stack ++ Term.Unr(op))
				of Term.Bin(op) then
					stack-or-reduce(lex, reduce(priority-binop(op), stack))
						.unwrap-or(stack ++ Term.Bin(op))
				of _ then Err(Parse-Error)
			end

		of _ then Err(Parse-Error)
	end


fun stack-or-reduce(lex, stack) {
	case lex {
		| Lex.Int(n) => Ok(stack ++ Term.Exp(Exp.Int(n)))
		| Lex.Ident(v) => Ok(stack ++ Term.Exp(Exp.Var(v)))
		| Lex.String(s) => Ok(stack ++ Term.Exp(Exp.Str(s)))
		| Lex.Symbol("(") => Ok(stack ++ Term.LPar)
		| Lex.Symbol(")") =>
			if stack is Array(..., Term.LPar, Term.Exp(e)) {
				Ok(stack ++ Term.Exp(e)))
			} else {
				stack-or-reduce(lex, reduce(0, stack))
			}
		| Lex.Symbol(s) =>
			-- remove the ambiguity of the `-` symbol
			-- according to the last exp element put on the stack
			symbol =
				if s == "-" {
					case stack {
						| Array(..., Term.Exp(_)) => Term.Bin(minus)
						| _ => Term.Unr(uminus)
					}
				} else {
					tsymb(s)
				}
			case symbol {
				| Term.Unr(op) => Ok(stack ++ Term.Unr(op))
				| Term.Bin(op) =>
					stack-or-reduce(lex, reduce(priority-binop(op), stack))
						.unwrap-or(stack ++ Term.Bin(op))
				| _ => Err(Parse-Error)
			}
		| _ => Err(Parse-Error)
	}
}