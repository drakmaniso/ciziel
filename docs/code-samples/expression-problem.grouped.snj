module foo


trait #eval =
	eval(expr: Self) -> Int


struct Literal =
	value: Int


struct Addition[T] =
	left: Expr[T]
	right: Expr[T]


implement #eval for Literal
    method eval(self) -> Int =
        self.value


implement #eval for Addition[#eval]
    method eval(self) -> Int =
        expr.left.eval + expr.right.eval


------
module bar

use foo (#eval, Literal, Addition)


trait #pretty =
	pretty(expr: Self) -> String


struct Negation[T] =
	subexpr: T


implement #eval for Negation[#eval]
    method eval(self) -> Int =
        - self.subexpr.eval


implement #pretty for Literal
    method pretty(self) -> String =
        self.eval.as-string


implement #pretty for Addition[#pretty]
    method pretty(self) -> String =
        "{self.left.pretty} + {self.right.pretty}"


implement #pretty for Negation[#pretty]
    method pretty(self) -> String =
        match self.subexpr
        case e = Literal(...):
            "-{e.pretty}"
        else
            "- ({self.subexpr.pretty})"


------
module main

use 'std'io

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)

union Expr = Literal | Addition[Expr] | Negation[Expr]

func main() -> Io[()] =
	do {
		e1 = Addition(Literal(77), Negation(Literal(12)))
		io'print("{e1.pretty} = {e1.eval}")
	}
