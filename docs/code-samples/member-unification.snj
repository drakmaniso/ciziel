let Pet = union(Cat | Dog)


let Cat = struct(
    let name: String,
    let favorite-toy: Cat-Toy,
)


let Dog = struct(
    let name: String,
    let favorite-toy: Dog-Toy,
)


let Pet-Toy = union(Cat-Toy | Dog-Toy)


let Cat-Toy = union(Wool-Ball | Laser | Wand)
let Wool-Ball = struct()
let Laser = struct()
let Wand = struct()

let Dog-Toy = union(Chew-Bone | Stick | Squeaky-Ball)
let Chew-Bone = struct()
let Stick = struct()
let Squeaky-Ball = struct()

for Pet {
    derive .name -> String
            
    [[ The field `favorite-toy` is not unified because its type is different for
    `Cat` and `Dog`. The corresponding functionality must be implemented under a
    new name: ]]

    def pet-favorite-toy -> Pet-Toy {
        match self {
        case cat: Cat => cat.favorite-toy
        case dog: Dog => dog.favorite-toy
        }
    }
}


for Cat {
    let .play(toy: Cat-Toy) -> String { "{self.name} plays with {toy}" }

    let .greets(human: String) -> String { "{self.name} ignores {human}" }
}


for Dog {
    let .play(toy: Dog-Toy) -> String { "{self.name} plays with {toy}" }

    let .greets(human: String) -> String { "{self.name} plays with {human}" }
}


for Pet {
    derive .greets(human: String) -> String
}