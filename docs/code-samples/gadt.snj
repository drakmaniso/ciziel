<< # GADT >>


-- First GADT Example ---------------------------------------------------------


<<
[from wikipedia]: https:--en.wikipedia.org/wiki/Generalized_algebraic_data_type
>>


module gadt1


let Expr = EBool | EInt | EEqual
let EBool = struct { data value: Bool }
let EInt = struct { data value: Int }
let EEqual = struct { data left: *EInt; data right: *EInt }


let #expr = trait {
    has Self.Output
    has (Self).eval -> Self.Output
}


let #expr for Expr, EBool, EInt, EEqual


let (Expr).eval -> Int | Bool


let EBool.Output = Bool
let (EBool).eval -> Bool {
    self.value
}


let EInt.Output = Int
let (EInt).eval -> Int {
    self.value
}


let EEqual.Output = Bool
let (EEqual).eval -> Bool {
    self.left.eval == self.right.eval
}


let main() -> Io[] {
    let expr1 = EEqual(EInt 2, EInt 3)
    Io.print("{expr1.Type.name}")
    --> EEqual

    eval1 = expr1.eval
    Io.print("{eval1.Type.name}")
    --> Bool

    exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
    Io.print("{expr2.Type.name}")
    --> Array[Expr]

    evals = exprs.map(___.eval)
    Io.print("{evals.Type.name}")
    --> Array[Bool | Int]
}


-- Second GADT Example: Phantom Types -----------------------------------------


<<
From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https:--www.researchgate.net/publication/228707929_Fun_with_phantom_types
>>


module gadt2


let Term[T] = Zero[T] | Succ[T] | Pred[T] | Is-Zero[T] | If[T]


let Zero[T] = struct {}
let Succ[T] = struct { data arg: Term[T] }
let Pred[T] = struct { data arg: Term[T] }
let Is-Zero[T] = struct { data arg: Term[T] }
let If[T] = struct {
    data condition: Term[Bool],
    data then-branch: T,
    data else-branch: T,
}


let (Term[T]).eval -> T


forall T == Int
let (Zero[T]).eval -> T { 0 }


forall T == Int
let (Succ[T]).eval -> T { self.arg.eval + 1 }


forall T == Int
let (Pred[T]).eval -> T { self.arg.eval - 1 }


forall T == Bool
let (Is-Zero[T]).eval -> T { self.arg.eval == 0 }


let (If[T]).eval -> T {
    if self.condition.eval {
        self.then-branch.eval
    } else {
        self.else-branch.eval
    }
}


<< alternative implementation: >>


module gadt2


let Term = ITerm | BTerm
let ITerm = Zero | Succ | Pred | If[Term]
let BTerm = Is-Zero | If[Bool]


let Zero = struct {}
let Succ = struct { data arg: ITerm }
let Pred = struct { data arg: ITerm }
let Is-Zero = struct { data arg: ITerm }
let If[T] = struct {
    data condition: BTerm
    data then-branch: T
    data else-branch: T
}


let Term.Output = Int | Bool
let ITerm.Output = Int
let BTerm.Output = Bool
let Zero.Output = Int
let Succ.Output = Int
let Pred.Output = Int
let Is-Zero.Output = Bool
let If[T].Output = T


let (Term).eval -> Term.Output
let (ITerm).eval -> Int
let (BTerm).eval -> Bool
let (Zero).eval -> Int { 0 }
let (Succ).eval -> Int { self.arg.eval + 1 }
let (Pred).eval -> Int { self.arg.eval - 1 }
let (Is-Zero).eval -> Bool { self.arg.eval == 0 }
let (If[T]).eval -> T {
    if self.condition.eval {
        self.then-branch.eval
    } else {
        self.else-branch.eval
    }
}


-- Third GADT Example: Higher-Order Abstract Syntax ---------------------------


<<
From
[wikipedia](https:--en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
>>


module gadt3


let Lift[T] = struct {
    data value: T
}


forall T #expr, U #expr
let Pair[T, U] = struct {
    data first: T
    data second: U
}


forall T #expr, U #expr
let Lambda[T, U] = struct {
    data value: T -> U
}


forall T #expr, U #expr
let Apply[T, U] = struct {
    data function: Lambda[T, U]
    data argument: U
}


forall T #expr, U #expr
let Fix[T] = struct {
    data function: Lambda[T, T]
}


let #expr = trait {
    has Self.Output
    has (Self).eval -> Self.Output
}


def #expr for Lift[T], Pair[T, U], Lambda[T, U], Apply[T, U], Fix[T]


let Lift[T].Output = alias T
let Pair[T, U].Output = alias (T, U)
let Lambda[T, U].Output = alias T -> U
let Apply[T, U].Output = alias U
let Fix[T].Output = alias T


let (Lift[T]).eval -> T {
    self.first.value
}


let (Pair[T, U]).eval -> (T, U) {
    (self.first.eval, self.second.eval)
}


let (Lambda[T, U]).eval -> (T -> U) {
    { x => self.function(Lift(x)).eval }
}


let (Apply[T, U]).eval -> U {
    self.function.eval(self.argument.eval)
}


let (Fix[T]).eval -> T {
    self.function.eval(Fix(self.function).eval)
}


let example() -> Io[] {
    let factorial = Fix(
        Lambda {
                f =>
                    Lambda {
                        y =>
                            let y' = y.eval
                            let f' = f.eval

                            if y' == 0 {
                                Lift(1)
                            } else {
                                Lift(y' * f'(y' - 1))
                            }
                    }
        }
    )

    let factorial-of-ten = Apply(factorial, Lift(10))

    Io.print(factorial-of-ten.eval)
}
