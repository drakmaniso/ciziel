--- [from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
module gadt_example_1


def #expr =
    has Self.Output #eq
    has (Self).eval() -> Output


def Expr = enum(EBool | EInt | EEqual)
def EBool = struct(value: Bool)
def EInt = struct(value: Int)
def EEqual = struct(left: *EInt, right: *EInt)


def Expr as #expr


def EBool as #expr
def EBool.Output = Bool
def (EBool).eval() -> Bool = self.value


def EInt as #expr
def EInt.Output = Int
def (EInt).eval() -> Int = self.value


def EEqual as #expr
def EEqual.Output = Bool
def (EEqual).eval() -> Bool = self.left.eval() == self.right.eval()

[[ implicitly defines: ]]
def Expr.Output = enum(Int | Bool)
def (Expr).eval() -> enum(Int | Bool) =
    match self
    case e: EBool then e.eval()
    case e: Eint then e.eval()
    else e: EEqual then e.eval()


let expr1 = EEqual(EInt 2, EInt 3)
    -- expr1: EEqual
let ret = expr1.eval()
    -- ret: Bool


let exprs = Array(Expr.EInt 2, Expr.EBool True, Expr.EEqual(EInt 2, EInt 3))
    -- exprs: Array[Expr]
let rets = exprs.map(___.eval())
    -- rets: Array[enum(Int | Bool)]


-------------------------------------------------------------------------------
--- GADT example: phantom types
--- From ["Fun with phantom types"] by R. Hinze
---
--- ["Fun with phantom types"]: https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
module


def Term[T] =
    enum(Zero[T] | Succ[T] | Pred[T] | IsZero[T] | If[T])


def Zero[T] =
    struct()
    
def Succ[T] =
    struct(arg: Term[T])

def Pred[T] =
    struct(arg: Term[T])

def IsZero[T] =
    struct(arg: Term[Int])

def If[T] =
    struct {
        condition: Term[Bool],
        then-branch: Term[T],
        else-branch: Term[T],
    }


def (Zero[Int]).eval() -> Int =
    0

def (Succ[Int]).eval() -> Int =
    self.arg.eval() + 1

def (Pred[Int]).eval() -> Int =
    self.arg.eval() - 1

def (IsZero[Bool]).eval() -> Bool =
    (self.arg.eval() == 0)

def (If[T]).eval() -> T =
    if self.condition.eval() then
        self.then-branch.eval()
    else
        self.else-branch.eval()


-- (implicitly defined)
def (Term[T]).eval() -> T =
    match self
    case z: Zero[T] then z.eval()
    case s: Succ[T] then s.eval()
    case p: Pred[T] then p.eval()
    case iz: IsZero[T] then iz.eval()
    else i: If[T] then i.eval()


-------------------------------------------------------------------------------
--- GADT example: higher-order abstract syntax
--- From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
module


def #expr =
    has Self.Output
    has (Self).eval() -> Self.Output


def Lift[T] =
    struct(value: T)

def Pair[T, U] =
    struct(first: T, second: U)

def Lambda[T, U] =
    struct(function: Func(T) -> U)

def Apply[T, U] =
    struct(function: Lambda[T, U], argument: U)

def Fix[T] =
    struct(function: Lambda[T, T])


def Lift[T] as #expr

def Lift[T].Output = alias T

def (Lift[T]).eval() -> T =
    self.first.value


forall T #expr, U #expr
def Pair[T,U] as #expr

def Pair[T, U].Output = alias (T, U)

forall T #expr, U #expr
def (Pair[T, U]).eval() -> (T, U) =
    (self.first.eval(), self.second.eval())


forall T #expr, U #expr
def Lambda[T, U] as #expr

def Lambda[T, U].Output = alias Func(T) -> U

forall T #expr, U #expr
def (Lambda[T, U]).eval() -> fun(T) -> U =
    fun(x) -> self.function(Lift(x)).eval()


forall T #expr, U #expr
def Apply[T, U] as #expr

def Apply[T, U].Output = alias U

forall T #expr, U #expr
def (Apply[T, U]).eval() -> U =
    self.function.eval()(self.argument.eval())


forall T #expr
def Fix[T] as #expr

def Fix[T].Output = alias T

forall T #expr
def (Fix[T]).eval() -> T =
    self.function.eval()(Fix(self.function).eval())


let example() =
    let factorial =
        Fix(
            Lambda(fun(f) =>
                Lambda(fun(y) =>
                    Lift(
                        let y' = y.eval()
                        let f' = f.eval()
                        if y' == 0 then 1 else y' * f'(y' - 1)
                    )
                )
            )
        )
    Io.print(Apply(factorial, Lift(10)).eval())
