--- [from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
module gadt_example_1


public Expr = enum(EBool | EInt | EEqual)
public EBool = struct(value: Bool)
public EInt = struct(value: Int)
public EEqual = struct(left: *EInt, right: *EInt)


public #expr =
    has Self.Output #eq
    has (Self).eval() -> Output
    implement Expr, EBool, EInt, EEqual


public EBool.Output = Bool
public (EBool).eval() -> Bool = self.value


public EInt.Output = Int
public (EInt).eval() -> Int = self.value


public EEqual.Output = Bool
public (EEqual).eval() -> Bool = self.left.eval() == self.right.eval()

[[ implicitly defines: ]]
public Expr.Output = enum(Int | Bool)
public (Expr).eval() -> enum(Int | Bool) =
    match self
    case e: EBool then e.eval()
    case e: Eint then e.eval()
    case e: EEqual then e.eval()
    end


local expr1 = EEqual(EInt 2, EInt 3)
    -- expr1: EEqual
local ret = expr1.eval()
    -- ret: Bool


local exprs = Array(Expr.EInt 2, Expr.EBool True, Expr.EEqual(EInt 2, EInt 3))
    -- exprs: Array[Expr]
local rets = exprs.map(___.eval())
    -- rets: Array[enum(Int | Bool)]


-------------------------------------------------------------------------------
--- GADT example: phantom types
--- From ["Fun with phantom types"] by R. Hinze
---
--- ["Fun with phantom types"]: https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
module


public Term[T] =
    enum(Zero[T], Succ[T], Pred[T], IsZero[T], If[T])


public Zero[T] =
    struct()
    
public Succ[T] =
    struct(arg: Term[T])

public Pred[T] =
    struct(arg: Term[T])

public IsZero[T] =
    struct(arg: Term[Int])

public If[T] =
    struct {
        condition: Term[Bool],
        then-branch: Term[T],
        else-branch: Term[T],
    }


public (Zero[Int]).eval() -> Int =
    0

public (Succ[Int]).eval() -> Int =
    self.arg.eval() + 1

public (Pred[Int]).eval() -> Int =
    self.arg.eval() - 1

public (IsZero[Bool]).eval() -> Bool =
    (self.arg.eval() == 0)

public (If[T]).eval() -> T =
    if self.condition.eval() then
        self.then-branch.eval()
    else
        self.else-branch.eval()


-- (implicitly defined)
public (Term[T]).eval() -> T =
    match self
    case z: Zero[T] then z.eval()
    case s: Succ[T] then s.eval()
    case p: Pred[T] then p.eval()
    case iz: IsZero[T] then iz.eval()
    case i: If[T] then i.eval()
    end


-------------------------------------------------------------------------------
--- GADT example: higher-order abstract syntax
--- From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
module


public #expr =
    has Self.Output
    has (Self).eval() -> Self.Output


public Lift[T] =
    struct(value: T)
    has #expr


public Pair[T, U] =
    struct(first: T, second: U)
    has #expr


public Lambda[T, U] =
    struct(function: Func(T) -> U)
    has #expr


public Apply[T, U] =
    struct(function: Lambda[T, U], argument: U)
    has #expr


public Fix[T] =
    struct(function: Lambda[T, T])
    has #expr


public Lift[T].Output = alias T
public (Lift[T]).eval() -> T =
    self.first.value


public Pair[T, U].Output = alias (T, U)
public (Pair[T, U]).eval() -> (T, U)
    forall T #expr, U #expr
    =
    (self.first.eval(), self.second.eval())


public Lambda[T, U].Output = alias Func(T) -> U
public (Lambda[T, U]).eval() -> fun(T) -> U
    forall T #expr, U #expr
    =
    fun(x) -> self.function(Lift(x)).eval()


public Apply[T, U].Output = alias U
public (Apply[T, U]).eval() -> U
    forall T #expr, U #expr
    =
    self.function.eval()(self.argument.eval())


public Fix[T].Output = alias T
public (Fix[T]).eval() -> T
    forall T #expr
    =
    self.function.eval()(Fix(self.function).eval())


local example() =
    let factorial =
        Fix(
            Lambda(fun(f) ->
                Lambda(fun(y) ->
                    Lift(
                        let y' = y.eval()
                        let f' = f.eval()
                        if y' == 0 then 1 else y' * f'(y' - 1)
                    )
                )
            )
        )
    Io.print(Apply(factorial, Lift(10)).eval())
