/*
# GADT
*/


/*
## First GADT Example #########################################################

[from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
*/
module gadt1


let #expr {
    has Self.Output: #eq
    has eval(self) -> Output
}


let Expr = EBool | EInt | EEqual

let EBool {
    var value: Bool
}

let EInt {
    var value: Int
}

let EEqual {
    var left: *EInt
    var right: *EInt
}


extend Expr as #expr {
    has Expr.Output = Int | Bool
    has eval(self) -> Int | Bool
}

extend EBool as #expr {
    let EBool.Output = Bool
    let eval(self) -> Bool {
        self.value
    }
}

extend EInt as #expr {
    let EInt.Output = Int
    let eval(self) -> Int {
        self.value
    }
}

extend EEqual as #expr {
    let EEqual.Output = Bool
    let eval(self) -> Bool {
        self.left.eval() == self.right.eval()
    }
}


let main() -> Io[] {
    expr1 = EEqual(EInt 2, EInt 3)
    Io.print("{expr1.Type}")
    // EEqual

    eval1 = expr1.eval()
    Io.print("{eval1.Type}")
    // Bool

    exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
    Io.print("{expr2.Type}")
    // Array[EBool | EEqual | EInt]

    evals = exprs.map(___.eval())
    Io.print("{evals.Type}")
    // Array[Bool | Int]
}


/*
## Second GADT Example: Phantom Types #########################################

From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
*/
module gadt2


let Term[T] = Zero[T] | Succ[T] | Pred[T] | IsZero[T] | If[T]

let Zero[T]

let Succ[T] {
    var arg: Term[T]
}

let Pred[T] {
    var arg: Term[T]
}

let IsZero[T] {
    var arg: Term[Int]
}

let If[T] {
    var condition: Term[Bool]
    var then-branch: Term[T]
    var else-branch: Term[T]
}


derive Term[T] {
    let eval(self) -> T
}

forall T = Int
extend Zero[T] {
    let eval(self) -> Int {
        0
    }
}

forall T = Int
extend Succ[T] {
    let eval(self) -> Int {
        self.arg.eval() + 1
    }
}

forall T = Int
extend Pred[T] {
    let eval(self) -> Int {
        self.arg.eval() - 1
    }
}

forall T = Bool
extend IsZero[T] {
    let eval(self) -> Bool {
        self.arg.eval() == 0
    }
}

extend If[T] {
    let eval(self) -> T {
        if self.condition.eval() {
            self.then-branch.eval()
        } else {
            self.else-branch.eval()
        }
    }
}


/*
## Third GADT Example: Higher-Order Abstract Syntax ###########################

From
[wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
*/
module gadt3


let #expr {
    has Output
    has eval(self) -> Self.Output
}


let Lift[T] {
    var value: T
}

let Pair[T, U] {
    var first: T
    var second: U
}

let Lambda[T, U] {
    var value: fun(T) -> U
}

let Apply[T, U] {
    var function: Lambda[T, U]
    var argument: U
}

let Fix[T] {
    var function: Lambda[T, T]
}


extend Lift[T] as #expr {
    let Output = T

    let eval() -> T {
        self.first.value
    }
}

forall T: #expr, U: #expr
extend Pair[T,U] as #expr {
    let Output = (T, U)

    let eval() -> (T, U) {
        (self.first.eval(), self.second.eval())
    }
}


forall T: #expr, U: #expr
extend Lambda[T, U] as #expr {
    let Output = fun(T) -> U

    let eval() -> fun(T) -> U {
        fun(x) {
            self.function(Lift(x)).eval()
        }
    }
}


forall T: #expr, U: #expr
extend Apply[T, U] as #expr {
    let Output = U

    let eval() -> U {
        self.function.eval(self.argument.eval())
    }
}


forall T: #expr
extend Fix[T] as #expr {
    let Output = T

    let eval() -> T {
        self.function.eval(Fix(self.function).eval())
    }
}


let example() {
    let factorial =
        Fix(
            Lambda(fun(f) {
                Lambda(fun(y) {
                    y' = y.eval()
                    f' = f.eval()

                    if y' == 0 {
                        Lift(1)
                    } else {
                        Lift(y' * f'(y' - 1))
                    }
                })
            })
        )

    Io.print(Apply(factorial, Lift(10)).eval())
}