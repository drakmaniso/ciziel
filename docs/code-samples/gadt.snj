--- GADT ----------------------------------------------------------------------


module gadt1 --- First GADT Example -------------------------------------------


<<
[from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
>>


public


Expr = EBool | EInt | EEqual
EBool = struct(value: Bool)
EInt = struct(value: Int)
EEqual = struct(left: *EInt, right: *EInt)


#expr =
	trait {
		Self.Output: Type
		(Self).eval -> Self.Output
	}


Expr: #expr
Expr.Output = Int | Bool
(Expr).eval -> Int | Bool = auto


EBool: #expr
EBool.Output = Bool
(EBool).eval -> Bool = self.value


EInt: #expr
EInt.Output = Int
(EInt).eval -> Int = self.value


EEqual: #expr
EEqual.Output = Bool
(EEqual).eval -> Bool = (self.left.eval == self.right.eval)


main() -> Nil &io =
	do
		expr1 = EEqual(EInt 2, EInt 3)
		io.print("{expr1.Type.name}")
		--> EEqual

		eval1 = expr1.eval
		io.print("{eval1.Type.name}")
		--> Bool

		exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
		io.print("{expr2.Type.name}")
		--> Array[Expr]

		evals = exprs.map(___.eval)
		io.print("{evals.Type.name}")
		--> Array[Bool | Int]
	end


module gadt2 --- Second GADT Example: Phantom Types ---------------------------


<<
From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
>>


public


Term = ITerm | BTerm
ITerm = Zero | Succ | Pred | If[Term]
BTerm = Is-Zero | If[Bool]


Zero = struct
Succ = struct(arg: ITerm)
Pred = struct(arg: ITerm)
Is-Zero = struct(arg: ITerm)
If =
	struct[T] {
		condition: BTerm,
		then-branch: T,
		else-branch: T,
	}


Term.Output = Int | Bool
ITerm.Output = Int
BTerm.Output = Bool
Zero.Output = Int
Succ.Output = Int
Pred.Output = Int
Is-Zero.Output = Bool
If[T].Output = T


(Term).eval -> Int | Bool = auto
(ITerm).eval -> Int = auto
(BTerm).eval -> Bool = auto


(Zero).eval -> Int = 0
(Succ).eval -> Int = self.arg.eval + 1
(Pred).eval -> Int = self.arg.eval - 1
(Is-Zero).eval -> Bool = self.arg.eval == 0
(If[T]).eval -> T =
	if self.condition.eval then
		self.then-branch.eval
	else
		self.else-branch.eval
	end


module gadt3 --- Third GADT Example: Higher-Order Abstract Syntax -------------


<<
From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
>>


public


#expr =
	trait {
		Self.Output: Type
		(Self).eval -> Self.Output
	}


Lift[T]: #expr =
	struct(value: T)


Pair[T, U]: #expr
	forall T: #expr
		and U: #expr
	=
	struct(
		first: T,
		second: U,
	)


Lambda[T, U]: #expr
	forall T: #expr
		and U: #expr
	=
	struct(value: T -> U)


Apply[T, U]: #expr
	forall T: #expr
		and U: #expr
	=
	struct(
		function: Lambda[T, U],
		argument: U,
	)


Fix[T]: #expr
	forall T: #expr
	=
	struct(function: Lambda[T, T])


Lift[T].Output = T
Pair[T, U].Output = (T, U)
Lambda[T, U].Output = T -> U
Apply[T, U].Output = U
Fix[T].Output = T


(Lift[T]).eval -> T =
	self.first.value


(Pair[T, U]).eval -> (T, U) =
	(self.first.eval, self.second.eval)


(Lambda[T, U]).eval -> (T -> U) =
	x => self.function(Lift(x)).eval


(Apply[T, U]).eval -> U =
	self.function.eval(self.argument.eval)


(Fix[T]).eval -> T =
	self.function.eval(Fix(self.function).eval)


example() -> Nil &io =
	do
		factorial =
			Fix(
				Lambda(
					f =>
						Lambda(
							y =>
								y' = y.eval
								f' = f.eval

								if y' == 0 then
									Lift(1)
								else
									Lift(y' * f'(y' - 1))
								end
						)
				)
			)

		factorial-of-ten = Apply(factorial, Lift(10))
		io.print(factorial-of-ten.eval)
	end
