/*
# GADT
*/


/*
## First GADT Example #########################################################

[from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
*/
module gadt1


def #expr {
    has Self.Output: #eq
    has eval() -> Output
}


def Expr = EBool | EInt | EEqual

def EBool {
    var value: Bool
}

def EInt {
    var value: Int
}

def EEqual {
    var left: *EInt
    var right: *EInt
}


derive Expr as #expr {
    def Expr.Output = Int | Bool
    def eval() -> Int | Bool
}

extend EBool as #expr {
    def EBool.Output = Bool
    def eval() -> Bool {
        self.value
    }
}

extend EInt as #expr {
    def EInt.Output = Int
    def eval() -> Int {
        self.value
    }
}

extend EEqual as #expr {
    def EEqual.Output = Bool
    def eval() -> Bool {
        self.left.eval() == self.right.eval()
    }
}


let main() -> Io[] {
    expr1 = EEqual(EInt 2, EInt 3)
    Io.print("{expr1.Type}")
    // EEqual

    eval1 = expr1.eval()
    Io.print("{eval1.Type}")
    // Bool

    exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
    Io.print("{expr2.Type}")
    // Array[EBool | EEqual | EInt]

    evals = exprs.map(___.eval())
    Io.print("{evals.Type}")
    // Array[Bool | Int]
}


/*
## Second GADT Example: Phantom Types #########################################

From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
*/
module gadt2


def Term[T] = Zero[T] | Succ[T] | Pred[T] | IsZero[T] | If[T]

def Zero[T]

def Succ[T] {
    var arg: Term[T]
}

def Pred[T] {
    var arg: Term[T]
}

def IsZero[T] {
    var arg: Term[Int]
}

def If[T] {
    var condition: Term[Bool]
    var then-branch: Term[T]
    var else-branch: Term[T]
}


derive Term[T] {
    def eval() -> T
}

forall T = Int
extend Zero[T] {
    def eval() -> Int {
        0
    }
}

forall T = Int
extend Succ[T] {
    def eval() -> Int {
        self.arg.eval() + 1
    }
}

forall T = Int
extend Pred[T] {
    def eval() -> Int {
        self.arg.eval() - 1
    }
}

forall T = Bool
extend IsZero[T] {
    def eval() -> Bool {
        self.arg.eval() == 0
    }
}

extend If[T] {
    def eval() -> T {
        if self.condition.eval() {
            self.then-branch.eval()
        } else {
            self.else-branch.eval()
        }
    }
}


/*
## Third GADT Example: Higher-Order Abstract Syntax ###########################

From
[wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
*/
module gadt3


def #expr {
    has Self.Output
    has eval() -> Self.Output
}


def Lift[T] {
    var value: T
}

def Pair[T, U] {
    var first: T
    var second: U
}

def Lambda[T, U] {
    var value: fun(T) -> U
}

def Apply[T, U] {
    var function: Lambda[T, U]
    var argument: U
}

def Fix[T] {
    var function: Lambda[T, T]
}


extend Lift[T] as #expr {
    def Lift.Output = T

    def eval() -> T {
        self.first.value
    }
}

forall T: #expr, U: #expr
extend Pair[T,U] as #expr {
    def Pair.Output = (T, U)

    def eval() -> (T, U) {
        (self.first.eval(), self.second.eval())
    }
}


forall T: #expr, U: #expr
extend Lambda[T, U] as #expr {
    def Lambda.Output = fun(T) -> U

    def eval() -> fun(T) -> U {
        fun(x) {
            self.function(Lift(x)).eval()
        }
    }
}


forall T: #expr, U: #expr
extend Apply[T, U] as #expr {
    def Apply.Output = U

    def eval() -> U {
        self.function.eval(self.argument.eval())
    }
}


forall T: #expr
extend Fix[T] as #expr {
    def Fix.Output = T

    def eval() -> T {
        self.function.eval(Fix(self.function).eval())
    }
}


let example() {
    let factorial =
        Fix(
            Lambda(fun(f) {
                Lambda(fun(y) {
                    y' = y.eval()
                    f' = f.eval()

                    if y' == 0 {
                        Lift(1)
                    } else {
                        Lift(y' * f'(y' - 1))
                    }
                })
            })
        )

    Io.print(Apply(factorial, Lift(10)).eval())
}