[[ # GADT ]]

[[ ## First Example ]]

[[ [from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type ]]


module gadt_example_1


def #expr {
    has ::Output: #eq
    has .eval -> Output
}


def Expr = EBool | EInt | EEqual
def EBool(var value: Bool)
def EInt(var value: Int)
def EEqual(var left: *EInt, var right: *EInt)


extend EBool as #expr {
    def ::Output = Bool
    def .eval -> Bool { self.value }
}


extend EInt as #expr {
    def ::Output = Int
    def .eval -> Int { self.value }
}


extend EEqual as #expr {
    def ::Output = Bool
    def .eval -> Bool { self.left.eval == self.right.eval }
}


[[ implicitly defines: ]]


derive Expr as #expr {
    def ::Output = Int | Bool
    def .eval -> Int | Bool
}


let expr1 = EEqual(EInt 2, EInt 3)
    -- expr1: EEqual


let ret = expr1.eval
    -- ret: Bool


let exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
    -- exprs: Array[Expr]


let rets = exprs.map(___.eval)
    -- rets: Array[enum(Int | Bool)]


-------------------------------------------------------------------------------
--- GADT example: phantom types

[[ From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]: https://www.researchgate.net/publication/228707929_Fun_with_phantom_types ]]


module


def Term[T] = Zero[T] | Succ[T] | Pred[T] | IsZero[T] | If[T]

def Zero[T]
    
def Succ[T](var arg: Term[T])

def Pred[T](var arg: Term[T])

def IsZero[T](var arg: Term[Int])

def If[T](
    var condition: Term[Bool],
    var then-branch: Term[T],
    var else-branch: Term[T],
)


extend Term[T] {
    has def .eval -> T
}


forall T = Int
extend Zero[T] {
    def .eval -> Int {
        0
    }
}


forall T = Int
extend Succ[T] {
    def .eval -> Int {
        self.arg.eval + 1
    }
}


forall T = Int
extend Pred[T] {
    def .eval -> Int {
        self.arg.eval - 1
    }
}


forall T = Bool
extend IsZero[T] {
    def .eval -> Bool {
        self.arg.eval == 0
    }
}


extend If[T] {
    def .eval -> T {
        if self.condition.eval {
            self.then-branch.eval
        } else {
            self.else-branch.eval
        }
    }
}


-------------------------------------------------------------------------------
--- GADT example: higher-order abstract syntax
--- From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)


module


def #expr {
    has ::Output
    has .eval -> Self::Output
}


def Lift[T](var value: T)

def Pair[T, U](var first: T, var second: U)

def Lambda[T, U](var function: \ T -> U)

def Apply[T, U](var function: Lambda[T, U], var argument: U)

def Fix[T](var function: Lambda[T, T])


extend Lift[T] as #expr {
    def ::Output = T

    def .eval -> T {
        self.first.value
    }
}


forall T: #expr, U: #expr
extend Pair[T,U] as #expr {
    def ::Output = (T, U)

    def .eval -> (T, U) {
        (self.first.eval, self.second.eval)
    }
}


forall T: #expr, U: #expr
extend Lambda[T, U] as #expr {
    def ::Output = fun(T) -> U

    def .eval -> fun(T) -> U {
        \ x { self.function( Lift(x) ).eval }
    }
}


forall T: #expr, U: #expr
extend Apply[T, U] as #expr {
    def ::Output = U

    def .eval -> U {
        self.function.eval(self.argument.eval)
    }
}


forall T: #expr
extend Fix[T] as #expr {
    def ::Output = T

    def .eval -> T {
        self.function.eval( Fix(self.function).eval )
    }
}


let example() {
    let factorial =
        Fix(
            Lambda \ f {
                Lambda \ y {
                    Lift(
                        let y' = y.eval
                        let f' = f.eval
                        if y' == 0 then 1 else y' * f'(y' - 1)
                    )
                }
            }
        )
    
    Io.print( Apply( factorial, Lift(10) ).eval )
}