// [Haskell's Typeclassopedia]: https://wiki.haskell.org/Typeclassopedia


def #functor[A] {
    has (Self[A]).fmap(transform: A -> B) -> Self[B]

    has (Self[A]) $> (value: B) -> Self[B] {
        self.map { any => value }
    }

    has Self[A].lift(transform: A -> B) -> (Self[A] -> Self[B]) {
        { ___.map(transform) }
    }
}


/************************************************************************************/


def #applicative {
    has #functor

    // aka `wrap`
    has Self[A].pure(value: A) -> Self[A]

    // aka `apply`
    has (Self[A -> B]) <*> (functor: Self[A]) -> Self[B]

    // aka `and-then`?
    has (Self[A]) *> (other: Self[B]) -> Self[B] {
        (identity <$ a) <*> b
    }

    // aka `discard`? `when-also`?
    has (Self[A]) <* (other: Self[B]) -> Self[A] {
        let const-f = { x, any => x }
        Self.lift-2(const-f)
    }

    has Self[Any].lift-2(f: (A, B) -> C) -> (Self[A], Self[B]) -> Self[C] {
        let curried-f: A -> B -> C = { a => { b => f(a, b) } }

        {
            a, b =>
                Self.pure(curried-f) <*> Self.pure(a) <*> Self.pure(b)
        }
    }
}


/************************************************************************************/


def #monad {
    has #applicative

    // aka `chain`, `flat-map`, `bind`...
    has (Self[A]) >>= (operation: A -> Self[B]) -> Self[B]

    has (Self[A]) >> (other: Self[B]) -> Self[B] {
        self >>= { any => other }
    }

    has (Self[M[A]]).join -> Self[A]
        forall M #monad
    {
        self.chain(identity)
    }
}


def #monad-fail {
    has #monad

    has Self[A].fail(msg: String) -> Self[A]
}


//TODO: is this correct?
def #monad-trans {
    has Self[M, A].lift(monad: M[A]) -> Self[M, A]
}


def #comonad
{
    has #functor

    has (Self[A]).extract -> A

    has (Self[A]).duplicate -> Self[Self[A]]
    {
        self.extend(identity)
    }

    has (Self[A]).extend(f: fun(Self[A]) -> B) -> Self[B]
    {
        self.duplicate.map(f)
    }
}


/************************************************************************************/


def #semigroup {
    has append(self, other: Self) -> Self
}


has #monoid {
    has #semigroup

    has empty: Self

    has concat(values: A[Self] #functor) -> Self {
        values.fold(Self.append, Self.empty)
    }
}


/************************************************************************************/

def #alternative {
    has #applicative

    has #monoid
}


def #monad-plus {
    has #monad

    has #monoid
}


/************************************************************************************/

def #reduce {
    has (Self[T]).reduce(operation: (T, T) -> T) -> T
        forall T #monoid

    has (Self[T]).fold-map(operation: T -> A) -> A
        forall T #monoid
}


def [T #monoid] #reduce =
    has reduce(self, operation: (T, T) -> T) -> T
    has fold-map(self, operation: T -> A) -> A

// Catamorphisms
def [T] #foldable =
    has fold(self, initial: A, operation: (A, T) -> A) -> A
    has rev-fold(self, initial: A, operation: (T, A) -> A) -> A

// Anamorphisms
def [T] #unfoldable =
    has unfold(initial: A, operation: A -> Option[(T, A)]) -> Self[T]

def [T] #traversable =
    has Self[T] #functor
    has Self[T] #foldable // or #reduce?
    has traverse(self, operation: T -> F[B] #functor) -> F[Self[B]]
    has sequence(stuff: Self[F[T] #functor]) -> F[Self[T]]


/************************************************************************************/

def [T, U] #bifunctor =
    has bimap(self, left-operation: T -> A, right-operation: U -> B) -> Self[A, B]
    has left-map(self, left-operation: T -> A) -> Self[A, U] =
        self.bimap(left-operation, identity)
    has right-map(self, right-operation: U -> A) -> Self[T, A] =
        self.bimap(identity, right-operation)


/************************************************************************************/

def [T, U] #category =
    has id: Self[T, T]
    has compose(self, other: Self[U -> A]) -> Self[T -> A]

def [T, U] #arrow =
    has Self[T, U] #category
    has arrow(operation: T -> U) -> Self[T, U]
    has first(self) -> Self[(T, A), (U, A)]
    has parrallel-compose(self, other: Self[A, B]) -> Self[(T, A), (U, B)]
    has fanout-compose(self, other: Self[T, A]) -> Self[T, (U, A)]

def [T, U] #arrow-apply =
    has Self[T, U] #arrow
    has application: Self[(Self[A, B], A), B]

def [T, U] #arrow-loop =
    has Self[T, U] #arrow
    has loop(Self[(A, C), (B, C)]) -> Self[A, B]


/************************************************************************************/

def [T] #comonad =
    has Self[T] #functor
    has extract(self) -> T
    has duplicate(self) -> Self[Self[T]]
    def extend(self, operation: Self[T] -> A) -> Self[A] =
        self.duplicate.map(operation)
