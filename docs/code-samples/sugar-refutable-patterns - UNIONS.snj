---- Refutable Bind -----------------------------------------------------------


fun example-1(numbers: Array[Int]) -> Int | None =
	first: Int ?= numbers.at(0)
	second: Int ?= numbers.at(1)
	first + second


fun example-1-desugared(numbers: Array[Int]) -> Int | None =
	case numbers.at(0)
		of first: Int then
			case numbers.at(1)
			of second: Int then first + second
			of a then a
			end
		of a then a
	end


fun example-2(numbers: Array[String]) -> Int | None | Int.Parse-Error =
	string-a: String ?= numbers.at(0)
	number-a: Int ?= Int.parse(string-a)
	string-b: String ?= numbers.at(1)
	number-b: Int ?= Int.parse(string-b)
	number-a + number-b


fun example-2-desugared(numbers: Array[String]) -> Int | None | Int.Parse-Error =
	case numbers.at(0)
		of string-a: String then
			case Int.parse(string-a)
				of number-a: Int then
					case numbers.at(1)
						of string-b: String then
							case Int.parse(string-b)
								of number-b: Int then
									number-a + number-b
								of e then e
							end
						of e then e
					end
				of e then e
			end
		of e then e
	end


fun example-3(numbers: Array[String]) -> Int | My-Error =
	string-a: String ?= numbers.at(0) !! => My-Error("array is emtpy")
	number-a: Int ?= Int.parse(string-a) !! e => My-Error("parse error: {e}")
	string-b: String ?= numbers.at(1) !! => My-Error("array is too smal")
	number-b: Int ?= Int.parse(string-b) !! e => My-Error("parse error: {e}")
	number-a + number-b


fun example-3-desugard(numbers: Array[String]) -> Int | My-Error =
	case
		case numbers.at(0)
			of _: #failure then My-Error("array is empty")
			of x then x
		end
		of string-a: String then
			case
				case Int.parse(string-a)
					of e: #failure then My-Error("parse error: {e}")
					of x then x
				end
				of number-a: Int then
					case
						case numbers.at(1)
							of _: #failure then My-Error("array is too small")
							of x then x
						end
						of string-b: String then
							case
								case Int.parse(string-b)
									of e: #failure then My-Error("parse error: {e}")
									of x then x
								end
								of number-b: Int then
									number-a + number-b
								of e then e
							end
						of e then e
					end
				of e then e
			end
		of e then e
	end


---- Chaining Operator --------------------------------------------------------


fun example-3(numbers: Array[String]) -> Int | None =
	numbers.at(0)?.to-Int?.abs


fun example-3-desugared(numbers: Array[String]) -> Int | None =
	case numbers.at(0)
		of s: String then
			case s.to-Int
				of n: Int then n.abs
				of a then a
			end
		of a then a
	end


---- Short-Circuit Operator --------------------------------------------------------


fun example-3(numbers: Array[String]) -> Int | None =
	math::abs(Int.parse(numbers[0]?)?)


fun example-3-desugared(numbers: Array[String]) -> Int | None =
	case numbers.at(0)
		of s: String then
			case Int.parse(s)
				of n: Int then math::abs(n)
				of a then a
			end
		of a then a
	end


---- Refutable Bind with failure wrapping -------------------------------------


<<
From a Rust RFC:
	fn get_count_item(s: &str) -> (u64, &str) {
		let mut it = s.split(' ');
		let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
			panic!("Can't segment count item pair: '{s}'");
		};
		let Ok(count) = u64::from_str(count_str) else {
			panic!("Can't parse integer: '{count_str}'");
		};
		(count, item)
	}
>>


fun get-count-item(s: String) -> (Int, String) | None | Int.Parse-Error =
	it = s.split(Char " ")
	count-str: String ?= it.item
	it' = it.next
	item: String ?= it'.item
	count: Int ?= Int.parse(count-str)

	(count, item)


struct Segment-Error #error
struct Parse-Error #error (cause: Int.Parse-Error)
fun get-count-item(s: String) -> (Int, String) | Segment-Error | Parse-Error =
	it = s.split(Char " ")
	count-str: String ?= it.item ?? Segment-Error
	it' = it.next
	item: String ?= it'.item ?? Segment-Error
	count: Int ?= Int.parse(count-str) ??? e => Parse-Error(e)

	(count, item)


fun get-count-item(s: String) -> (Int, String) | None | Int.Parse-Error =
	let it = s.split(Char " ")
	let? count-str: String = it.item
	let it' = it.next
	let? item: String = it'.item
	let? count: Int = Int.parse(count-str)

	(count, item)


struct Segment-Error #error
struct Parse-Error #error (cause: Int.Parse-Error)
fun get-count-item(s: String) -> (Int, String) | Segment-Error | Parse-Error =
	let it = s.split(Char " ")
	let? count-str: String = it.item ?? Segment-Error
	let it' = it.next
	let? item: String = it'.item ?? Segment-Error
	let? count: Int = Int.parse(count-str) ??? e => Parse-Error(e)

	(count, item)
