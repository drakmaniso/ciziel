<< The Expression Problem >>


module basic


public


struct Literal(value: data Int)
struct Addition[E](left: data *E, right: data *E)


trait #eval {
	fun (Self).eval -> Int
}


tag Literal #eval
forall E #eval
tag Addition[E] #eval


fun (Literal).eval -> Int =
	self.value


forall E #eval
fun (Addition[E]).eval -> Int =
    self.left.eval + self.right.eval


-------------------------------------------------------------------------------


module extended
use basic (#eval, Literal, Addition)
public


struct Negation[E](subexpr: *E)


forall E #eval
tag Negation[E] #eval


forall E #eval
fun (Negation[E]).eval -> Int =
    - self.subexpr.eval


trait #pretty {
	fun (Self).pretty -> String
}


tag Literal #pretty
forall E #pretty
tag Addition[E] #pretty
forall E #pretty
tag Negation[E] #pretty


fun (Literal).pretty -> String =
    self.value.to-string


forall E #eval
fun (Addition[E]).pretty -> String =
	l = self.left.pretty
	r = self.right.pretty

	case (self.left, self.right)
		of (Literal(...), Literal(...)) then "{l} + {r}"
		of (Literal(...), _) then "{l} + ({r})"
		of (_, Literal(...)) then "({l}) + {r}"
		of (_, _) then "({l}) + ({r})"
	end


fun (Negation[#pretty]).pretty -> String =
    "- ({self.subexpr.pretty})"


module main --- Usage ---------------------------------------------------------
use /std/io (&io)
use basic (#eval, Literal, Addition)
use extended (#pretty, Negation)


type Expr = Literal | Addition[Expr] | Negation[Expr]


fun main() -> Void &io =
	do
		e1: Expr = Addition(Literal(77), Negation(Literal(12)))
		print("{e1.pretty} = {e1.eval}")
	end
