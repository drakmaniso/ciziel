module foo


define #eval =
	trait {
		(Self).eval -> Int
	}


define Literal =
	struct {
		value: Int,
	}
	impl #tuple
	impl #eval


define Addition[T] =
	struct {
		left: Expr[T],
		right: Expr[T],
	}
	impl #tuple
	impl #eval forall T #eval


define (Literal).eval -> Int =
	self.value


define (Addition[#eval]).eval -> Int =
	self.left.eval + self.right.eval


------
module bar


use foo (#eval, Literal, Addition)


define #pretty =
	trait {
		(Self).pretty -> String
	}
	impl Literal
	impl Addition[#pretty]


define Negation[T] =
	struct {
		subexpr: T,
	}
	impl #tuple
	impl #eval forall T #eval
	impl #pretty forall T #pretty


define (Negation[#eval]).eval -> Int =
	- self.subexpr.eval


define (Literal).pretty -> String =
	self.eval.as-string


define (Addition[#pretty]).pretty -> String =
	"{self.left.pretty} + {self.right.pretty}"


define (Negation[#pretty]).pretty -> String =
	match self.subexpr
	case e = Literal(...) then
		"-{e.pretty}"
	else
		"- ({self.subexpr.pretty})"


------
module main

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)


define Expr =
	enum { Literal, Addition[Expr], Negation[Expr] }
	impl #eval
	impl #pretty


define main() -> Io[] =
	e1 = Expr.Addition {
		left: Expr.Literal(77),
		right: Expr.Negation(Expr.Literal(12))
	}
	Io.print("{e1.pretty} = {e1.eval}")
