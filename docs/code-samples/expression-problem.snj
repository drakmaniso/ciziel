[[ # The Expression Problem ]]


[[ ## Base Module ########################################################## ]]


module basic


def #eval {
	has .eval() -> Int
}


def Literal(
    var value: Int,
)


def Addition[A](
    var left: A,
    var right: A,
)


extend Literal as #eval {
    def .eval() -> Int {
        self.value
    }
}


forall A: #eval
extend Addition[A] as #eval {
    def .eval() -> Int {
        self.left.eval() + self.right.eval()
    }
}


[[ ## Extension Module ##################################################### ]]


module advanced


use basic { #eval, Literal, Addition }


def #pretty {
	has .pretty() -> String
}


def Negation[A](
    var subexpr: A,
)


forall A: #eval
extend Negation[A] as #eval {
    def .eval() -> Int {
        - self.subexpr.eval()
    }
}


extend Literal as #pretty {
    def .pretty() -> String {
        self.eval.to-string()
    }
}


forall A: #pretty
extend Addition[A] as #pretty {
    def .pretty() -> String {
        let l = self.left.pretty()
        let r = self.right.pretty()

        match ( self.left, self.right ) {
        case ( Literal(...), Literal(...) ):
            "{l} + {r}"
        case ( Literal(...), _ ):
            "{l} + ({r})"
        case ( _, Literal(...) ):
            "({l}) + {r}"
        case ( _, _ ):
            "({l}) + ({r})"
        }
    }
}


forall A: #pretty
extend Negation[A] as #pretty {
    def .pretty() -> String {
        self.subexpr.match {
        case e as Literal:
            "-{e.pretty}"
        case e:
            "- ({e.pretty})"
        }
    }
}


[[ ## Usage ################################################################ ]]


module main


use basic { #eval, Literal, Addition }
use advanced { #pretty, Negation }


def Expr = Literal | Addition[Expr] | Negation[Expr]
derive Expr as #eval
derive Expr as #pretty


def main() -> Io[] {
	let e1: Expr = Addition( Literal(77), Negation( Literal(12) ) )
	Io::print("{e1.pretty()} = {e1.eval()}")
}
