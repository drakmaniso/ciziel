module basic


def #eval {
	has .eval -> Int
}


def Literal {
    var .value: Int
}


for Literal: #eval {
    def .eval -> Int {
        self.value
    }
}


def Addition[A] {
    var .left: A
    var .right: A
}


for Addition[A]: #eval forall A: #eval {
    def .eval -> Int {
        self.left.eval + self.right.eval
    }
}


------
module advanced


use basic (#eval, Literal, Addition)


def #pretty {
	has .pretty -> String
}


def Negation[A] {
    var .subexpr: A
}


for Negation[A]: #eval forall A: #eval {
    def .eval -> Int {
        - self.subexpr.eval
    }
}


for Literal: #pretty {
    def .pretty -> String {
        self.eval.to-string
    }
}


for Addition[A]: #pretty forall A: #pretty {
    def pretty -> String {
        "{self.left.pretty} + {self.right.pretty}"
    }
}


for Negation[A]: #pretty forall A: #pretty {
    def .pretty -> String {
        self.subexpr.match {
            case e: Literal =>
                "-{e.pretty}"
            case e =>
                "- ({e.pretty})"
        }
    }
}


------
module main

use basic (#eval, Literal, Addition)
use advanced (#pretty, Negation)


let Expr {
    case Literal
    case Addition[Expr]
    case Negation[Expr]
}
for Expr: #eval {}
for Expr: #pretty {}


[[ Expr automatically has implementations for #eval and #pretty:

    for Expr: #eval {
        let eval() -> Int {
            match self {
            case e: Literal => e.eval()
            case e: Addition[Expr] => e.eval()
            case e: Negation[Expr] => e.eval()
            }
        }
    }
	
    for Expr: #pretty {
        let pretty() -> String {
            match self {
            case e: Literal => e.pretty()
            case e: Addition[Expr] => e.pretty()
            case e: Negation[Expr] => e.pretty()
            }
        }
    }
]]


def main(Void) -> Io[Void] {
	let e1 = Expr.Addition(
		Literal(77),
		Negation(Literal(12)),
	)
	Io.print("{e1.pretty()} = {e1.eval()}")
}