/*
# The Expression Problem
*/


/*
## Base Module ################################################################
*/
module basic


def #eval {
	has eval(self) -> Int
}


def Literal {
    var value: Int
}


def Addition[A] {
    var left: A
    var right: A
}


extend Literal as #eval {
    def eval(self) -> Int {
        self.value
    }
}


forall A: #eval
extend Addition[A] as #eval {
    def eval(self) -> Int {
        self.left.eval() + self.right.eval()
    }
}


/*
## Extension Module ###########################################################
*/
module advanced


use basic (#eval, Literal, Addition)


def #pretty {
	has pretty(self) -> String
}


def Negation[A] {
    var subexpr: A
}


forall A: #eval
extend Negation[A] as #eval {
    def eval(self) -> Int {
        - self.subexpr.eval()
    }
}


extend Literal as #pretty {
    def pretty(self) -> String {
        self.eval().to-string()
    }
}


forall A: #pretty
extend Addition[A] as #pretty {
    def pretty(self) -> String {
        l = self.left.pretty()
        r = self.right.pretty()

        match (self.left, self.right) {
        case (_ as Literal, _ as Literal):
            "{l} + {r}"
        case (_ as Literal, _):
            "{l} + ({r})"
        case (_, _ as Literal):
            "({l}) + {r}"
        case (_, _):
            "({l}) + ({r})"
        }
    }
}


forall A: #pretty
extend Negation[A] as #pretty {
    def pretty(self) -> String {
        match self.subexpr {
        case e as Literal:
            "-{e.pretty()}"
        case e:
            "- ({e.pretty()})"
        }
    }
}


/*
## Usage ######################################################################
*/
module main


use basic (#eval, Literal, Addition)
use advanced (#pretty, Negation)


def Expr = Literal | Addition[Expr] | Negation[Expr]
extend Expr as #eval
extend Expr as #pretty


def main() -> Io[] {
	let e1: Expr = Addition(Literal(77), Negation(Literal(12)))
	Io.print("{e1.pretty()} = {e1.eval()}")
}
