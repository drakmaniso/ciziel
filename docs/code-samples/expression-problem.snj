module foo


public Literal =
	struct(value: Int)


public Addition[T] =
	struct(left: T, right: T)


public #eval =
	has (Self).eval() -> Int
	implement Literal
	implement Addition[#eval]


public (Literal).eval() -> Int =
	self.value


public (Addition[#eval]).eval() -> Int =
	self.left.eval() + self.right.eval()


------
module bar


use foo (#eval, Literal, Addition)


public Negation[T] =
	struct(subexpr: T)
	implement #eval forall T #eval


public (Negation[#eval]).eval() -> Int =
	- self.subexpr.eval()


public #pretty =
	has (Self).pretty() -> String
	implement Literal
	implement Addition[#pretty]
	implement Negation[#pretty]


public (Literal).pretty() -> String =
	self.eval().to-string()


public (Addition[#pretty]).pretty() -> String =
	"{self.left.pretty()} + {self.right.pretty()}"


public (Negation[#pretty]).pretty() -> String =
	match self.subexpr
	case e: Literal then
		"-{e.pretty()}"
	case e then
		"- ({e.pretty()})"
	end


------
module main

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)


local Expr =
	enum(Literal | Addition[Expr] | Negation[Expr])
	implement #eval, #pretty


[[ Expr automatically has implementations for #eval and #pretty:

	local (Expr).eval() -> Int =	
		match self
		case e: Literal then e.eval()
		case e: Addition[Expr] then e.eval()
		case e: Negation[Expr] then e.eval()
	
	local (Expr).pretty() -> String =
		match self
		case e: Literal then e.pretty()
		case e: Addition[Expr] then e.pretty()
		case e: Negation[Expr] then e.pretty()
]]


public main() -> Io[] =
	let e1 = Expr.Addition(
		Expr.Literal(77),
		 Expr.Negation(Expr.Literal(12)),
	)
	Io.print("{e1.pretty()} = {e1.eval()}")
