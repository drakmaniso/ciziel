## The Expression Problem #####################################################


## With Generics and Unions ###################################################


module basic


def Literal = struct {
    data value: Int
}


def Addition[E] = struct {
    data left: *E
    data right: *E
}


def #eval = trait {
	has (Self).eval -> Int
}


def #eval for Literal, Addition[#eval]


def (Literal).eval -> Int {
    self.value
}


def (Addition[#eval]).eval -> Int {
    self.left.eval + self.right.eval
}


-------------------------------------------------------------------------------


module extended


use #eval, Literal, Addition from basic


def Negation[E] = struct {
    data subexpr: *E
}


def #eval for Negation[#eval]


def (Negation[#eval]).eval -> Int {
    - self.subexpr.eval
}


def #pretty = trait {
	has (Self).pretty -> String
}


def #pretty for Literal, Addition[#pretty], Negation[#pretty]


def (Literal).pretty -> String {
    self.eval.to-string
}


def (Addition[#pretty]).pretty -> String {
    let l = self.left.pretty
    let r = self.right.pretty

    match self.left, self.right {
        | Literal(...), Literal(...) => "{l} + {r}"
        | Literal(...), any => "{l} + ({r})"
        | any, Literal(...) => "({l}) + {r}"
        | any, any => "({l}) + ({r})"
    }
}


def (Negation[#pretty]).pretty -> String {
    "- ({self.subexpr.pretty})"
}


-------------------------------------------------------------------------------


module main


use Io from std
use #eval, Literal, Addition from basic
use #pretty, Negation from extended


let Expr = Literal | Addition[Expr] | Negation[Expr]


def main() -> Io[] {
	let e1: Expr = Addition(Literal(77), Negation(Literal(12)))
	Io.print("{e1.pretty} = {e1.eval}")
}


## With Extensible ADT ########################################################


module basic


def Expr = union {
    def Literal {
        data value: Int
    }

    def Addition {
        data left: *Expr
        data right: *Expr
    }

    ...
}


def #eval = trait {
	has (Self).eval -> Int
}


def #eval for Expr


def (Literal).eval -> Int {
    self.value
}


def (Addition[#eval]).eval -> Int {
    self.left.eval + self.right.eval
}


-------------------------------------------------------------------------------


module advanced


use basic (Expr, #eval)


def Expr = union {
    ...

    def Negation {
        data subexpr: *Expr
    }
}


def (Negation[#eval]).eval -> Int {
    - self.subexpr.eval
}


def #pretty = trait {
	has (Self).pretty -> String
}


def #pretty for Expr


def (Literal).pretty -> String {
    self.eval.to-string
}


def (Addition[#pretty]).pretty -> String {
    let l = self.left.pretty
    let r = self.right.pretty

    match self.left, self.right {
        | Literal(...), Literal(...) => "{l} + {r}"
        | Literal(...), any => "{l} + ({r})"
        | any, Literal(...) => "({l}) + {r}"
        | any, any => "({l}) + ({r})"
    }
}


def (Negation[#pretty]).pretty -> String {
    "- ({self.subexpr.pretty})"
}


-------------------------------------------------------------------------------


module main


use basic (#eval)
use advanced (Expr, Addition, Literal, Negation, #pretty)


def main() -> Io[] {
	let e1 = Addition(Literal(77), Negation(Literal(12)))
	Io.print("{e1.pretty} = {e1.eval}")
}
