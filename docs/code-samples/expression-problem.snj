--- The Expression Problem ----------------------------------------------------


module basic


public


Literal = struct(value: data Int)
Addition[E] = struct(left: data *E, right: data *E)


#eval =
	trait {
		(Self).eval -> Int
	}


Literal: #eval
Addition[E]: #eval forall E: #eval


(Literal).eval -> Int =
	self.value


(Addition[E]).eval -> Int
	forall E: #eval
	=
    self.left.eval + self.right.eval


module extended --- Extension -------------------------------------------------
use basic (#eval, Literal, Addition)


public


Negation[E] = struct(subexpr: *E)


Negation[E]: #eval forall E: #eval


(Negation[E]).eval -> Int
	forall E: #eval
	=
    - self.subexpr.eval


#pretty =
	trait {
		(Self).pretty -> String
	}


Literal: #pretty
Addition[E]: #pretty forall E: #pretty
Negation[E]: #pretty forall E: #pretty


(Literal).pretty -> String =
    self.eval.to-string


(Addition[E]).pretty -> String
	forall E: #eval
	=
	l = self.left.pretty
	r = self.right.pretty

	case (self.left, self.right)
	of (Literal(...), Literal(...)) then "{l} + {r}"
	of (Literal(...), _) then "{l} + ({r})"
	of (_, Literal(...)) then "({l}) + {r}"
	of (_, _) then "({l}) + ({r})"
	end


(Negation[#pretty]).pretty -> String =
    "- ({self.subexpr.pretty})"


module main --- Usage ---------------------------------------------------------
use /std/io (&io)
use basic (#eval, Literal, Addition)
use extended (#pretty, Negation)


Expr = Literal | Addition[Expr] | Negation[Expr]


main() -> Nil &io =
	do
		e1: Expr = Addition(Literal(77), Negation(Literal(12)))
		io.print("{e1.pretty} = {e1.eval}")
	end
