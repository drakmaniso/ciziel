## The Expression Problem #####################################################


## With Generics and Unions ###################################################


module basic


def Basic-Expr[E] = union {
    case Literal(data value: Int)

    case Addition(
        data left: *E,
        data right: *E,
    )
}


def #eval {
	has (Self).eval -> Int
}


def #eval for Basic-Expr[#eval]


def (Literal).eval -> Int {
    self.value
}


def (Addition[#eval]).eval -> Int {
    self.left.eval + self.right.eval
}


-------------------------------------------------------------------------------


module extended


use basic (#eval, Basic-Expr, Literal, Addition)


def Extended-Expr[E] = union {
    alias Basic-Expr[E]
    case Negation = struct { data subexpr: *E }
}


def #eval for Extended-Expr[#eval]


def (Negation[#eval]).eval -> Int {
    - self.subexpr.eval
}


def #pretty {
	has (Self).pretty -> String
}


def #pretty for Extended-Expr[#pretty]


def (Literal).pretty -> String {
    self.eval.to-string
}


def (Addition[#pretty]).pretty -> String {
    let l = self.left.pretty
    let r = self.right.pretty

    match self.left, self.right {
        case Literal(...), Literal(...) => "{l} + {r}"
        case Literal(...), any => "{l} + ({r})"
        case any, Literal(...) => "({l}) + {r}"
        case any, any => "({l}) + ({r})"
    }
}


def (Negation[#pretty]).pretty -> String {
    "- ({self.subexpr.pretty})"
}


-------------------------------------------------------------------------------


module main


use basic (#eval, Literal, Addition)
use extended (#pretty, Extended-Expr, Negation)


let Expr = alias Extended-Expr[Extended-Expr]


def main() -> Io[] {
	let e1: Expr = Addition(Literal(77), Negation(Literal(12)))
	Io.print("{e1.pretty} = {e1.eval}")
}


## With Extensible ADT ########################################################


module basic


def Expr = union {
    case Literal = struct { data value: Int }
    case Addition = struct { data left: *Expr, data right: *Expr }
    alias ...
}


def #eval = trait {
	has (Self).eval -> Int
}


def #eval for Expr


def (Literal).eval -> Int {
    self.value
}


def (Addition[#eval]).eval -> Int {
    self.left.eval + self.right.eval
}


-------------------------------------------------------------------------------


module advanced


use basic (Expr, #eval)


def Expr = union {
    alias basic::Expr
    case Negation = struct { data subexpr: *Expr }
    alias ...
}


def (Negation[#eval]).eval -> Int {
    - self.subexpr.eval
}


def #pretty = trait {
	has (Self).pretty -> String
}


def #pretty for Expr


def (Literal).pretty -> String {
    self.eval.to-string
}


def (Addition[#pretty]).pretty -> String {
    let l = self.left.pretty
    let r = self.right.pretty

    match self.left, self.right {
        case Literal(...), Literal(...) => "{l} + {r}"
        case Literal(...), any => "{l} + ({r})"
        case any, Literal(...) => "({l}) + {r}"
        case any, any => "({l}) + ({r})"
    }
}


def (Negation[#pretty]).pretty -> String {
    "- ({self.subexpr.pretty})"
}


-------------------------------------------------------------------------------


module main


use basic (#eval)
use advanced (Expr, Addition, Literal, Negation, #pretty)


def main() -> Io[] {
	let e1 = Addition(Literal(77), Negation(Literal(12)))
	Io.print("{e1.pretty} = {e1.eval}")
}
