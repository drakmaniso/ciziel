[[ # The Expression Problem ]]


[[ ## Base Module ########################################################## ]]


module basic


def #eval {
	has .eval -> Int
}


def Literal {
    var .value: Int
}


def Addition[A] { 
    var .left: A
    var .right: A
}


for Literal as #eval {
    def .eval -> Int {
        self.value
    }
}


forall A: #eval
for Addition[A] as #eval {
    def .eval -> Int {
        self.left.eval + self.right.eval
    }
}


[[ ## Extension Module ##################################################### ]]


module advanced


use basic { #eval, Literal, Addition }


def #pretty {
	has .pretty -> String
}


def Negation[A] {
    var .subexpr: A
}


forall A: #eval
for Negation[A] as #eval {
    def .eval -> Int {
        - self.subexpr.eval
    }
}


for Literal as #pretty {
    def .pretty -> String {
        self.eval.to-string
    }
}


forall A: #pretty
for Addition[A] as #pretty {
    def .pretty -> String {
        let l = self.left.pretty
        let r = self.right.pretty

        match (self.left, self.right) {
            case (Literal(...), Literal(...)) =>
                "{l} + {r}"
            case (Literal(...), _) =>
                "{l} + ({r})"
            case (_, Literal(...)) =>
                "({l}) + {r}"
            case _ =>
                "({l}) + ({r})"
        }
    }
}


forall A: #pretty
for Negation[A] as #pretty {
    def .pretty -> String {
        self.subexpr.match {
            case e: Literal =>
                "-{e.pretty}"
            case e =>
                "- ({e.pretty})"
        }
    }
}


[[ ## Usage ################################################################ ]]


module main


use basic { #eval, Literal, Addition }
use advanced { #pretty, Negation }


def Expr = Literal | Addition[Expr] | Negation[Expr]
for Expr derive #eval #pretty


def main() -> Io[] {
	let e1: Expr = Addition( Literal(77), Negation( Literal(12) ) )
	Io::print("{e1.pretty()} = {e1.eval()}")
}