--- The Expression Problem ----------------------------------------------------


module basic


public


trait #eval {
	fun (Self).eval -> Int
}


struct Literal(value: data Int)
struct Addition[E](left: data *E, right: data *E)


trait #eval for Literal
fun (Literal).eval -> Int =
	self.value


fun Addition[#eval] as #eval
fun (Addition[#eval]).eval -> Int =
    self.left.eval + self.right.eval


module extended --- Extension -------------------------------------------------


import basic (#eval, Literal, Addition)


public


struct Negation[E](subexpr: *E)


trait #eval for Negation[#eval]


fun (Negation[#eval]).eval -> Int =
    - self.subexpr.eval


trait #pretty {
	(Self).pretty -> String
}


trait #pretty for Literal
trait #pretty for Addition[#pretty]
trait #pretty for Negation[#pretty]


fun (Literal).pretty -> String =
    self.eval.to-string


fun (Addition[#pretty]).pretty -> String =
	l = self.left.pretty
	r = self.right.pretty

	case (self.left, self.right)
	of (Literal(...), Literal(...)) then "{l} + {r}"
	of (Literal(...), any) then "{l} + ({r})"
	of (any, Literal(...)) then "({l}) + {r}"
	of (any, any) then "({l}) + ({r})"
	end


fun (Negation[#pretty]).pretty -> String =
    "- ({self.subexpr.pretty})"


module main --- Usage ---------------------------------------------------------


import /std/io (&io)
import basic (#eval, Literal, Addition)
import extended (#pretty, Negation)


private


type Expr = Literal | Addition[Expr] | Negation[Expr]


fun main() -> Nil &io =
	e1: Expr = Addition(Literal(77), Negation(Literal(12)))
	io.print("{e1.pretty} = {e1.eval}")
