---- Single Dispatch ----------------------------------------------------------


module /std/ops


trait #eq {
	type Self.Eq-Right-Hand = Self
	fun (Self) == (other: Self.Eq-Right-Hand) -> Bool
}


module basic


type Basic = Foo | Bar
struct Foo
struct Bar


trait #eq for Basic
fun (Basic) == (other: Basic) -> Bool =
	case (self, other)
	of (Foo, Foo) then True
	of (Bar, Bar) then True
	of (Foo, Bar) then False
	of (Bar, Foo) then False


<< Question: do `Foo` and `Bar` implement `#eq`? This would require trait
conformance to accept widening of arguments. >>

<< Note: this approach is not extensible, since the equality trait needs a
concrete type. >>


---- Single Dispatch with Unknown type ----------------------------------------


module /std


trait #eq {
	type Self.Eq-Right-Hand = Self
	fun (Self) == (other: Self.Eq-Right-Hand) -> Bool
}


-- type Unknown = (all types)


module basic


use /std (#eq, Unknown)


public


type Basic = Foo | Bar
struct Foo
struct Bar


trait #eq for Basic


trait #eq for Foo
type Foo.Eq-Right-Hand = Unknown
fun (Foo) == (other: Unknown) -> Bool =
	case (self, other)
	of (Foo, Foo) then True
	else False


trait #eq for Bar
type Bar.Eq-Right-Hand = Unknown
fun (Bar) == (other: Unknown) -> Bool =
	case (self, other)
	of (Bar, Bar) then True
	else False


module extended


use /std (#eq, Unknown)
use basic (Basic, Foo, Bar)


type Extended = Basic | Baz
struct Baz


trait #eq for Extended


trait #eq for Baz
type Baz.Eq-Right-Hand = Unknown
fun (Baz) == (other: Unknown) -> Bool =
	case (self, other)
	of (Baz, Baz) then True
	else False


---- Double Dispatch ----------------------------------------------------------


module std


trait #eq {
    fun (Self) == (other: Self) -> Bool
}


module basic


type Basic = First | Second
struct First
struct Second


trait #eq for Basic, First, Second
fun (First) == (other: Basic) -> Bool = other is First
fun (First) == (other: Basic) -> Bool = other is Basic


-- Extension --


module extended


use basic (Basic, First, Second)


type Extended = Basic | Third
struct Third


trait #eq for Extended, Third
fun (Basic) == (other: Third) -> Bool = False
fun (Third) == (other: Extended) -> Bool = other is Third


-- Single Dispatch ------------------------------------------------------------


module basic


type Basic = Foo | Bar
struct Foo
struct Bar


trait #basic {
    fun (Self).as-basic -> Option[Basic]
}


trait #basic for Basic
fun (Foo).as-basic = Some(self)
fun (Bar).as-basic = Some(self)


trait #eq for Basic


forall A #basic
fun (Foo) == (other: A) -> Bool =
    case other.as-basic
	of Some(Foo) then True
	of Some(Bar) then False
	of None then False
	end


forall A #basic
fun (Bar) == (other: A) -> Bool =
    case other.as-basic
	of Some(Foo) then False
	of Some(Bar) then True
	of None then False
	end


-- Extension --


module extended

use basic (Basic, Foo, Bar, #basic)


type Extended = Basic | Baz
type Baz


trait #basic for Extended
fun (Baz).as-basic = None


trait #extended {
    fun (Self).as-extended -> Option[Extended]
}


trait #extended for Extended
fun (Foo).as-extended = Some(self)
fun (Bar).as-extended = Some(self)
fun (Baz).as-extended = Some(self)


trait #eq for Extended


forall A #extended
fun (Baz) == (other: A) -> Bool =
    case other.as-extended
	of Foo then False
	of Bar then False
	of Baz then True
	end
