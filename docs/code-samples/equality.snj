---- Single Dispatch ----------------------------------------------------------


module /std/ops
public


#eq =
	trait {
		Self.Eq-Right-Hand: Type = Self
		(Self) == (other: Self.Eq-Right-Hand) -> Bool
	}


module basic
public


Basic = Foo | Bar
Foo = struct
Bar = struct


Basic: #eq
(Basic) == (other: Basic) -> Bool =
	case (self, other)
	of (Foo, Foo) then True
	of (Bar, Bar) then True
	of (Foo, Bar) then False
	of (Bar, Foo) then False
	end


<< Question: do `Foo` and `Bar` implement `#eq`? This would require trait
conformance to accept widening of arguments. >>

<< Note: this approach is not extensible, since the equality trait needs a
concrete type. >>


---- Single Dispatch with Unknown type ----------------------------------------


module /std
public


#eq =
	trait {
		Self.Eq-Right-Hand: Type = Self
		(Self) == (other: Self.Eq-Right-Hand) -> Bool
	}


Unknown =
	__core__ -- (union of all types)


module basic
use /std (#eq, Unknown)
public


Basic = Foo | Bar
Foo = struct
Bar = struct


Basic: #eq


Foo: #eq
Foo.Eq-Right-Hand = Unknown
(Foo) == (other: Unknown) -> Bool =
	case (self, other)
	of (Foo, Foo) then True
	else False
	end


Bar: #eq
Bar.Eq-Right-Hand = Unknown
(Bar) == (other: Unknown) -> Bool =
	case (self, other)
	of (Bar, Bar) then True
	else False
	end


module extended
use /std (#eq, Unknown)
use basic (Basic, Foo, Bar)
public


Extended = Basic | Baz
Baz = struct


Extended: #eq


Baz: #eq
Baz.Eq-Right-Hand = Unknown
(Baz) == (other: Unknown) -> Bool =
	case (self, other)
	of (Baz, Baz) then True
	else False
	end


---- Double Dispatch ----------------------------------------------------------


module std
public


#eq =
	trait {
		(Self) == (other: Self) -> Bool
	}


module basic
public


Basic = First | Second
First = struct
Second = struct


Basic: #eq
First: #eq
Second: #eq
(First) == (other: Basic) -> Bool = other is First
(First) == (other: Basic) -> Bool = other is Basic


-- Extension --


module extended
use basic (Basic, First, Second)
public


Extended = Basic | Third
Third = struct


Extended: #eq
Third: #eq
(Basic) == (other: Third) -> Bool = False
(Third) == (other: Extended) -> Bool = other is Third


-- Single Dispatch ------------------------------------------------------------


module basic


Basic = Foo | Bar
Foo = struct
Bar = struct


#basic =
	trait {
		(Self).as-basic -> Option[Basic]
	}


Basic: #basic
(Foo).as-basic = Some(self)
(Bar).as-basic = Some(self)


Basic: #eq


(Foo) == (other: A) -> Bool
	forall A: #basic
	=
    case other.as-basic
	of Some(Foo) then True
	of Some(Bar) then False
	of None then False
	end


(Bar) == (other: A) -> Bool
	forall A: #basic
	=
    case other.as-basic
	of Some(Foo) then False
	of Some(Bar) then True
	of None then False
	end


-- Extension --


module extended
use basic (Basic, Foo, Bar, #basic)
public


Extended = Basic | Baz
Baz = struct


Extended: #basic
(Baz).as-basic = None


#extended =
	trait {
		(Self).as-extended -> Option[Extended]
	}


Extended: #extended
(Foo).as-extended = Some(self)
(Bar).as-extended = Some(self)
(Baz).as-extended = Some(self)


Extended: #eq


(Baz) == (other: A) -> Bool
	forall A: #extended
	=
    case other.as-extended
	of Foo then False
	of Bar then False
	of Baz then True
	end
