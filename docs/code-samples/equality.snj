---- Single Dispatch ----------------------------------------------------------


module /std/ops
public


trait #eq {
	type Self.Eq-RHS = Self
	fun (Self) == (other: Self.Eq-RHS) -> Bool
}


module basic
public


type Basic =
	| Foo
	| Bar
	|;


implement #eq for Basic


fun (Basic) == (other: Basic) -> Bool =
	match (self, other)
		| (Foo, Foo) -> True
		| (Bar, Bar) -> True
		| (Foo, Bar) -> False
		| (Bar, Foo) -> False
		|;


/*
Question: do `Foo` and `Bar` implement `#eq`? This would require trait
conformance to accept widening of arguments.

Note: this approach is not extensible, since the equality trait needs a
concrete type.
*/

// Single Dispatch with Unknown type //////////////////////////////////////////


module /std
public


trait #eq {
	type Self.Eq-RHS = Self
	fun (Self) == (other: Self.Eq-RHS) -> Bool
}


type Unknown =
	__core__ // (union of all types)


module basic
use /std (#eq, Unknown)
public


type Basic = Foo | Bar
struct Foo
struct Bar


tag Basic #eq


tag Foo #eq
type Foo.Eq-RHS = Unknown
fun (Foo) == (other: Unknown) -> Bool =
	case (self, other)
		of (Foo, Foo) then True
		else False
	end


tag Bar #eq
type Bar.Eq-RHS = Unknown
fun (Bar) == (other: Unknown) -> Bool =
	case (self, other)
		of (Bar, Bar) then True
		else False
	end


module extended
use /std (#eq, Unknown)
use basic (Basic, Foo, Bar)
public


type Extended = Basic | Baz
struct Baz


tag Extended #eq


tag Baz #eq
type Baz.Eq-RHS = Unknown
fun (Baz) == (other: Unknown) -> Bool =
		case (self, other)
		of (Baz, Baz) then True
		else False
	end


---- Double Dispatch ----------------------------------------------------------


module std
public


trait #eq {
	fun (Self) == (other: Self) -> Bool
}


module basic
public


type Basic = First | Second
struct First
struct Second


tag Basic #eq
tag First #eq
tag Second #eq
fun (First) == (other: Basic) -> Bool = other is First
fun (First) == (other: Basic) -> Bool = other is Basic


-- Extension --


module extended
use basic (Basic, First, Second)
public


type Extended = Basic | Third
struct Third


tag Extended #eq
tag Third #eq
fun (Basic) == (other: Third) -> Bool = False
fun (Third) == (other: Extended) -> Bool = other is Third


-- Single Dispatch ------------------------------------------------------------


module basic


type Basic = Foo | Bar
struct Foo
struct Bar


trait #basic {
	fun (Self).as-basic -> Option[Basic]
}


tag Basic #basic
fun (Foo).as-basic = Some(self)
fun (Bar).as-basic = Some(self)


tag Basic #eq


type Foo.Eq-RHS = A #basic
forall A #basic
fun (Foo) == (other: A) -> Bool =
    case other.as-basic
		of Some(Foo) then True
		of Some(Bar) then False
		of None then False
	end


type Bar.Eq-RHS = A #basic
forall A #basic
fun (Bar) == (other: A) -> Bool =
    case other.as-basic
		of Some(Foo) then False
		of Some(Bar) then True
		of None then False
	end


-- Extension --


module extended
use basic (Basic, Foo, Bar, #basic)
public


type Extended = Basic | Baz
struct Baz


tag Extended #basic
type Extended.Eq-RHS = A #basic
fun (Baz).as-basic = None


tag #extended {
	fun (Self).as-extended -> Option[Extended]
}


tag Extended #extended
fun (Foo).as-extended = Some(self)
fun (Bar).as-extended = Some(self)
fun (Baz).as-extended = Some(self)


tag Extended #eq


forall A #extended
fun (Baz) == (other: A) -> Bool =
    case other.as-extended
		of Foo then False
		of Bar then False
		of Baz then True
	end
