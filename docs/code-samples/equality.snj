module std


def #eq = trait {
    has (Self) == (other: Self) -> Bool
}


## Multiple Dispatch ##########################################################


module basic


def Basic = First | Second
def First = struct {}
def Second = struct {}


def #eq for Basic, First, Second
def (Basic) == (other: Basic) -> Bool { ... }


-------------------------------------------------------------------------------


module extended


use basic (Basic, First, Second)


def Extended = Basic | Third
def Third = struct {}


def #eq for Extended, Third
def (Basic) == (other: Third) -> Bool { ... }
def (Third) == (other: Extended) -> Bool { ... }


## Single Dispatch ############################################################


module basic


def Basic = Foo | Bar
def Foo
def Bar


def #basic = trait {
    has (Self).as-basic -> Option[Basic]
}


def #basic for Basic
def (Foo).as-basic { Some(self) }
def (Bar).as-basic { Some(self) }


def #eq for Basic


forall A #basic
def (Foo) == (other: A) -> Bool {
    match other.as-basic {
        | Some(Foo) => True
        | Some(Bar) => False
        | None => False
    }
}


forall A #basic
def (Bar) == (other: A) -> Bool {
    match other.as-basic {
        | Some(Foo) => False
        | Some(Bar) => True
        | None => False
    }
}


-------------------------------------------------------------------------------


module extended

use basic (Basic, Foo, Bar, #basic)


def Extended = Basic | Baz
def Baz = struct {}


def #basic for Extended
def (Baz).as-basic -> None { None }


def #extended = trait {
    has (Self).as-extended -> Option[Extended]
}


def #extended for Extended
def (Foo).as-extended { Some(self) }
def (Bar).as-extended { Some(self) }
def (Baz).as-extended { Some(self) }


def #eq for Extended


forall A #extended
def (Baz) == (other: A) -> Bool {
    match other.as-extended {
        | Foo => False
        | Bar => False
        | Baz => True
    }
}


## Open Unions ################################################################


module basic


def Extensible = union {
    | Foo
    | Bar
    | ...
}


def #eq for Extensible


def (Foo) == (other: Extensible) -> Bool {
    | Foo => True
    | Bar => False
    | any => False
}


def (Bar) == (other: Extensible) -> Bool {
    | Foo => True
    | Bar => False
    | any => False
}


-------------------------------------------------------------------------------


module extended


use basic { Extensible; Foo; Bar }


def Extensible = union {
    | Baz
    | ...
}


def (Baz) == (other: Extensible) -> Bool {
    match other {
        | Foo => False
        | Bar => False
        | Baz => True
        | any => False
    }
}
