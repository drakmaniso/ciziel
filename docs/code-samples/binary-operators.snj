---- With Single Dispatch and Default Implementations -------------------------


module /std/ops

public

#add =
	trait {
		Self.Add-Output: #type = Self
		Self.Add-Other: #type = Self
		Self.zero: Self
		Self.right-hand-zero: Self.Add-Other = Self.zero
		(Self).+ (other: Self.Add-Other) -> Self.Add-Output
	}

#mul =
	trait {
		Self.Mul-Output: #type = Self
		Self.Mul-Other: #type = Self
		Self.one: Self
		Self.right-hand-one: Self.Mul-Other = self.one
		(Self).* (other: Self.Mul-Other) -> Self.Mul-Output
	}

#eq =
	trait {
		Self.Eq-Other: #type = Self
		(Self).== (other: Self.Eq-Other) -> Bool
	}

module vec -- Usage
use /std/ops(#add, #mul)

public

Vec2 = struct { x: data Float, y: data Float }

Vec2: #add

Vec2.zero = Vec2(0, 0)

(Vec2).+ (other: Vec2) -> Vec2 =
    Vec2(self.x + other.x, self.y + other.y)

Vec2: #mul

Vec2.Mul-Other = Float

Vec2.Mul-Output = Vec2

(Vec2).* (other: Float) -> Vec2 =
    Vec2(self.x * other, self.y * other)


---- With Single Dispatch Only ------------------------------------------------


module std.ops

public

#add =
	trait {
		Self.zero: Self
		(Self) + (other: Self) -> Self
	}

#add-other =
	trait {
		Self.Add-Output: #type
		Self.Add-Other: #type
		Self.zero: Self
		(Self).+ (other: Self.Add-Other) -> Self.Add-Output
	}

#mul =
	trait {
		Self.one: Self
		(Self).* (other: Self) -> Self
	}

#mul-other =
	trait {
		Self.Mul-Output: #type
		Self.Mul-Other: #type
		Self.one: Self
		(Self).* (other: Self.Mul-Other) -> Self.Mul-Output
	}

#eq =
	trait {
		(Self).== (other: Self) -> Bool
	}

#eq-other =
	trait {
		Self.Eq-Other: #type
		(Self).== (other: Self.Eq-Other) -> Bool
	}


---- With Double Dispatch and Generic Traits ----------------------------------


module std.ops

public

#add =
	trait {
		Self: #add-with[Self, Self]
		Self.zero: Self
		(Self).+ (other: Self) -> Self
	}

#add-with[A, B] =
	trait {
		Self.zero: Self
		(Self).+ (other: A) -> B
		(A).+ (other: Self) -> B =
			other + self
	}

#mul =
	trait {
		Self: #mul-with[Self, Self]
		Self.one: Self
		(Self).* (other: Self) -> Self
	}

#mul-with[A, B] =
	trait {
		Self.one: Self
		(Self).* (other: A) -> B
		(A).* (other: Self) -> B =
			other * self
	}

-- Generic trait implementation?

A: #add-with[A, A]
	forall A: #add


A.Add-Output
	forall A: #add
	=
	A


module vec -- Usage
use /std/ops(#add, #mul)

public

Vec2 =
	struct {
		data x: Float,
		data y: Float,
	}

Vec2: #add

Vec2.zero = Vec2(0, 0)

(Vec2).+ (other: Vec2) -> Vec2 =
    Vec2(self.x + other.x, self.y + other.y)

Vec2: #mul-with[Float]

Vec2.Mul-Output = Vec2

(Vec2).* (other: Float) -> Vec2 =
    Vec2(self.x * other, self.y * other)

(Float).* (other: Vec2) -> Vec2 =
    Vec2(self * other.x, self * other.y)


---- With Double Dispatch and Default Arguments -------------------------------


module /std/ops

public

#add[A = Self, B = Self] =
	trait {
		Self.zero: Self
		Self.right-hand-zero: A = Self.zero
		(Self).+ (other: A) -> B
		(A).+ (other: Self) -> B =
			other + self
	}

#mul[A = Self, B = Self] =
	trait {
		Self.one: Self
		Self.right-hand-one: A = self.one
		(Self).* (other: A) -> B
		(A).* (other: Self) -> B =
			other * self
	}

#eq[A = Self] =
	trait {
		(Self).== (other: A) -> Bool
		(A).== (other: Self) -> Bool =
			other == self
	}
