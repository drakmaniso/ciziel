module std::ops


def #add {
    has ::Other
    has ::Output
    has + (right: Self::Other) -> Self::Output
    has ::+ (left: Self::Other, right: Self) -> Self::Output
}


def #add-with-zero {
    has #add
    has #add::Other == Self
    has #add::Output == Self
    has ::zero: Self
}


def #mul {
    has ::Other
    has ::Output
    has * (right: Self::Other) -> Self::Output
    has ::* (left: Self::OTher, right: Self) -> Self::Output
}


def #mul-with-one {
    has #mul
    has #mul::Other == Self
    has #mul::Output == Self
    has Self::one: Self
}


-------------------------------------------------------------------------------


module vec


use std::ops (#add, #mul)


def Vec2(var x: Float, var y: Float)


extend Vec2 as #add {
    def ::Other = Vec2

    def ::Output = Vec2

    def + (right: Vec2) -> Vec2 {
        Vec2(self.x + other.x, self.y + other.y)
    }
}


extend Vec2 as #zero {
    def ::zero = Vec2(0, 0)
}


extend Vec2 as #mul {
    def ::Other = Float

    def ::Output = Vec2

    def * (right: Float) -> Vec2 {
        Vec2(self.x * other, self.y * other)
    }

    def ::* (left: Float, right: Vec2) -> Vec2 {
        Vec2(left * right.x, left * right.y)
    }
}
