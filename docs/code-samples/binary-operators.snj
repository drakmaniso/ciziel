module std::ops


def #add {
    has ::Other
    has ::Output
    has + (other: Self::Other) -> Self::Output
    extend Self::Other {
        has + (other: Self) -> Self::Output
    }
}


def #add-with-zero {
    has #add
    has #add::Other == Self
    has #add::Output == Self
    has ::zero: Self
}


def #mul {
    has ::Other
    has ::Output
    has * (other: Self::Other) -> Self::Output
    extend Self::Other {
        has * (other: Self) -> Self::Output
    }
}


def #mul-with-one {
    has #mul
    has #mul::Other == Self
    has #mul::Output == Self
    has Self::one: Self
}


-------------------------------------------------------------------------------


module vec


use std::ops (#add, #mul)


def Vec2(var x: Float, var y: Float)


for Vec2 as #add {
    def ::Other = Vec2

    def ::Output = Vec2

    def + (other: Vec2) -> Vec2 {
        Vec2(self.x + other.x, self.y + other.y)
    }
}


for Vec2 as #zero {
    def ::zero = Vec2(0, 0)
}


for Vec2 as #mul {
    def ::Other = Float

    def ::Output = Vec2

    def * (other: Float) -> Vec2 {
        Vec2(self.x * other, self.y * other)
    }

    for Float {
        def * (other: Vec2) -> Vec2 {
            Vec2(self * other.x, self * other.y)
        }
    }
}
