module std.ops


def #add {
    has zero: Self
    has +(left: Self, right: Self) -> Self
}


def #add-with[A] {
    has Output
    has zero: Self
    has +(left: Self, right: A) -> Self.Output
    has +(left: A, right: Self) -> Self.Output
}


def #mul {
    has one: Self
    has *(left: Self, right: Self) -> Self
}


def #mul-with[Other] {
    has Output
    has *(left: Self, right: Other) -> Self.Output
    has *(left: Other, right: Self) -> Self.Output
}


forall A: #add-with[A]
extend A as #add {
    def Output = A#add-with[A].Output
    def zero = A#add-with[A].zero
    def +(left: A, right: A) -> A.Output {
        left' = left#add-with[A]
        left' + right
    }
}


///////////////////////////////////////////////////////////////////////////////


module vec


use std::ops (#add, #mul)


def Vec2 {
    var x: Float
    var y: Float
}


extend Vec2 as #add {
    def zero = Vec2(0, 0)

    def +(left: Vec2, right: Vec2) -> Vec2 {
        Vec2(left.x + right.x, right.y + right.y)
    }
}


extend Vec2 as #mul-with[Float] {
    def Output = Vec2

    def *(left: Vec2, right: Float) -> Vec2 {
        Vec2(self.x * right, self.y * right)
    }

    def *(left: Float, right: Vec2) -> Vec2 {
        Vec2(left * right.x, left * right.y)
    }
}
