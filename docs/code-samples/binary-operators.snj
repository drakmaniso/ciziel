---- With Single Dispatch and Default Implementations -------------------------


module /std/ops
public


trait #add {
	type Self.Add-Output = Self
	type Self.Add-Right-Hand = Self
	val Self.zero: Self
	val Self.right-hand-zero: Self.Add-Right-Hand = Self.zero
	fun (Self) + (other: Self.Add-Right-Hand) -> Self.Add-Output
}


trait #mul {
	type Self.Mul-Output = Self
	type Self.Mul-Right-Hand = Self
	val Self.one: Self
	val Self.right-hand-one: Self.Mul-Right-Hand = self.one
	fun (Self) * (other: Self.Mul-Right-Hand) -> Self.Mul-Output
}


trait #eq {
	type Self.Eq-Right-Hand = Self
	fun (Self) == (other: Self.Eq-Right-Hand) -> Bool
}


---- With Single Dispatch Only ------------------------------------------------


module std.ops
public


trait #add {
	val Self.zero: Self
	fun (Self) + (other: Self) -> Self
}


trait #add-other {
	type Self.Add-Output
	type Self.Add-Other
	val Self.zero: Self
	fun (Self) + (other: Self.Add-Other) -> Self.Add-Output
}


trait #mul {
	val Self.one: Self
	fun (Self) * (other: Self) -> Self
}


trait #mul-other {
	type Self.Mul-Output
	type Self.Mul-Other
	val Self.one: Self
	fun (Self) * (other: Self.Mul-Other) -> Self.Mul-Output
}


trait #eq {
	fun (Self) == (other: Self) -> Bool
}


trait #eq-other {
	type Self.Eq-Other
	fun (Self) == (other: Self.Eq-Other) -> Bool
}


---- With Double Dispatch -----------------------------------------------------


module std.ops
public


trait #add {
	val Self.zero: Self
	fun (Self) + (other: Self) -> Self
}


trait #add-with[A] {
	type Self.Add-Output
	val Self.zero: Self
	fun (Self) + (other: A) -> Self.Add-Output
	fun (A) + (other: Self) -> Self.Add-Output
}


trait #mul {
	val Self.one: Self
	fun (Self) * (other: Self) -> Self
}


trait #mul-with[A] {
	type Self.Mul-Output
	val Self.one: Self
	fun (Self) * (other: A) -> Self.Mul-Output
	fun (A) * (other: Self) -> Self.Mul-Output
}


-------------------------------------------------------------------------------


<< Generic trait implementation? >>


trait #add-with[A] for A #add


type A.Add-Output forall A #add = A



-------------------------------------------------------------------------------


module vec
import /std/ops(#add, #mul)
public


struct Vec2 {
	data x: Float,
	data y: Float,
}


trait #add for Vec2


val Vec2.zero = Vec2(0, 0)


fun (Vec2) + (other: Vec2) -> Vec2 =
    Vec2(self.x + other.x, self.y + other.y)


trait #mul-with[Float] for Vec2


type Vec2.Mul-Output = Vec2


fun (Vec2) * (other: Float) -> Vec2 =
    Vec2(self.x * other, self.y * other)


fun (Float) * (other: Vec2) -> Vec2 =
    Vec2(self * other.x, self * other.y)
