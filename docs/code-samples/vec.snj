module vec


[[ ## Traits ############################################################### ]]


def #vector {
    has ::Scalar: #num #vector-scalar[Vector = Self]
    has ::zero: Self
    has .length -> Self::Scalar
    has .normalize -> Self
    has + (other: Self) -> Self
    has - (other: Self) -> Self
    has * (scalar: Self::Scalar) -> Self
    has ::* (scalar: Self::Scalar, self: Self) -> Self
}


def #vec2 {
    has #vector
    has ::Scalar: #num
    has Self(x: Self::Scalar, y: Self::Scalar)
}


def #vec3 {
    has #vector
    has ::Scalar: #num
    has Self(
        x: Self::Scalar,
        y: Self::Scalar,
        z: Self::Scalar,
    )
}


[[ ## Automatic Extensions ################################################# ]]


forall V: #vec2
extend V as #vector {
    def ::Scalar = V#vec2::Scalar

    def ::zero: V {
        V(x = V::Scalar::zero, y = V::Scalar::zero)
    }
        
    def .length -> V::Scalar {
        math::sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def .normalize -> V {
        let l = self.length
        V(x = self.x / l, y = self.y / l)
    }

    def + (other: V) -> V {
        V(x = self.x + other.x, y = self.y + other.y)
    }

    def - (other: V) -> V {
        V(x = self.x - other.x, y = self.y - other.y)
    }

    def * (scalar: V::Scalar) -> V {
        V(x = self.x * scalar, y = self.y * scalar)
    }

    def ::* (scalar: V::Scalar, self: V) -> V {
        V(x = self.x * scalar, y = self.y * scalar)
    }
}


[[ ## Concrete Types ####################################################### ]]


def Vec2 = struct(
    var x: Float32,
    var y: Float32,
)


extend Vec2 as #vec2 {
    def ::Scalar = Float32
}


derive Vec2 as #vector


[[ Or, without using the automatic derivation: ]]


def IVec2 = struct(
    var x: Int32,
    var y: Int32,
)


extend IVec2 as #vec2 {
    def ::Scalar = Int32
}


extend IVec2 as #vector {
    def ::Scalar = Int32

    def ::zero = Vec2(0, 0)

    def .length -> Int32 {
        math::sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def .normalize -> Vec2 {
        let l = self.length
        Self(x = self.x / l, y = self.y / l)
    }

    def + (other: Vec2) -> Vec2 {
        Vec2(x = self.x + other.x, y = self.y + other.y)
    }

    def - (other: Vec2) -> Vec2 {
        Vec2(x = self.x - other.x, y = self.y - other.y)
    }

    def * (scalar: Int32) -> Vec2 {
        Vec2(x = self.x * scalar, y = self.y * scalar)
    }

    def * (scalar: Int32, self: Vec2) -> Vec2 {
        Vec2(x = self.x * scalar, y = self.y * scalar)
    }
}
