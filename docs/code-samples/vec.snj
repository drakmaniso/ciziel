module vec


public #vector =
    has Self.Scalar #num
    has Self.zero: Self
    has (Self).length -> Self.Scalar
    has (Self).normalize -> Self
    has (Self) + (other: Self) -> Self
    has (Self) - (other: Self) -> Self
    has (Self) * (other: Self.Scalar) -> Self
    -- If operators have double dispatch:
    has (Self.Scalar) * (other: Self) -> Self


public #vec2 =
    has Self {
        x: Self.Scalar,
        y: Self.Scalar,
    }

    has #vector

    has Self.zero: Self =
        Self { x = Self.Scalar.zero, y = Self.Scalar.zero }
        
    has (Self).length -> Self.Scalar =
        ((self.x ^ 2) + (self.y ^ 2)).square-root


    has (Self).normalize -> Self =
        let l = self.length
        Self { x = self.x / l, y = self.y / l }


    has (Self) + (other: Self) -> Self =
        Self { x = self.x + other.x, y = self.y + other.y }


    has (Self) - (other: Self) -> Self =
        Self { x = self.x - other.x, y = self.y - other.y }


    has (Self) * (scalar: Self.Scalar) -> Self =
        Self { x = self.x * scalar, y = self.y * scalar }
    
    -- If operators have double dispatch:
    has (Self.Scalar) * (other: Self) -> Self =
        self * other


public #vec3 =
    has Self {
        x: Self.Scalar,
        y: Self.Scalar,
        z: Self.Scalar,
    }

    has #vector

    ...


-- Concrete Types -------------------------------------------------------------


public Vec2 =
    struct {
        x: Float32
        y: Float32
    }
    has #vec2

public Vec2.Scalar = Float32

public Vec2.zero = Vec2(0, 0)

public (Vec2).length -> Float32 = vec2-length(self)

public (Vec2).normalize -> Vec2 = vec2-normalize(self)

public (Vec2) + (other: Vec2) -> Vec2 =
    Vec2 { x = self.x + other.x, y = self.y + other.y }

public (Vec2) - (other: Vec2) -> Vec2 =
    Vec2 { x = self.x - other.x, y = self.y - other.y }

public (Vec2) * (other: Float32) -> Vec2 =
    Vec2 { x = self.x * other, y = self.y * other }

-- If operators have double-dispatch:
public (Float32) * (other: Vec2) -> Vec2 =
    other * self


public IVec2 =
    struct {
        x: Int32
        y: Int32
    }
    has #vec2

public IVec2.Scalar = Int32

public IVec2.zero = IVec2(0, 0)

public (IVec2).length -> Int32 = length(self)

public (IVec2).normalize -> IVec2 = normalize(self)

public (IVec2) + (other: IVec2) -> IVec2 =
    IVec2(x: self.x + other.x, y: self.y + other.y)

public (IVec2) - (other: IVec2) -> IVec2 =
    IVec2(x: self.x - other.x, y: self.y - other.y)

public (IVec2) * (other: Int32) -> IVec2 =
    IVec2(x: self.x * other, y: self.y * other)

-- If operators have double-dispatch:
public (Int32) * (other: IVec2) -> IVec2 =
    other * self
