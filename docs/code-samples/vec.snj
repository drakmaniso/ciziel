module vec


def #vector {
    has ::Scalar: #num
    has ::zero: Self
    has .length -> Self::Scalar
    has .normalize -> Self
    has + (other: Self) -> Self
    has - (other: Self) -> Self
    has * (other: Self::Scalar) -> Self
}


def #vec2 {
    has ::Scalar: #num
    has Self(x: Self::Scalar, y: Self::Scalar)
    has #vector
}


derive A as #vector forall A: #vec2 {
    def ::Scalar = Self#vec2::Scalar

    def ::zero: Self {
        Self(x = Self::Scalar::zero, y = Self::Scalar::zero)
    }
        
    def .length -> Self::Scalar {
        math::sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def .normalize -> Self {
        let l = self.length
        Self(x = self.x / l, y = self.y / l)
    }

    def + (other: Self) -> Self {
        Self(x = self.x + other.x, y = self.y + other.y)
    }

    def - (other: Self) -> Self {
        Self(x = self.x - other.x, y = self.y - other.y)
    }

    def * (scalar: Self::Scalar) -> Self {
        Self(x = self.x * scalar, y = self.y * scalar)
    }
}


def #vec3 {
    has ::Scalar: #num
    has Self(
        x: Self::Scalar,
        y: Self::Scalar,
        z: Self::Scalar,
    )

    for Self: #vector {
        ...
    }
}


[[ ## Concrete Types ####################################################### ]]


def Vec2 = struct(
    var x: Float32,
    var y: Float32,
)


for Vec2 as #vec2 {
    def ::Scalar = Float32
}


for Vec2 derive #vector


for Float32 {
    def * (other: Vec2) -> Vec2 {
        other * self
    }
}


[[ Or, without using the derivation: ]]


def IVec2 = struct(
    var x: Int32,
    var y: Int32,
)


for IVec2 as #vec2 {
    def ::Scalar = Int32
}


for IVec2 as #vector {
    def ::Scalar = Int32

    def ::zero = Vec2(0, 0)

    def .length -> Int32 {
        math::sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def .normalize -> Vec2 {
        let l = self.length
        Self(x = self.x / l, y = self.y / l)
    }

    def + (other: Vec2) -> Vec2 {
        Vec2(x = self.x + other.x, y = self.y + other.y)
    }

    def - (other: Vec2) -> Vec2 {
        Vec2(x = self.x - other.x, y = self.y - other.y)
    }

    def * (other: Int32) -> Vec2 {
        Vec2(x = self.x * other, y = self.y * other)
    }
}


for Int32 {
    def * (other: IVec2) -> IVec2 {
        other * self
    }
}
