/*
# Vectors
*/
module vec


/*
## Traits ##################################################################
*/


def #vector {
    has Self.Scalar: #num
    has Self.zero: Self
    has length -> Self.Scalar
    has normalized -> Self
    has (other: Self) -> Self
    has - (other: Self) -> Self
    has * (scalar: Self.Scalar) -> Self
    has Self.* (scalar: Self.Scalar, self: Self) -> Self
}


def #vec2 {
    has #vector
    has Self.Scalar: #num
    has Self(x: Self.Scalar, y: Self.Scalar)
    has x: Self.Scalar
    has y: Self.Scalar
}


def #vec3 {
    has #vector
    has Self.Scalar: #num
    has Self(x: Self.Scalar, y: Self.Scalar, z: Self.Scalar)
    has x: Self.Scalar
    has y: Self.Scalar
    has z: Self.Scalar
}


/*
## Automatic Extensions ####################################################
*/


forall V: #vec2
extend V as #vector {
    def Self.Scalar = V#vec2.Scalar

    def Self.zero: V {
        V(x: V.Scalar.zero, y: V.Scalar.zero)
    }

    def length -> V.Scalar {
        math.sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def normalized -> V {
        l = self.length
        V(x: self.x / l, y: self.y / l)
    }

    def + (other: V) -> V {
        V(x: self.x + other.x, y: self.y + other.y)
    }

    def - (other: V) -> V {
        V(x: self.x - other.x, y: self.y - other.y)
    }

    def * (scalar: V.Scalar) -> V {
        V(x: self.x * scalar, y: self.y * scalar)
    }

    def Self.* (scalar: V.Scalar, self: V) -> V {
        V(x: self.x * scalar, y: self.y * scalar)
    }
}


/*
## Concrete Types ##########################################################
*/


/*
Implement Vec2 using the automatic extension:
*/


def Vec2 {
    var x: Float32
    var y: Float32
}


extend Vec2 as #vec2 {
    def Vec2.Scalar = Float32
}


extend Vec2 as #vector


/*
Implement IVec2 *without* the automatic extension:
*/


def IVec2 {
    var x: Int32
    var y: Int32
}


extend IVec2 as #vec2 {
    def Self.Scalar = Int32
}


extend IVec2 as #vector {
    def IVec2.Scalar = Int32

    def IVec2.zero = Vec2(0, 0)

    def length -> Int32 {
        math.sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def normalized -> Vec2 {
        l = self.length
        Self(x: self.x / l, y: self.y / l)
    }

    def + (other: Vec2) -> Vec2 {
        Vec2(x: self.x + other.x, y: self.y + other.y)
    }

    def - (other: Vec2) -> Vec2 {
        Vec2(x: self.x - other.x, y: self.y - other.y)
    }

    def * (scalar: Int32) -> Vec2 {
        Vec2(x: self.x * scalar, y: self.y * scalar)
    }

    def Self.* (scalar: Int32, self: Vec2) -> Vec2 {
        Vec2(x: scalar * self.x, y: scalar * self.y)
    }
}
