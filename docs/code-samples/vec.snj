module vec


define #vector =
    trait {
        has Self.Scalar #num
        has Self.zero: Self
        has (Self).length -> Self.Scalar
        has (Self).normalize -> Self
        has (Self) + (other: Self) -> Self
        has (Self) - (other: Self) -> Self
        has (Self) * (other: Self.Scalar) -> Self
        -- If operators have double dispatch:
        has (Self.Scalar) * (other: Self) -> Self
    }


define #vec2 =
    trait {
        has #vector

        has struct {
            x: Self.Scalar,
            y: Self.Scalar,
        }

        define Self.zero: Self =
            Self { x = Self.Scalar.zero, y = Self.Scalar.zero }
            
        define (Self).length -> Self.Scalar =
            ((self.x ^ 2) + (self.y ^ 2)).square-root


        define (Self).normalize -> Self =
            let l = self.length
            Self { x = self.x / l, y = self.y / l }


        define (Self) + (other: Self) -> Self =
            Self { x = self.x + other.x, y = self.y + other.y }


        define (Self) - (other: Self) -> Self =
            Self { x = self.x - other.x, y = self.y - other.y }


        define (Self) * (scalar: Self.Scalar) -> Self =
            Self { x = self.x * scalar, y = self.y * scalar }
        
        -- If operators have double dispatch:
        define (Self.Scalar) * (other: Self) -> Self =
            self * other
    }    


define #vec3 =
    trait {
        has #vector

        has struct {
            x: Self.Scalar,
            y: Self.Scalar,
            z: Self.Scalar,
        }

        ...
    }


-- Concrete Types -------------------------------------------------------------


define Vec2 =
    struct {
        x: Float32
        y: Float32
        has #vec2
    }

define Vec2.Scalar = Float32

define Vec2.zero = Vec2(0, 0)

define (Vec2).length -> Float32 = vec2-length(self)

define (Vec2).normalize -> Vec2 = vec2-normalize(self)

define (Vec2) + (other: Vec2) -> Vec2 =
    Vec2 { x = self.x + other.x, y = self.y + other.y }

define (Vec2) - (other: Vec2) -> Vec2 =
    Vec2 { x = self.x - other.x, y = self.y - other.y }

define (Vec2) * (other: Float32) -> Vec2 =
    Vec2 { x = self.x * other, y = self.y * other }

-- If operators have double-dispatch:
define (Float32) * (other: Vec2) -> Vec2 =
    other * self


define IVec2 =
    struct {
        x: Int32
        y: Int32
        has #vec2
    }

define IVec2.Scalar = Int32

define IVec2.zero = IVec2(0, 0)

define (IVec2).length -> Int32 = length(self)

define (IVec2).normalize -> IVec2 = normalize(self)

define (IVec2) + (other: IVec2) -> IVec2 =
    IVec2(x: self.x + other.x, y: self.y + other.y)

define (IVec2) - (other: IVec2) -> IVec2 =
    IVec2(x: self.x - other.x, y: self.y - other.y)

define (IVec2) * (other: Int32) -> IVec2 =
    IVec2(x: self.x * other, y: self.y * other)

-- If operators have double-dispatch:
define (Int32) * (other: IVec2) -> IVec2 =
    other * self
