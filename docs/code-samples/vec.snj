module vec


def #vector {
    has ::Scalar: #num
    has ::zero: Self
    has .length -> Self::Scalar
    has .normalize -> Self
    has + (other: Self) -> Self
    has - (other: Self) -> Self
    has * (other: Self::Scalar) -> Self
    -- If operators have double dispatch:
    has (other: Self::Scalar) * self -> Self
}


def #vec2 {
    has ::Scalar: #num
    has Self(x: Self::Scalar, y: Self::Scalar)

    for Self: #vector {
        def ::Scalar = Self#vec2::Scalar

        def ::zero: Self {
            Self(x = Self::Scalar::zero, y = Self::Scalar::zero)
        }
            
        def .length -> Self::Scalar {
            math::sqrt((self.x ^ 2) + (self.y ^ 2))
        }

        def .normalize -> Self {
            let l = self.length
            Self(x = self.x / l, y = self.y / l)
        }

        def + (other: Self) -> Self {
            Self(x = self.x + other.x, y = self.y + other.y)
        }

        def - (other: Self) -> Self {
            Self(x = self.x - other.x, y = self.y - other.y)
        }

        def * (scalar: Self::Scalar) -> Self {
            Self(x = self.x * scalar, y = self.y * scalar)
        }

        -- If operators have double dispatch:
        def (other: Self::Scalar) * self -> Self {
            self * other
        }
    }
}


def #vec3 {
    has ::Scalar: #num
    has Self(
        x: Self::Scalar,
        y: Self::Scalar,
        z: Self::Scalar,
    )

    for Self: #vector {
        ...
    }
}


-- Concrete Types -------------------------------------------------------------


def Vec2 {
    var x: Float32
    var y: Float32
}


for Vec2: #vec2 {
    def ::Scalar = Float32
}


for Vec2: #vector {
    def ::Scalar = Float32

    def ::zero = Vec2(0, 0)

    def .length -> Float32 {
        math::sqrt((self.x ^ 2) + (self.y ^ 2))
    }

    def .normalize -> Vec2 {
        let l = self.length
        Self(x = self.x / l, y = self.y / l)
    }

    def + (other: Vec2) -> Vec2 {
        Vec2(x = self.x + other.x, y = self.y + other.y)
    }

    def - (other: Vec2) -> Vec2 {
        Vec2(x = self.x - other.x, y = self.y - other.y)
    }

    def * (other: Float32) -> Vec2 {
        Vec2(x = self.x * other, y = self.y * other)
    }

    -- If operators have double-dispatch:
    def (other: Float32) * self -> Vec2 {
        self * other
    }
}

-- or simply:

def IVec2 {
    var x: Int32
    var y: Int32
}

for IVec2: #vec2 #vector {
    def ::Scalar = Int32
}


def UVec2 = struct(var x: UInt64, var y: UInt64)


struct DVec2(x: Float64, y: Float64)

for DVec2 {
    def DVec2(x, y)
}
