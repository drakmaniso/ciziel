/*
# Encapsulation
*/


/*
## Structs ####################################################################
*/


/*
### Private Structs
*/


let Private {
    let foo: Int
    let bar: Bool
}


/*
### Opaque Structs
*/


def Opaque {
    let foo: Int
    let bar: Bool
}


/*
### Read-Only Structs
*/


def Read-Only {
    def foo: Int
    def bar: Int
}


/*
### Transparent Structs
*/


def Transparent {
    var foo: Int
    var bar: Bool
}


/*
### Translucent Structs
*/
def Translucent {
    let opaque: Int
    def read-only: Bool
    var transparent: String
}


/*
### Proxy Structs
*/


def Proxy {
    let underlying: Int | Float

    def Proxy(foo: String) {
        n = (foo <to> Option[Int])
            .or-else(___ <to> Option[Float])
            .with-default(0 as Int)
        Proxy(underlying: n)
    }

    def foo() -> String {
        underlying <to> String
    }

    def bar() -> Bool {
        match self.underlying {
        case n as Int:
            n.is-even()
        case _:
            False
        }
    }
}


/*
## Unions #####################################################################
*/


let Private-Foo
let Private-Bar
def Public-Foo
def Public-Bar


/*
### Private Unions
*/


let Private = Private-Foo | Private-Bar


/*
### Opaque Unions
*/


def Opaque = Private-Foo | Private-Bar


/*
### Translucent Unions
*/


def Translucent = Public-Foo | Private-Bar


/*
### Transparent Unions
*/


def Transparent = Public-Foo | Public-Bar


/*
NOTE: Because unions are structural, it's impossible to create an opaque union of
public types.
*/


/*
## Traits #####################################################################
*/


/*
### Private Traits
*/


let #private {
    has foo() -> Int
    has bar(arg: Bool) -> String
}


/*
### Public Traits
*/


def #transparent {
    has foo() -> Int
    has bar(arg: Bool) -> String
}


/*
### Opaque Traits
*/


def #opaque {
    has #private
}

let #private {
    has foo() -> Int
    has bar(arg: Bool) -> String
}    
