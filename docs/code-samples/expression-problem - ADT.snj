<< The Expression Problem >>


module basic
public


type Expr[E] =
	| Literal(value: data Int)
	| Addition(left: data *E, right: data *E)


trait #eval {
	fun (Self).eval -> Int
}


forall E #eval
extend Expr[E] as #eval


forall E #eval
fun (Expr[E]).eval -> Int =
	case self
		of Expr.Literal(value) then
			value
		of Expr.Addition(left, right) then
			left.eval + right.eval
	end


-------------------------------------------------------------------------------
module extended
use basic (#eval)
public


type Expr[E] =
	| as basic::Expr[E].Literal
	| as basic::Expr[E].Addition
	| Negation(subexpr: data *E)


forall E #eval
extend Expr[E] as #eval


forall E #eval
fun (Expr[E]).eval -> Int =
	case self
		of Expr.Negation(subexpr) then - subexpr.eval
		of e: basic::Expr[E] then e.eval
	end


trait #pretty {
	fun (Self).pretty -> String
}


forall E #pretty
extend basic::Expr[E] as #pretty


forall E #pretty
fun (basic::Expr[E]).pretty -> String =
	case self
		of basic::Expr.Literal(value) then value.to-String
		of basic::Expr.Addition(left, right) then
			l = self.left.pretty
			r = self.right.pretty

			case (self.left, self.right)
				of (Expr.Literal(...), Expr.Literal(...)) then "{l} + {r}"
				of (Expr.Literal(...), _) then "{l} + ({r})"
				of (_, Literal(...)) then "({l}) + {r}"
				of (_, _) then "({l}) + ({r})"
			end
	end


forall E #pretty
extend Expr[E] as #pretty


forall E #pretty
fun (Expr[E]).pretty -> String =
	case self
		of Expr.Negation(subexpr) then
			"- ({subexpr.pretty})"
		of e: basic::Expr[E] then
			e.pretty
	end


-------------------------------------------------------------------------------
module main
use /std/io (&io)
use basic (#eval)
use extended (#pretty)
public


alias Expr = extended::Expr[Expr]
-- Or:
type Expr = as extended::Expr[Expr]
auto extend Expr as #eval
auto extend Expr as #pretty


fun main() -> Void &io =
	do
		e1 = Expr.Addition(Expr.Literal(77), Expr.Negation(Expr.Literal(12)))
		print("{e1.pretty} = {e1.eval}")
	end
