module basic


pub trait #eval {
	has .eval -> Int
}


pub struct Literal(
    var value: Int,
)


pub struct Addition[A](
    var left: A,
    var right: A,
)


for Literal trait #eval {
    pub fun .eval -> Int {
        self.value
    }
}


for Addition[A] trait #eval forall A: #eval {
    pub fun .eval -> Int {
        self.left.eval + self.right.eval
    }
}


------
module advanced


use basic { #eval, Literal, Addition }


pub trait #pretty {
	has .pretty -> String
}


pub struct Negation[A](
    var subexpr: A,
)


for Negation[A] trait #eval forall A: #eval {
    pub fun .eval -> Int {
        - self.subexpr.eval
    }
}


for Literal trait #pretty {
    def .pretty -> String {
        self.eval.to-string
    }
}


for Addition[A] trait #pretty forall A: #pretty {
    def .pretty -> String {
        let l = self.left.pretty
        let r = self.right.pretty

        match (self.left, self.right) {
            case (Literal(...), Literal(...)) =>
                "{l} + {r}"
            case (Literal(...), _) =>
                "{l} + ({r})"
            case (_, Literal(...)) =>
                "({l}) + {r}"
            case _ =>
                "({l}) + ({r})"
        }
    }
}


for Negation[A] trait #pretty forall A: #pretty {
    def .pretty -> String {
        self.subexpr.match {
            case e: Literal =>
                "-{e.pretty}"
            case e =>
                "- ({e.pretty})"
        }
    }
}


------
module main

use basic { #eval, Literal, Addition }
use advanced { #pretty, Negation }


def Expr = Literal | Addition[Expr] | Negation[Expr]
for Expr derive #eval #pretty


def main() -> Io[] {
	let e1: Expr = Addition( Literal(77), Negation( Literal(12) ) )
	Io::print("{e1.pretty()} = {e1.eval()}")
}