module main

use std'io (Io)


func main() -> Io[()] =
	do number = get-number()
	naive = naive-factorial(number)
	tail = tail-factorial(number)
	folded = folded-factorial(number)

	do Io'print("naive factorial: {naive}")
	do Io'print("tail recursice factorial: {tail}")
	do Io'print("fold-based factorial: {folded}")
	Io'wrap(())

	where
		get-number() -> Io[Int] =
			do Io'put-string("Please enter a number: ")
			do answer = Io'input
			match answer.to-int
			case Some n then Io'wrap(n)
			else get-number()


func main(io: Io) -> Io =
	(io, number) := get-number(io)
	naive = naive-factorial(answer)
	tail = tail-factorial(answer)
	folded = folded-factorial(answer)

	io.print("naive factorial: {naive}")
		.print("tail recursice factorial: {tail}")
		.print("fold-based factorial: {folded}")

	where
		get-number(io) =
			(io, answer) :=
				io.put-string("Please enter a number: ")
					.input
			match answer.to-int
			case Some n then (io, n)
			else get-number(io)


func naive-factorial(n) =
	if n <= 1 then 1
	else n * naive-factorial(n - 1)


func tail-factorial(n: Int) -> Int =
	step(n, 1)
	where
		step(n, accum) =
			if n <= 1 then accum
			else step(n - 1, n * accum)


func fold-factorial(n: Int) -> Int =
	(2 `upto` n).fold(1, => ___ * ___)


forall N #num #copy
func generic-tail-factorial(number: N) -> N =
	step(number, N.one)
	where
		step(num, accum) =
			if num <= N.one then accum
			else step(num - N.one, num * accum)


forall N #num #range #copy
func generic-fold-factorial(number: N) -> N =
	(N.one `upto` number).fold(
		N.one,
		=> ___ * ___
	)


func gcd(n: Int, m: Int) -> Int =
	require n > 0
	require m > 0
	ensure result > 0

	(a, b) = (max(n, m), min(n, m))
	if b == 0 then a
	else gcd(b, a % b)

	
func fibonacci(n: Int) -> Int =
	require n > 0
	ensure result > 0
	step(n, 1, 1)
	where
		step(n, previous, current) =
			if n = 0 then current
			else step(n - 1, current, previous + current)


func pipeline-example() =
	my-array = [1, 2, 3, 4, 5, 6, 7]
	my-array
		.filter(=> ___ `mod` 2 == 0)
		.map(=> ___ * 2)
		.fold("", \str \num =>
			str ++ num.to-string
		)
		.map(\rune =>
			if rune.is-letter then
				rune.to-upper
			else
				"?".to-rune
		)
