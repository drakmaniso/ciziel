module main

use std::io { Io }


def main() -> Io[] {
	let get-number() {
		Io::put-string("Please enter a number: ")
		let? answer = Io::input()
		match answer.to-int() {
		case Some(n):
			Io(n)
		case None:
			get-number()
		}
    }

	let? number = get-number()
	let naive = naive-factorial(number)
	let tail = tail-factorial(number)
	let folded = folded-factorial(number)

	Io::print("naive factorial: {naive}")
	Io::print("tail recursice factorial: {tail}")
	Io::print("fold-based factorial: {folded}")
}


let naive-factorial(n) {
	if n <= 1 {
		1
	} else {
		n * naive-factorial(n - 1)
    }
}


let tail-factorial(n: Int) -> Int {
	let step(n, accum) {
		if n <= 1 {
			accum
		} else {
			step(n - 1, n * accum)
        }
    }

	step(n, 1)
}


let fold-factorial(n: Int) -> Int {
	(2 <upto> n).fold(1, ___ * ___)
}


forall N: #num
let generic-tail-factorial(number: N) -> N {
    let step(num, accum) {
        if num <= N::one {
			accum
        } else {
			step(num - N::one, num * accum)
        }
    }

	step(number, N::one)
}


forall N: #num #range
let generic-fold-factorial(number: N) -> N {
	(N::one <upto> number).fold(N::one, ___ * ___)
}


let gcd(a: Int, b: Int) -> Int
	require
		a > 0
		b > 0
	ensure
		result > 0
{
	let (a', b') = (max(a, b), min(a, b))
	if b' == 0 {
		a'
	} else {
		gcd(b', a' <mod> b')
    }
}

	
let fibonacci(n: Int) -> Int
	require n > 0
	ensure result > 0
{
	let step(n, previous, current) {
		if n == 0 {
			current
		} else {
			step(n - 1, current, previous + current)
        }
    }

	step(n, 1, 1)
}


let pipeline-example() {
	let my-array = Array(1, 2, 3, 4, 5, 6, 7)
	my-array
        .iterator()
		.filter( ___.is-even )
		.map( ___ * 2 )
		.fold("") \(string, number) {
            "{string}, {number.to-string}"
		}
		.map() \(rune) {
            if rune.is-letter {
                rune.to-upper
            } else {
                Rune("?")
            }
		}
}
