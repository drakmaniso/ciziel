module lexer


struct Lexer =
    filepath: String
    input: String
    start: Size
    pos: Size

func new-lexer(filepath: String, input: String) -> Lexer =
    Lexer(
        :filepath,
        :input,
        start: 0,
        pos: 0,
    )

func lexer-run(lexer: Lexer) -> =
    (lexer, tag) := scan(lexer)
    if tag == token'EndOfFile then
        lexer
    else
        lexer-run(
            lexer.with(
                token:
                    Token(
                        value: str-slice(lexer.input, lexer.start, lexer.pos),
                        tag: tag,
                        pos: lexer.start,
                    ),
                start: lexer.pos,
            )
        )

let next!(mut self: Lexer) -> Option[Char] =
    result = self.input[self.pos]
    if result is Some then
        self.pos <- self.pos + 1
    return result

let ignore!(mut self: Lexer) =
    self.start <- self.pos

let backtrack!(mut self: Lexer) =
    self.pos <- self.pos - 1

let peek(self: Lexer) -> Option[Char] =
    self.input[self.pos + 1]


-- Old version:

module lexer

let Lexer{
        filepath: String,
        input: String,
        start: UInt,
        pos: UInt,
    }

let State! = Func![mut Lexer -> State!] | Nil

for Lexer:
    def new(filepath: String, input: String) -> Lexer =
        Lexer{
            filepath,
            input,
            start = 0,
            pos = 0,
        }

    def run!(mut self) =
        mut state! = state_between
        while state! =/= Nil do
            state! <- state!(self)

    let next!(mut self) -> Char | OutOfBounds =
        result = self.input.at(self.pos)?
        self.pos <- self.pos++
        result

    let ignore!(mut self) =
        self.start <- self.pos
    
    let backtrack!(mut self) =
        self.pos <- self.pos - 1
    
    let peek(self) -> Char | OutOfBounds =
        self.input.at(self.pos + 1)?