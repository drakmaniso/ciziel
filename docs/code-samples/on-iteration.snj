-- From https://www.informit.com/articles/printerfriendly/1407357


#one-pass-range =
	trait {
		Self.Item: #type
		(Self).front -> Self.Item?
		(Self).pop-front -> Self
	}


find(range: R, value: R.Item) -> R
	forall R: #one-pass-range
	=
    if range.front is Ok(value) then
		range
    else
		find(range.pop-front, value)
	end


#writable-range =
	trait {
		Self.Item: #type
		(Self).replace-front(item: Self.Item) -> Self?
	}


copy(source: A, target: B) -> (A, B)
	forall A: #one-pass-range
		and B: #one-pass-range #writable-range
		and A.Item == B.Item
	=
	case source.front
	of Ok(item) then
		case target.replace-front(item)
		of Ok(target') then
			copy(source.pop-front, target'.pop-front)
		else (source, target)
	else (source, target)


copy(source: A, target: B) -> (A, B)
	forall A: #one-pass-range
		and B: #one-pass-range #writable-range
		and A.Item == B.Item
	=
	try
		item ?= source.front
		target' ?= target.replace-front(item)
		copy(source.pop-front, target.pop-front)
	else
		_ => (source, target)


trait #forward-range {
    trait #one-pass-range
    fun (Self).save -> Self
}


trait #double-ended-range {
    trait #forward-range
    fun (Self).back -> Self.Item?
    fun (Self).pop-back -> Self
}


trait #random-access-range {
    trait #forward-range
    fun (Self).at(index: Size) -> Self.Item?
    fun (Self).slice(from: Size, to: Size) -> Self
}


trait #length {
    fun (Self).length -> Size
}


trait #is-infinite {
    val Self.is-infinite: Bool
}
