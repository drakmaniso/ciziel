--- GADT ----------------------------------------------------------------------


module gadt1 ---- First GADT Example ------------------------------------------


/*
[from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
*/


public


union Expr[A] {
	Bool(value: Bool) -> Expr[Bool]
	Int(value: Int) -> Expr[Int]
	Equal(left: ref Expr[Int], right: ref Expr[Int]) -> Expr[Bool]
}


trait #expr[A] {
	type Self[A]
	fun (Self[A]).eval -> A
}


implement #expr for Expr[A]


fun (Expr[A]).eval -> A =
	case self
		of Expr.Bool(value) then value
		of Expr.Int(value) then value
		of Expr.Equal(left, right) then left.equal == right.equal
	end


fun main() -> Void &io =
	do
		expr1 = Expr.Equal(Expr.Int(2), Expr.Int(3))
		print("{expr1.Type}")
		-- Expr[Bool]

		eval1 = expr1.eval
		print("{eval1.Type}")
		-- Bool
	end


public -- Without GADTs:


type Expr =
	| Bool(value: Bool)
	| Int(value: Int)
	| Equal(left: ref Expr[Output == Int], right: ref Expr[Output ==Int])


trait #expr {
	type Self.Output
	fun (Self).eval -> Self.Output
}


implement #expr for Expr.Bool
type Expr.Bool.Output = Bool
fun (Expr.Bool).eval -> Bool = self.value


implement #expr for Expr.Int
type Expr.Int.Output = Int
fun (Expr.Int).eval -> Int = self.value


implement #expr for Expr.Equal
type Expr.Equal.Output = Bool
fun (EEqual).eval -> Bool = (self.left.eval == self.right.eval)


fun main() -> Void &io =
	do
		expr1 = Expr.Equal(Expr.Int(2), Expr.Int(3))
		print("{expr1.Type}")
		-- Expr.Equal

		eval1 = expr1.eval
		print("{eval1.Type}")
		-- Bool
	end


module gadt2 ---- Second GADT Example: Phantom Types --------------------------


<<
From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
>>


public


type Term = ITerm | BTerm
type ITerm = Zero | Succ | Pred | If[Term]
type BTerm = Is-Zero | If[Bool]


type Term[T] =
	| Zero -> Term[Int]
	| Succ(arg: ITerm) -> Term[]
	| Pred(arg: ITerm)
	| Is-Zero(arg: ITerm)
	| If[T] {
		condition: BTerm,
		then-branch: T,
		else-branch: T,
	}


type Term.Output = Int | Bool
type ITerm.Output = Int
type BTerm.Output = Bool
type Zero.Output = Int
type Succ.Output = Int
type Pred.Output = Int
type Is-Zero.Output = Bool
type If[T].Output = T


auto (Term).eval -> Int | Bool
auto (ITerm).eval -> Int
auto (BTerm).eval -> Bool


fun (Zero).eval -> Int = 0
fun (Succ).eval -> Int = self.arg.eval + 1
fun (Pred).eval -> Int = self.arg.eval - 1
fun (Is-Zero).eval -> Bool = self.arg.eval == 0
fun (If[T]).eval -> T =
	if self.condition.eval then
		self.then-branch.eval
	else
		self.else-branch.eval
	end


module gadt3 ---- Third GADT Example: Higher-Order Abstract Syntax ------------


<<
From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
>>


public


trait #expr {
	Self.Output: Type
	(Self).eval -> Self.Output
}


struct Lift[T](value: T)


struct Pair[T #expr, U #expr](
	first: T,
	second: U,
)


struct Lambda[T #expr, U #expr](value: T -> U)


struct Apply[T #expr, U #expr](
	function: Lambda[T, U],
	argument: U,
)


struct Fix[T #expr](function: Lambda[T, T])


implement #expr for Lift[T]
implement #expr for Pair[T, U]
implement #expr for Lambda[T, U]
implement #expr for Apply[T, U]
implement #expr for Fix[T]


type Lift[T].Output = T
type Pair[T, U].Output = (T, U)
type Lambda[T, U].Output = T -> U
type Apply[T, U].Output = U
type Fix[T].Output = T


fun (Lift[T]).eval -> T =
	self.first.value


fun (Pair[T, U]).eval -> (T, U) =
	(self.first.eval, self.second.eval)


fun (Lambda[T, U]).eval -> (T -> U) =
	x => self.function(Lift(x)).eval


fun (Apply[T, U]).eval -> U =
	self.function.eval(self.argument.eval)


fun (Fix[T]).eval -> T =
	self.function.eval(Fix(self.function).eval)


fun example() -> Void &io =
	do
		factorial =
			Fix(
				Lambda(
					f =>
						Lambda(
							y =>
								y' = y.eval
								f' = f.eval

								if y' == 0 then
									Lift(1)
								else
									Lift(y' * f'(y' - 1))
								end
						)
				)
			)

		factorial-of-ten = Apply(factorial, Lift(10))

		print(factorial-of-ten.eval)
	end
