--- GADT ----------------------------------------------------------------------


module gadt1 ---- First GADT Example ------------------------------------------


<<
[from wikipedia]: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type
>>


public


type Expr =
	| EBool(value: Bool)
	| EInt(value: Int)
	| EEqual(left: *EInt, right: *EInt)


trait #expr {
	Self.Output: Type
	(Self).eval -> Self.Output
}


auto implement #expr for Expr
auto fun (Expr).eval -> Expr.Output


implement #expr for EBool
type EBool.Output = Bool
fun (EBool).eval -> Bool = self.value


implement #expr for EInt
type EInt.Output = Int
fun (EInt).eval -> Int = self.value


implement #expr for EEqual
type EEqual.Output = Bool
fun (EEqual).eval -> Bool = (self.left.eval == self.right.eval)


fun main() -> Void &io =
	do
		expr1 = EEqual(EInt 2, EInt 3)
		print("{expr1.Type.name}")
		-- EEqual

		eval1 = expr1.eval
		print("{eval1.Type.name}")
		-- Bool

		exprs = Array(EInt 2, EBool True, EEqual(EInt 2, EInt 3))
		print("{expr2.Type.name}")
		-- Array[Expr]

		evals = exprs.map(___.eval)
		print("{evals.Type.name}")
		-- Array[Bool | Int]
	end


module gadt2 ---- Second GADT Example: Phantom Types --------------------------


<<
From ["Fun with phantom types"] by R. Hinze

["Fun with phantom types"]:
https://www.researchgate.net/publication/228707929_Fun_with_phantom_types
>>


public


type Term = ITerm | BTerm
type ITerm = Zero | Succ | Pred | If[Term]
type BTerm = Is-Zero | If[Bool]


struct Zero
struct Succ(arg: ITerm)
struct Pred(arg: ITerm)
struct Is-Zero(arg: ITerm)
struct If[T] {
	condition: BTerm,
	then-branch: T,
	else-branch: T,
}


type Term.Output = Int | Bool
type ITerm.Output = Int
type BTerm.Output = Bool
type Zero.Output = Int
type Succ.Output = Int
type Pred.Output = Int
type Is-Zero.Output = Bool
type If[T].Output = T


auto (Term).eval -> Int | Bool
auto (ITerm).eval -> Int
auto (BTerm).eval -> Bool


fun (Zero).eval -> Int = 0
fun (Succ).eval -> Int = self.arg.eval + 1
fun (Pred).eval -> Int = self.arg.eval - 1
fun (Is-Zero).eval -> Bool = self.arg.eval == 0
fun (If[T]).eval -> T =
	if self.condition.eval then
		self.then-branch.eval
	else
		self.else-branch.eval
	end


module gadt3 ---- Third GADT Example: Higher-Order Abstract Syntax ------------


<<
From [wikipedia](https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax)
>>


public


trait #expr {
	Self.Output: Type
	(Self).eval -> Self.Output
}


struct Lift[T](value: T)


struct Pair[T #expr, U #expr](
	first: T,
	second: U,
)


struct Lambda[T #expr, U #expr](value: T -> U)


struct Apply[T #expr, U #expr](
	function: Lambda[T, U],
	argument: U,
)


struct Fix[T #expr](function: Lambda[T, T])


implement #expr for Lift[T]
implement #expr for Pair[T, U]
implement #expr for Lambda[T, U]
implement #expr for Apply[T, U]
implement #expr for Fix[T]


type Lift[T].Output = T
type Pair[T, U].Output = (T, U)
type Lambda[T, U].Output = T -> U
type Apply[T, U].Output = U
type Fix[T].Output = T


fun (Lift[T]).eval -> T =
	self.first.value


fun (Pair[T, U]).eval -> (T, U) =
	(self.first.eval, self.second.eval)


fun (Lambda[T, U]).eval -> (T -> U) =
	x => self.function(Lift(x)).eval


fun (Apply[T, U]).eval -> U =
	self.function.eval(self.argument.eval)


fun (Fix[T]).eval -> T =
	self.function.eval(Fix(self.function).eval)


fun example() -> Void &io =
	do
		factorial =
			Fix(
				Lambda(
					f =>
						Lambda(
							y =>
								y' = y.eval
								f' = f.eval

								if y' == 0 then
									Lift(1)
								else
									Lift(y' * f'(y' - 1))
								end
						)
				)
			)

		factorial-of-ten = Apply(factorial, Lift(10))

		print(factorial-of-ten.eval)
	end
