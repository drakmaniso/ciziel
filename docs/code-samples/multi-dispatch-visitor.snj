/*
# Multiple dispatch emulated with the Visitor pattern
*/


/*
## Simple single module version
*/


module pets

def #pet {
    has #pet-visitor
    has Self(name: String, ...)
    has meets(other: #pet) -> String
}


def #pet-visitor {
    has visit-dog(other: Dog) -> String
    has visit-cat(other: Cat) -> String
}


forall A #pet, B #pet
def encounter(a: A, b: B) -> String {
    let verb = a.meets(b)
    "{a.name} meets {b.name} and {verb}"
}


def Cat {
    var name: String
}

extend Cat as #pet {
    def meets(other: A #pet) -> String = { other.visit-cat(self) }
}

extend Cat as #pet-visitor {
    def visit-cat(other: Cat) -> String = { "slinks" }
    def visit-dog(other: Dog) -> String = { "hisses" }
}


def Dog {
    var name: String
}

extend Dog as #pet {
    def meets(other: B #pet) -> String = { other.visit-dog(self) }
}

extend Dog as #pet-visitor {
    def visit-cat(other: Cat) -> String = { "chases" }
    def visit-dog(other: Dog) -> String = { "sniffs" }
}


/*
## Combined with the extension problem
*/


module pets


forall V: #visitor
def #pet[V] {
    has name() -> String

    has meets(other: V[Self]) -> String {
        V.visit(self, other)
    }
}


forall P: #pet
def #visitor[P] {
    has visit(a: P[V], b: Self[V]) -> String
    implement Pet
}


--

module cats-and-dogs

use pets (#pet, #visitor)

def Cat[V] = struct { name: String } implement #pet

def Dog[V] = struct { name: String } implement #pet

def Pet[V] = enum(Cat[V] | Dog[V]) implement #visitor

def Pet[V].visit(a: Pet[V], b: Pet[V]) -> String =
    match (a, b)
    case (a: Cat, b: Cat) then "slinks"
    case (a: Cat, b: Dog) then "hisses"
    case (a: Dog, b: Cat) then "chases"
    case (a: Dog, b: Dog) then "sniffs"
    end


--


module birds

use cats-and-dogs (Cat, Dog)
use pets (#pet, #visitor, Pet)

def Bird[V] = struct() implement #pet

def Ext-Pet[V] = enum(Pet[V] | Bird[V]) implement #visitor

def Ext-Pet[V].visit(a: Ext-Pet[V], b: Ext-Pet[V]) -> String =
    match (a, b)
    case (a: Pet, b: Pet) then Pet.visit(a, b)
    case (a: Cat, b: Bird) then "hunts"
    case (a: Bird, b: Cat) then "flees"
    case (a: Dog, b: Bird) then "barks"
    case (a: Bird, b: Dog) then "flees"
    end


-------------------------------------------------------------------------------

module test

use pets (#pet)
use dogs (Dog)
use cats (Cat)

def example_encounter() -> Io[] =
    Io.do {
        let fido = Dog("Fido")
        let rex = Dog("Rex")
        let whiskers = Cat("Whiskers")
        let spot = Cat("Spot")

        Io.print(encounter(fido, rex))
        --> Fido meets Rex and sniffs
        Io.print(encounter(fido, whiskers))
        --> Fido meets Whiskers and chases
        Io.print(encounter(whiskers, rex))
        --> Whiskers meets Rex and hisses
        Io.print(encounter(whiskers, spot))
        --> Whiskers meets Spot and slinks

        let pets = Array(fido, whiskers)
        Io.wrap(
            pets.map(fun(pet) ->
                Io.print("{pet.name}: {pet.type}")
            )
        )
        --> Fido: enum(Cat | Dog)
        --> Whiskers: enum(Cat | Dog)

        Io.wrap(
            pets.map(fun(a) ->
                pets.map(fun(b) ->
                    Io.print(encounter(a, b))
                )
            )
        )
        --> Fido meets Fido and sniffs
        --> Fido meets Whiskers and chases
        --> Whiskers meets Fido and hisses
        --> Whiskers meets Whiskers and slinks
    }
