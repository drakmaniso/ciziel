-- # Multiple dispatch emulated with the Visitor pattern


-- ## Simple single module version


module pets

public #pet =
    has #pet-visitor
    has Self { name: String, ... }
    has (Self).meets(other: #pet) -> String
    implement Cat, Dog


public #pet-visitor =
    has (Self).visit-dog(other: Dog) -> String
    has (Self).visit-cat(other: Cat) -> String


public encounter(a: A, b: B) -> String
    forall A #pet, B #pet
=
    let verb = a.meets(b)
    "{a.name} meets {b.name} and {verb}"


public Cat = struct { name: String }
public (Cat).meets(other: A #pet) -> String = other.visit-cat(self)
public (Cat).visit-cat(other: Cat) -> String = "slinks"
public (Cat).visit-dog(other: Dog) -> String = "hisses"


public Dog = struct { name: String }
public (Dog).meets(other: B #pet) -> String = other.visit-dog(self)
public (Dog).visit-cat(other: Cat) -> String = "chases"
public (Dog).visit-dog(other: Dog) -> String = "sniffs"


-- ## Combined with the extension problem


module pets


public #pet =
    has Self[V]

    has Self { name: String, ... }

    has (Self[V]).meets(other: V[V]) -> String
        forall V #visitor
    =
        V.visit(self, other)
    
    implement Cat, Dog


public #visitor =
    has Self[V].visit(a: Self[V], b: Self[V]) -> String
    implement Pet


--

module cats-and-dogs

use pets (#pet, #visitor)

public Cat[V] = struct { name: String } implement #pet

public Dog[V] = struct { name: String } implement #pet

public Pet[V] = enum(Cat[V] | Dog[V]) implement #visitor

public Pet[V].visit(a: Pet[V], b: Pet[V]) -> String =
    match (a, b)
    case (a: Cat, b: Cat) then "slinks"
    case (a: Cat, b: Dog) then "hisses"
    case (a: Dog, b: Cat) then "chases"
    case (a: Dog, b: Dog) then "sniffs"
    end


--


module birds

use cats-and-dogs (Cat, Dog)
use pets (#pet, #visitor, Pet)

public Bird[V] = struct() implement #pet

public Ext-Pet[V] = enum(Pet[V] | Bird[V]) implement #visitor

public Ext-Pet[V].visit(a: Ext-Pet[V], b: Ext-Pet[V]) -> String =
    match (a, b)
    case (a: Pet, b: Pet) then Pet.visit(a, b)
    case (a: Cat, b: Bird) then "hunts"
    case (a: Bird, b: Cat) then "flees"
    case (a: Dog, b: Bird) then "barks"
    case (a: Bird, b: Dog) then "flees"
    end


-------------------------------------------------------------------------------

module test

use pets (#pet)
use dogs (Dog)
use cats (Cat)

public example_encounter() -> Io[] =
    Io.do {
        let fido = Dog("Fido")
        let rex = Dog("Rex")
        let whiskers = Cat("Whiskers")
        let spot = Cat("Spot")

        Io.print(encounter(fido, rex))
        --> Fido meets Rex and sniffs
        Io.print(encounter(fido, whiskers))
        --> Fido meets Whiskers and chases
        Io.print(encounter(whiskers, rex))
        --> Whiskers meets Rex and hisses
        Io.print(encounter(whiskers, spot))
        --> Whiskers meets Spot and slinks

        let pets = Array(fido, whiskers)
        Io.wrap(
            pets.map(fun(pet) ->
                Io.print("{pet.name}: {pet.type}")
            )
        )
        --> Fido: enum(Cat | Dog)
        --> Whiskers: enum(Cat | Dog)

        Io.wrap(
            pets.map(fun(a) ->
                pets.map(fun(b) ->
                    Io.print(encounter(a, b))
                )
            )
        )
        --> Fido meets Fido and sniffs
        --> Fido meets Whiskers and chases
        --> Whiskers meets Fido and hisses
        --> Whiskers meets Whiskers and slinks
    }
