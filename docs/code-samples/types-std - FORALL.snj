def Nil

def Bool = union(False | True)
def False = struct()
def True = struct()


[[ ## Option ############################################################### ]]


def Option[A] = union(None | Some[A])
def None = struct()
def Some[A] = struct(var item: A)


extend Option[A] as #functor[A] 


forall A
extend Some[A] as #functor[A] {
    def .map(transform: func(A) -> B) -> Some[B] forall B {
        Some(transform(self.item))
    }
}


forall A
extend None as #functor[A] {
    def .map(transform: func(A) -> B) -> None
    forall B {
        None
    }
}


forall A
extend Option[A] as #monad[A] {
    def ::wrap(value: A) -> Option[A] {
        Some(value)
    }

    forall B
    def .chain(operation: func(A) -> Option[B]) -> Option[B] {
        match self {
        case Some(item) => operation(item)
        case None => None
        }
    }
}


[[ ## Result ############################################################### ]]


def Result[A, E] = union(
    | Ok[A] 
    | Error[E]
)


def Ok[A] = struct(
    var value: A,
)


forall E: #error
def Error[E] = struct(
    var error: E,
)


forall A, E
extend Result[A, E] as #monad[A] {
    def ::wrap(value: A) -> Result[A, E] {
        Result(Ok(value))
    }

    def .chain(operation: func(A) -> Result[A, E]) -> Result[A, E] {
        match self {
        case Ok(value) => operation(value)
        case e: Error[E] => Result(e)
        }
    }
}


[[ ## Map Iterator ######################################################### ]]


forall I: #iterator 
def Map[I, A] = struct(
    let iterator: I,
    let transform: func(I::Item) -> A,
)


forall I: #iterator 
extend Map[I, A] {
    def ::new(iterator: I, transform: func(I'Item) -> A) -> Map[I, A] {
        Map(iterator, transform)
    }
}


forall I: #iterator 
extend Map[I, A] as #iterator {
    def ::Item = A

    def .next -> (Map[I, A], Option[A]) {
        match self.iterator.next {
        case (_, None) =>
            (Self, None)

        case (iter, Some(item)) =>
            let new-self = self.with(iterator: iter)
            let transformed = transform(item)
            (new-self, Some(transformed))
        }
    }
}

