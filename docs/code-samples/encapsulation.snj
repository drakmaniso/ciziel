[[ # Encapsulation ]]

[[ ## Structs ############################################################### ]]

[[ There is four levels of visibility for data for data structures:
- fully private,
- opaque (can be used but not constructed or deconstructed),
- read-only (can be used and deconstructed, but not constructed),
- and fully public. ]]


[[ ### Private Structs ]]

[[ A local struct is completely private: it cannot appear in the public
interface of the module, and cannot be used outside the module. ]]

let Private {
    let foo: Int
    let bar: Bool
}


[[ ### Opaque Structs ]]

[[ An opaque struct can be used outside the module, but its fields cannot be
accessed, its default constructor cannot be used, and it cannot be updated. ]]

def Opaque {
    let foo: Int
    let bar: Bool
}

def some-function() -> Opaque {
    Opaque(foo = 1, bar = False)
}


[[ ### Read-Only Structs ]]

[[ An opaque struct can publish some (or all) of its fields, which can then be
accessed outside the module. However the constructor and the functional update
are still private. ]]

def Read-Only {
    def foo: Int
    def bar: Bool
}

def some-function() -> Read-Only {
    Read-Only(foo = 1, bar = False)
}


[[ ### Public Structs ]]

[[ A public struct is completely transparent: all its fields are accessible
outside the module, as well as the default constructor and the functional
update syntax. ]]

def Public {
    var foo: Int
    var bar: Bool
}


[[ ### Mixed Visibility Structs ]]

def Mixed {
    var foo: Int
    def bar: Bool
    let baz: String
}

def some-function(foo: Int) -> Mixed {
    Mixed(foo, bar = foo.is-even(), baz = foo.to-string())
}


[[ ## Unions ################################################################ ]]


[[ ### Private Unions ]]

[[ A local enum is completely private: it cannot appear in the public interface
of the module, and cannot be used outside the module. ]]

let Private = Foo | Bar
let Foo
let Bar


[[ ### Public Unions ]]

[[ A public enum is completely transparent: it can be used, constructed and
matched outside the module. ]]

def Transparent = Foo | Bar
def Foo
def Bar


[[ ### Opaque Unions ]]

[[ An opaque enum can be used outside the module. However it cannot be
constructed or matched outside the module (even if its variants are public
types). ]]

def Opaque = Foo | Bar
let Foo
let Bar

def some-function() -> Opaque {
    Foo
}


[[ Opaque Unions of Public Types: ]]

def Foo
def Bar

def Opaque = Opaque-Foo | Opaque-Bar
let Opaque-Foo = Foo
let Opaque-Bar = Bar


[[ ## Traits ################################################################ ]]

[[ ### Private Traits ]]

let #private {
    has foo() -> Int
    has bar() -> Bool
}


[[ ### Public Traits ]]

def #transparent {
    has foo() -> Int
    has bar() -> Bool
}


[[ ### Opaque Traits ]]

def #opaque {
    has #private
}

let #private {
    has foo() -> Int
    has bar() -> Bool
}    


[[ ## Proxy Types? ]]

[[ ### Proxy Structs? ]]

def Pseudo-Struct = proxy Underlying-Type

for Pseudo-Struct {
    def Pseudo-Struct(
        foo: Int,
        bar: Bool,
    ) {
        Underlying-Type.make-from(foo, bar)
    }

    def foo -> Int {
        self.extract-foo()
    }

    def bar -> Bool {
        self.extract-bar()
    }
}

[[ ### Proxy Unions ]]

def Pseudo-Enum {
    proxy Underlying-Type

    def Pseudo-Enum(variant: Foo | Bar) {
        Underlying-Type.make-from(variant)
    }

    def (Pseudo-Enum).match -> Foo | Bar {
        self.extract-variant()
    }
}