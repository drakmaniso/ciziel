--- Encapsulation


--- Structs -------------------------------------------------------------------


<< A struct declared with `let` is completely private: it cannot be used outside
the module, and cannot appear in the public interface of the module. All its
fields are private and must be declared with `let`. >>


let Private = struct {
    let foo: Int
    let bar: Bool
}


<< A struct declared with `def` is public, and can be used outside the module.
However, if the fields are declared with `let`, then the constructor is private
and so are the fields. >>


def Opaque = struct {
    let foo: Int
    let bar: Bool
}


<< Read-Only Struct >>
def Read-Only = struct {
    def foo: Int
    def bar: Bool
}


<< Transparent Struct >>
def Transparent = struct {
    data foo: Int
    data bar: Bool
}


<< Translucent Struct >>
def Translucent = struct {
    let opaque: Int
    def read-only: Bool
    data transparent: String
}



--- Unions --------------------------------------------------------------------


let Private-Foo = struct {}
let Private-Bar = struct {}
def Public-Foo = struct {}
def Public-Bar = struct {}


<< Private Union >>
let Private =
    | Private-Foo
    | Private-Bar


<< Opaque Union >>
def Opaque =
    | Private-Foo
    | Private-Bar


<< Transparent Union >>
def Transparent =
    | Public-Foo
    | Public-Bar


<< Translucent Union >>
def Translucent =
    | Public-Foo
    | Private-Bar


<< NOTE: Because unions are structural, it's impossible to create an opaque union of
public types. >>


--- Traits --------------------------------------------------------------------


<< Private Traits >>
let #private = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}


<< Public Traits >>
def #transparent = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}


<< Opaque Traits >>
def #opaque = trait {
    has #private
}


let #private = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}
