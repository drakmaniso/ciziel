/*
# Encapsulation
*/


/*
## Structs ####################################################################
*/


/*
Private Struct
*/
let Private {
    let foo: Int
    let bar: Bool
}


/*
Opaque Struct
*/
def Opaque {
    let foo: Int
    let bar: Bool
}


/*
Read-Only Struct
*/
def Read-Only {
    def foo: Int
    def bar: Int
}


/*
Transparent Struct
*/
def Transparent {
    var foo: Int
    var bar: Bool
}


/*
Translucent Struct
*/
def Translucent {
    let opaque: Int
    def read-only: Bool
    var transparent: String
}


/*
Proxy Struct?
*/
def Proxy {
    let underlying: Int | Float

    def Proxy(foo: String) {
        n = (foo <to> Option[Int])
            .or-else(___ <to> Option[Float])
            .with-default(0 as Int)
        Proxy(underlying: n)
    }

    def foo -> String {
        underlying <to> String
    }

    def bar -> Bool {
        match self.underlying {
        case n as Int:
            n.is-even()
        case _:
            False
        }
    }
}

/* would be used like:*/

def Proxy {
    var foo: String
    def bar: Bool

    def Proxy(foo: String) {
        ...
    }
}

/*
## Unions #####################################################################
*/


let Private-Foo
let Private-Bar
def Public-Foo
def Public-Bar


/*
Private Union
*/
let Private = Private-Foo | Private-Bar


/*
Opaque Union
*/
def Opaque = Private-Foo | Private-Bar


/*
Translucent Union
*/
def Translucent = Public-Foo | Private-Bar


/*
Transparent Union
*/
def Transparent = Public-Foo | Public-Bar


/*
NOTE: Because unions are structural, it's impossible to create an opaque union of
public types.
*/


/*
## Traits #####################################################################
*/


/*
Private Traits
*/
let #private {
    has foo() -> Int
    has bar(arg: Bool) -> String
}


/*
Public Traits
*/
def #transparent {
    has foo() -> Int
    has bar(arg: Bool) -> String
}


/*
Opaque Traits
*/
def #opaque {
    has #private
}


let #private {
    has foo() -> Int
    has bar(arg: Bool) -> String
}
