--- Encapsulation


--- Structs -------------------------------------------------------------------


<< A struct declared with `let` is completely private: it cannot be used outside
the module, and cannot appear in the public interface of the module. All its
fields are private and must be declared with `let`. >>
let Private = struct {
    let foo: Int
    let bar: Bool
}


<< A struct declared with `def` is public, and can be used outside the module.
However, if the fields are declared with `let`, then the constructor is private
and so are the fields. >>
def Opaque = struct {
    let foo: Int
    let bar: Bool
}


<< Read-Only Struct >>
def Read-Only = struct {
    def foo: Int
    def bar: Bool
}


<< Transparent Struct >>
def Transparent = struct {
    data foo: Int
    data bar: Bool
}


<< Translucent Struct >>
def Translucent = struct {
    let opaque: Int
    def read-only: Bool
    data transparent: String
}



--- Unions --------------------------------------------------------------------


<< Private Union >>
let Private = union {
    case Foo
    case Bar
}


<< Opaque Union >>
def Opaque = union {
    alias Private
}


<< Transparent Union >>
def Transparent = union {
    case Foo
    case Bar
}


<< Translucent Union >>
def Translucent = union {
    case Foo
    alias Private
}


<< NOTE: Because unions are structural, it's impossible to create an opaque union of
public types. >>


-- Structs as Syntax Sugar ----------------------------------------------------


def My-Struct = struct {
    def foo: Int
    let bar: Bool
}


def My-Struct = union {
    case My-Struct {
        def foo: Int
        let bar: Bool
    }
}


--- Traits --------------------------------------------------------------------


<< Private Traits >>
let #private = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}


<< Public Traits >>
def #transparent = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}


<< Opaque Traits >>
def #opaque = trait {
    has #private
}


let #private = trait {
    has (Self).foo -> Int
    has (Self).bar(arg: Bool) -> String
}


--- Proxy Struct? -------------------------------------------------------------


let Proxy = union {
    case INum(let value: Float64)
    case FNum(let value: Int64)
    case Invalid
}


def Proxy(value: String) {
    if Float64.parse(value) case Some(n) then
        FNum(value = n)
    else if Int64.parse(value) case Some(n) then
        INum(value = n)
    else
        Invalid
}


def (Proxy).value -> String {
    match self {
        case FNum(value) => value <to> String
        case INum(value) => value <to> String
        case Invalid => "*** invalid ***"
    }
}


<< ...would be used like the following struct: >>


def Proxy = struct {
    data value: String
}
