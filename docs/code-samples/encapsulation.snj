-- # Encapsulation

[[ There is four levels of visibility for data for data structures:
- fully private,
- opaque (can be used but not constructed or deconstructed),
- read-only (can be used and deconstructed, but not constructed),
- and fully public.
]]


-- ## Structs

-- ### Private Structs

[[ A local struct is completely private: it cannot appear in the public
interface of the module, and cannot be used outside the module. ]]

let Private {
    let foo: Int
    let bar: Bool
}


-- ### Opaque Structs

[[ An opaque struct can be used outside the module, but its fields cannot be
accessed, its default constructor cannot be used, and it cannot be updated. ]]

def Opaque {
    let foo: Int
    let bar: Bool
}

def some-function() -> Opaque {
    Opaque(foo = 1, bar = False)
}


-- ### Read-Only Structs

[[ An opaque struct can publish some (or all) of its fields, which can then be
accessed outside the module. However the constructor and the functional update
are still private. ]]

def Read-Only {
    def foo: Int
    def bar: Bool
}

def some-function() -> Read-Only {
    Read-Only(foo = 1, bar = False)
}


-- ### Public Structs

[[ A public struct is completely transparent: all its fields are accessible
outside the module, as well as the default constructor and the functional
update syntax. ]]

def Transparent {
    var foo: Int
    var bar: Bool
}


-- ### Semi-Opaque Structs

def Semi-Opaque {
    var foo: Int
    def bar: Bool
    let baz: String
}

def some-function(foo: Int) -> Semi-Opaque {
    Semi-Opaque(foo, bar = foo.is-even(), baz = foo.to-string())
}


-- ## Unions

-- ### Private Unions

[[ A local enum is completely private: it cannot appear in the public interface
of the module, and cannot be used outside the module. ]]

let Private {
    case Foo
    case Bar
}


-- ### Opaque Unions

[[ An opaque enum can be used outside the module. However it cannot be
constructed or matched outside the module (even if its variants are public
types). ]]

def Opaque {
    case Foo
    case Bar
}
let Foo
let Bar


def some-function() -> Opaque {
    Foo
}


-- ### Public Unions

[[ A public enum is completely transparent: it can be used, constructed and
matched outside the module. ]]

def Transparent {
    case Foo
    case Bar
}
def Foo
def Bar


-- ### Opaque Unions of Public Types?

def Opaque {
    let case Foo
    let case Bar
}
def Foo
def Bar


-- ### Read-Only Union?

[[ An opaque enum can publish some or all of its variants. It can then be
matched outside the module, but still cannot be constructed. ]]

def Opaque {
    def case Foo
    def case Bar
}
def Foo
def Bar


-- ## Traits

-- ### Private Traits

let #private {
    has foo() -> Int
    has bar() -> Bool
}


-- ### Public Traits

def #transparent {
    has foo() -> Int
    has bar() -> Bool
}


-- ### Opaque Traits?

def #opaque {
    let has foo() -> Int
    let has bar() -> Bool
}



-- ## Proxy Types?

-- ### Proxy Structs?

def Pseudo-Struct {
    proxy Underlying-Type

    def Pseudo-Struct(
        foo: Int,
        bar: Bool,
    ) {
        Underlying-Type.make-from(foo, bar)
    }

    def foo -> Int {
        self.extract-foo()
    }

    def bar -> Bool {
        self.extract-bar()
    }
}

-- ### Proxy Unions

def Pseudo-Enum {
    proxy Underlying-Type

    def Pseudo-Enum(variant: Foo | Bar) {
        Underlying-Type.make-from(variant)
    }

    def (Pseudo-Enum).match -> Foo | Bar {
        self.extract-variant()
    }
}