def Nil = struct {}


def Bool = def False | def True


-- Option ---------------------------------------------------------------------


def Option[A] = None[A] | Some[A]
def None[A] = struct {}
def Some[A] = struct { data item: A }


def #functor[A] for Option[A], None, Some[A]


def (None).map(transform: A -> B) -> None {
    None
}


def (Some[A]).map(transform: A -> B) -> Some[B] {
    Some(transform(self.item))
}


def #monad[A] for Option[A]


def Option[A].wrap(value: A) -> Option[A] {
    Some(value)
}


def (Option[A]).chain(operation: A -> Option[B]) -> Option[B] {
    match self {
        | Some(item) => operation(item)
        | None => None
    }
}


-- Result ---------------------------------------------------------------------


def Result[A, E] = Ok[A] | Error[E]
def Ok[A] = struct { data value: A }
def Error[E] = struct { data error: E }


def #monad[A] for Result[A, E]


def Result[A, E].pure(value: A) -> Result[A, E] {
    Ok(value)
}


def (Ok[A, E]).and-then(operation: A -> Result[B, E]) -> Result[B, E] {
    operation(self.value)
}


def (Error[A, E]).and-then(operation: A -> Result[B, E]) -> Error[B, E] {
    self
}


-- Map Iterator ---------------------------------------------------------------


def Map[I, A] = struct {
    let iterator: I
    let transform: I.Item -> A
}


forall I #iterator
def Map[I, A].new(iterator: I, transform: I.Item -> A) -> Map[I, A] {
    Map(iterator, transform)
}


forall I #iterator
def #iterator for Map[I, A]


def Map[I, A].Item = A


forall I #iterator
def (Map[I, A]).next -> (Map[I, A], Option[A]) {
    match self.iterator.next {
        | (Any, None) =>
            (self, None)

        | (i, Some(item)) =>
            let new-self = self.with(iterator: i)
            let transformed = transform(item)

            (new-self, Some(transformed))
    }
}
