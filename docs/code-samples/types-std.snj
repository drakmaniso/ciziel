module /std


public


struct Nil


type Bool = False | True
struct False
struct True


-- Option-Result --------------------------------------------------------------


type A ? E = Ok[A] | Error[E]
struct Ok[A](value: data A)
struct Error[E](error: data E)


type A? = Ok[A] | None -- A ? Nil
type None = Error[Nil]


A ? E: #functor[A]


auto fun (A ? E).map(transform: A -> B) -> B ? E
fun (Ok[A]).map(transform: A -> B) -> Ok[B] = Ok(transform(self.item))
fun (Error[E]).map(transform: A -> B) -> Error[E] = self


A ? E:  #monad[A]


fun A ? E.wrap(value: A) -> Result[A, E] = Ok(value)


auto fun (A ? E).and-then(operation: A -> B ? E) -> B ? E
fun (Ok[A]).and-then(operation: A -> B ? E) -> B ? E = operation(self.value)
fun (Error[E]).and-then(operation: A -> B ? E) -> Error[E] = self


-- Map Iterator ---------------------------------------------------------------


struct Map[I, A] {
    iterator: I
    transform: I.Item -> A
}



Map[I, A]: #iterator
	forall I: #iterator


type Map[I, A].Item = A


fun (Map[I, A]).next -> (Map[I, A], Option[A])
	forall I: #iterator
	=
    case self.iterator.next
	of (_, None) then (self, None)
	of (i, Ok(item)) then
		new-self = self.with(iterator: i)
		transformed = transform(item)
		(new-self, Ok(transformed))
	end
