def Nil

def Bool = False | True
def False
def True


[[ ## Option ]]


def Option[A] = None | Some[A]
def None
def Some[A] {
    var .item: A
}


for Option[A] derive #functor[A] forall A


for Some[A] as #functor[A] forall A {
    def .map(transform: func(A) -> B) -> Some[B] forall B {
        Some(transform(self.item))
    }
}


for None as #functor[A] forall A {
    def .map(transform: func(A) -> B) -> None
    forall B {
        None
    }
}


for Option[A] as #monad[A] forall A {
    def ::wrap(value: A) -> Option[A] {
        Some(value)
    }

    def .chain(operation: func(A) -> Option[B]) -> Option[B]
    forall B {
        match self {
        case Some(item) => operation(item)
        case None => None
        }
    }
}


[[ ## Result ]]


def Result[A, E] forall E: #error = Ok[A] | Error[E]
def Ok[A] {
    var .value: A
}
def Error[E] forall E: #error {
    var .error: E
}



for Result[A, E] as #monad[A] {
    def ::wrap(value: A) -> Result[A, E] {
        Result(Ok(value))
    }

    def .chain(operation: func(A) -> Result[A, E]) -> Result[A, E] {
        match self {
        case Ok(value) => operation(value)
        case e: Error[E] => Result(e)
        }
    }
}


[[ ## Map Iterator ]]


def Map[I, A] forall I: #iterator {
    let iterator: I
    let transform: func(I::Item) -> A
}


for Map[I, A] forall I: #iterator {
    def ::new(iterator: I, transform: func(I'Item) -> A) -> Map[I, A] {
        Map(iterator, transform)
    }
}


for Map[I, A] as #iterator forall I: #iterator {
    def ::Item = A

    def .next -> (Map[I, A], Option[A]) {
        match self.iterator.next {
        case (_, None) =>
            (Self, None)

        case (iter, Some(item)) =>
            let new-self = self.with(iterator: iter)
            let transformed = transform(item)
            (new-self, Some(transformed))
        }
    }
}

