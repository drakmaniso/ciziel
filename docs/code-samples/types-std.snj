def Nil

def Bool {
    case False
    case True
}
def False
def True


--- The "maybe" monad


def Option[A] {
    case None
    case Some[A]
}
def None
def Some[A] {
    var item: A
}


for Option[A]: #functor[A] forall A {
    def .map(transform: Fun(A) -> B) -> Option[B] forall B {
        match self {
        case Some(item) => Some(transform(self.item))
        case None => None
        }
    }
}

for Some[A]: #functor[A] forall A {
    def .map(transform: Fun(A) -> B) -> Some[B] forall B {
        Some(transform(self.item))
    }
}

for None: #functor[A] forall A {
    def map(transform: Fun(A) -> B) -> None
    forall B {
        None
    }
}

for Option[A]: #monad[A] forall A {
    def Option.of(value: A) -> Option[A] {
        Some(value)
    }

    def chain(f: Fun(A) -> Option[B]) -> Option[B]
    forall B {
        match self {
        case Some(item) => f(item)
        case None => None
        }
    }
}

def Option[A] {
    def Some[A] {
        var item: A
        has #functor
    }

    def None {
        has #functor
    }

    has #functor, #monad
}

def Some[A].map(self, transform: Fun(A) -> B) -> Some[B] {

}
---

def Result[A, E] forall E: #error {
    case Ok[A]
    case Error[E]
}

def Ok[A] {
    var value: A
}

def Error[E] forall E: #error {
    var error: E
}


for Result[A, E]: #monad[A] {
    def ::wrap(value: A) -> Result[A, E] {
        Result(Ok(value))
    }

    def .chain(operation: func(A) -> Result[A, E]) -> Result[A, E] {
        match self {
        case Ok(value) => operation(value)
        case e: Error[E] => Result(e)
        }
    }
}


---


def Map[I, A]: forall I #iterator {
    let iterator: I
    let transform: func(I::Item) -> A
}

for Map[I, A] forall I: #iterator {
    def ::new(iterator: I, transform: func(I'Item) -> A) -> Map[I, A] {
        Map(iterator, transform)
    }
}


for Map[I, A]: #iterator forall I: #iterator {
    def ::Item = A

    def .next -> (Map[I, A], Option[A]) {
        match self.iterator.next {
        case (_, None) =>
            (Self, None)

        case (iter, Some(item)) =>
            let new-self = self.with(iterator: iter)
            let transformed = transform(item)
            (new-self, Some(transformed))
        }
    }
}

