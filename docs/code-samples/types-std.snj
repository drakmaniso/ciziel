def Nil

def Bool = union {
    case False
    case True
}


/*
## Option #####################################################################
*/


def Option[A] = union {
    case None
    case Some { data item: A }
}


def #functor[A] for Option[A], None, Some[A]


def (None).map(transform: fun(A) -> B) -> None {
    None
}


def (Some[A]).map(transform: fun(A) -> B) -> Some[B] {
    Some(transform(self.item))
}


def #monad[A] for Option[A]


def Option[A].wrap(value: A) -> Option[A] {
    Some(value)
}


def (Option[A]).chain(operation: fun(A) -> Option[B]) -> Option[B] {
    match self {
        case Some(item) => operation(item)
        case None => None
    }
}


/*
## Result #####################################################################
*/


def Result[A, E] = union {
    case Ok { data value: A }
    case Error { data error: E }
}


def #monad[A] for Result[A, E]


def Result[A, E].pure(value: A) -> Result[A, E] {
    Ok(value)
}


def (Ok[A, E]).and-then(operation: A -> Result[B, E]) -> Result[B, E] {
    operation(self.value)
}


def (Error[A, E]).and-then(operation: A -> Result[B, E]) -> Error[B, E] {
    self
}


/*
## Map Iterator ###############################################################
*/


def Map[I, A] = struct {
    let iterator: I
    let transform: I.Item -> A
}


def Map[I, A].new(iterator: I, transform: I.Item -> A) -> Map[I, A]
    forall I #iterator
{
    Map(iterator, transform)
}


def #iterator for Map[I, A]
    forall I #iterator


def Map[I, A].Item = A


def (Map[I, A]).next -> (Map[I, A], Option[A])
    forall I #iterator
{
    match self.iterator.next {
        case (Any, None) =>
            (self, None)

        case (i, Some(item)) =>
            let new-self = self.with(iterator: i)
            let transformed = transform(item)

            (new-self, Some(transformed))
    }
}
