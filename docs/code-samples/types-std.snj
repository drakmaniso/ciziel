def Nil

def Bool = union(False | True)
def False = struct()
def True = struct()


[[ ## Option ############################################################### ]]


def Option[A] = union(None | Some[A])
def None = struct()
def Some[A] = struct(var item: A)


for Option[A] derive #functor[A] where A


for Some[A] as #functor[A] where A {
    def .map(transform: fun(A) -> B) -> Some[B] where B {
        Some(transform(self.item))
    }
}


for None as #functor[A] where A {
    def .map(transform: fun(A) -> B) -> None
    where B {
        None
    }
}


for Option[A] as #monad[A] where A {
    def ::wrap(value: A) -> Option[A] {
        Some(value)
    }

    def .chain(operation: fun(A) -> Option[B]) -> Option[B]
    where B {
        match self {
        case Some(item) => operation(item)
        case None => None
        }
    }
}


[[ ## Result ############################################################### ]]


def Result[A, E] = union(
    | Ok[A] 
    | Error[E]
)


def Ok[A] = struct(
    var value: A,
)


def Error[E] where E: #error = struct(
    var error: E,
)


for Result[A, E] as #monad[A] {
    def ::wrap(value: A) -> Result[A, E] {
        Result(Ok(value))
    }

    def .chain(operation: fun(A) -> Result[A, E]) -> Result[A, E] {
        match self {
        case Ok(value) => operation(value)
        case e: Error[E] => Result(e)
        }
    }
}


[[ ## Map Iterator ######################################################### ]]


def Map[I, A] where I: #iterator = struct(
    let iterator: I,
    let transform: fun(I::Item) -> A,
)


for Map[I, A] where I: #iterator {
    def ::new(iterator: I, transform: fun(I'Item) -> A) -> Map[I, A] {
        Map(iterator, transform)
    }
}


for Map[I, A] as #iterator where I: #iterator {
    def ::Item = A

    def .next -> (Map[I, A], Option[A]) {
        match self.iterator.next {
        case (_, None) =>
            (Self, None)

        case (iter, Some(item)) =>
            let new-self = self.with(iterator: iter)
            let transformed = transform(item)
            (new-self, Some(transformed))
        }
    }
}

