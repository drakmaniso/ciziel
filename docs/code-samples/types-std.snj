module /std


public


struct Nil


type Bool = False | True
struct False
struct True


-- Option-Result --------------------------------------------------------------


type A ? E = Ok[A] | Error[E]
struct Ok[A](value: data A)
struct Error[E](error: data E)


type A? = Ok[A] | None -- A ? Nil
type None = Error[Nil]


trait #functor[A] for A ? E


auto (A ? E).map(transform: A -> B) -> B ? E
fun (Ok[A]).map(transform: A -> B) -> Ok[B] = Ok(transform(self.item))
fun (Error[E]).map(transform: A -> B) -> Error[E] = self


trait #monad[A] for A ? E


fun A ? E.wrap(value: A) -> Result[A, E] = Ok(value)


auto (A ? E).and-then(operation: A -> B ? E) -> B ? E
fun (Ok[A]).and-then(operation: A -> B ? E) -> B ? E = operation(self.value)
fun (Error[E]).and-then(operation: A -> B ? E) -> Error[E] = self


-- Map Iterator ---------------------------------------------------------------


struct Map[I, A] {
    iterator: I
    transform: I.Item -> A
}



forall I #iterator
trait #iterator for Map[I, A]


type Map[I, A].Item = A


forall I #iterator
fun (Map[I, A]).next -> (Map[I, A], Option[A]) =
    case self.iterator.next
	of (_, None) then (self, None)
	of (i, Ok(item)) then
		new-self = self.with(iterator: i)
		transformed = transform(item)
		(new-self, Ok(transformed))
	end
