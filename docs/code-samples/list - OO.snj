/*
# Linked List
*/


module std::list


use std::iter { #iterator, #iterable }


def List[A] = Empty | *Node[A]


extend List[A] {
    def List.new(...items: Array[A]) -> List[A] {
        items.rev-fold(Empty) fun(item, acc) {
            Node(item, acc)
        }
    }


    def push(item: A) -> *Node[A] {
        Node(item, self)
    }


    def head() -> Option[A]


    def tail() -> List[A]


    has #eq


    has #functor


    forall B
    def map(transform: fun(A) -> B) -> List[B]


    has #iterable


    def List.Iterator = List-Iterator[A]


    def iterator() -> List-Iterator[A] {
        List-Iterator(self)
    }
}


def Empty {
    def head() -> None {
        None
    }


    def tail() -> Empty {
        Empty
    }


    has #eq


    def == (right: Empty) -> True {
        True
    }


    def == (right: Node[A]) -> False {
        False
    }


    has #functor


    forall B
    def map(transform: fun(A) -> B) -> Empty {
        Empty
    }
}


def Node[A] {
    var item: A
    var tail: List[A]


    def head() -> Some[A] {
        self.item
    }


    def tail() -> List[A] {
        self.rest
    }


    has #eq


    def == (right: Empty) -> False {
        False
    }


    def == (right: Node[A]) -> Bool {
        self.item == other.item
            and self.rest == other.rest
    }


    has #functor


    forall B
    def map(transform: fun(A) -> B) -> *Node[B] {
        Node(transform(self.item), self.rest.map(transform))
    }
}


def List-Iterator[A] {
    let current: List[A]


    has #iterator


    def List-Iterator.Item = A


    def next() -> (List-Iterator[A], Option[A]) {
        match self.current {
        case Empty:
            (self, None)

        case Node(item, rest):
            let new-self = self.with(current: rest)
            (new-self, Some(item))
        }
    }
}


/*
## Usage ################################################################
*/


module main


use std::list { List, Node, Empty }


let double(list: List[Int]) -> List[Int] {
    list.map(___ * 2)
}


let main() -> Io[] {
    let a = Node(1, Node(2, Node(3, Empty)))
    let b = List::new(1, 2, 3)

    Io::print(a.Type)
    // Node[Int]

    Io::print(b.Type)
    // List[Int]

    Io::print(a.map.Type))
    // fun(Node[Int], fun(Int) -> A) -> Node[A]
}
