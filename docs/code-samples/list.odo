------
module std'list

use std'iter: #iterator, #asIterator


union List[T] =
    Empty | ref Node[T]


ensure
    List[#eq] is #eq
    List[_] is #functor
    List[_] is #iterable


forall T #any
struct Node[T] =
    item: T
    tail: List[T]


ensure
    Node[#eq] is #eq
    Node[_] is #functor #iterable


struct Empty


ensure
    Empty is #eq #functor #iterable


func List[T].new(...items: Array[T]) -> List[T] =
    items.fold-rev(
        Empty,
        \item \acc => Node(item, acc)
    )


func (Empty) == (other: Empty) -> Bool =
    True


func (Empty) == (other: Node[_]) -> Bool =
    False


func (Node[_]) == (other: Empty) -> Bool =
    False


func (Node[T #eq]) == (other: Node[T]) -> Bool =
    self.item == other.item and self.tail == other.tail


-- Pushing and poping

    
func (Node[T]).push(item: T) -> Node[T] =
    Node(item, self)


func (Empty).push(item: T) -> Node[T] =
    Node(item, Empty)


func (Node[T]).pop -> Some[T] =
    Some(self.item)


func (Empty).pop -> None =
    None


-- Functor implementation


func (Empty).map(f: T -> U) -> Empty =
    Empty


func (Node[T]).map(f: T -> U) -> Node[U] =
    Node(
        item: f(self.item),
        tail: self.tail.map(f))
    )


-- Iterator stuff


alias List[T].Iterator = Iterator[T]


func (List[T]).iter -> Iterator[T] =
    Iterator(self)


struct Iterator[T] =
    current: List[T]


ensure
    Iterator[_] is #iterator


alias Iterator[T].Item = T


func (Iterator[T]).next -> (Iterator[T], Option[T]) =
    match self.current
    case Empty then
        (self, None)
    case Node(item, tail) then
        (self with (current: tail), Some(item))
    

------
module std'list'test


use std'list (List, Node, Empty)


func double(list: List[Int]) -> List[Int] =
    list.map(x => x * 2)


func main!(io: Console) =
    a = Node(1, Node(2, Node(3, Empty)))
    b = List.new(1, 2, 3)

    io.print!(a.type)
    --> ListNode[Int] | EmptyList

    io.print!(b.type)
    --> ListNode[Int] | EmptyList

    io.print!(a.map.type)
    --> Func(ListNode[Int] | EmptyList, Int -> A) -> ListNode[A] | EmptyList
