-- Multiple dispatch using custom binary operators ----------------------------

def Pet = Cat | Dog


def Cat(name: String)


extend Cat {
    def -meets- (other: Cat) -> String {
        "slinks"
    }

    def -meets- (other: Dog) -> String {
        "hisses"
    }
}


def Dog(name: String)


extend Dog {
    def -meets- (other: Dog) -> String {
        "sniffs"
    }

    def -meets- (other: Cat) -> String {
        "chases"
    }
}


def encounter(a: Pet, b: Pet) -> String {
    let verb = a -meets- b
    "{a.name} meets {b.name} and {verb}"
}


-- Note: would a generic version of encounter be possible?


def #pet {
    has .name -> String

    forall A #pet
    has -meets- (other: A) -> String
}


forall A #pet, B #pet
def generic-encounter(a: A, b: B) -> String {
    let verb = a -meets- b
    return "{a.name} meets {b.name} and {verb}"
}


-- Combined with the expression problem: --------------------------------------

module pets

def #pet {
    has .name -> String
}


--


module cats

use pets { #pet }

def Cat(name: String)

extend Cat as #pet


--

module dogs

use pets { #pet }

def Dog(name: String)

extend Dog as #pet

--

module common-pets

use pets { #pet }
use cats { Cat }
use dogs { Dog }


def #common-pet {
    has #pet
    has -meets- (other: Cat) -> String
    has -meets- (other: Dog) -> String
}


extend Cat as #common-pet {
    def -meets- (other: Cat) -> String {
        "slinks"
    }

    def -meets- (other: Dog) -> String {
        "hisses"
    }
}


extend Dog as #common-pet {
    def (Dog) -meets- (other: Cat) -> String {
        "chases"
    }

    def (Dog) -meets- (other: Dog) -> String {
        "sniffs"
    }
}


def Common-Pet = Cat | Dog


forall A #common-pet
def encounter(a: A, b: Common-Pet) -> String {
    let verb = a -meets- b
    return "{a.name} meets {b.name} and {verb}"
}


--

module test

use pets (#pet)
use dogs (Dog)
use cats (Cat)
use common-pets { #common-pet }

def example_encounter() -> Io[] {
    let fido = Dog("Fido")
    let rex = Dog("Rex")
    let whiskers = Cat("Whiskers")
    let spot = Cat("Spot")

    Io::print(encounter(fido, rex))
    --> Fido meets Rex and sniffs
    Io::print(encounter(fido, whiskers))
    --> Fido meets Whiskers and chases
    Io::print(encounter(whiskers, rex))
    --> Whiskers meets Rex and hisses
    Io::print(encounter(whiskers, spot))
    --> Whiskers meets Spot and slinks

    let pets = Array(fido, whiskers)
    
    Io::traverse(pets) fun(pet) {
        Io::print("{pet.name}: {pet.type}")
    }
    --> Fido: enum(Cat | Dog)
    --> Whiskers: enum(Cat | Dog)

    Io::traverse(pets) fun(a) {
        Io::traverse(pets) fun(b) {
            Io::print(encounter(a, b))
        }
    }
    --> Fido meets Fido and sniffs
    --> Fido meets Whiskers and chases
    --> Whiskers meets Fido and hisses
    --> Whiskers meets Whiskers and slinks
}