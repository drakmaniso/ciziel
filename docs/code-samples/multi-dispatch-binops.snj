<< Multiple dispatch using custom binary operators >>


--- Simple Version: Non-generic `encounter` -----------------------------------


module cats-and-dogs

public

Cat = struct { name: data String }
Dog = struct { name: data String }

(Cat).<meets> (other: Cat) -> String = "slinks"
(Cat).<meets> (other: Dog) -> String = "hisses"
(Dog).<meets> (other: Dog) -> String = "sniffs"
(Cat).<meets> (other: Cat) -> String = "chases"


module birds
use cats-and-birds (Cat, Dog)

public

Bird = struct { name: data String }

(Bird).<meets> (other: Bird) -> String = "chirps"
(Bird).<meets> (other: Cat) -> String = "chirps"
(Bird).<meets> (other: Dog) -> String = "chirps"
(Cat).<meets> (other: Bird) -> String = "hunts"
(Dog).<meets> (other: Bird) -> String = "barks"


module usage
use cats-and-dogs (Cat, Dog)
use birds (Bird)

public

Pet = Cat | Dog | Bird

encounter(a: Pet, b: Pet) -> String =
    verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"


example-encounter() -> Nil &io =
	do
		pets =
			Array(
				Cat("Spot"),
				Dog("Fido"),
				Bird("Coco"),
			)

		pets.foreach(a =>
			pets.foreach(b =>
				io.print(encounter(a, b))
			)
		)
		--> Spot meets Spot and slinks
		--> Spot meets Fido and hisses
		--> Spot meets Coco and hunts
		--> Fido meets Spot and chases
		--> Fido meets Fido and sniffs
		--> Fido meets Coco and barks
		--> Coco meets Spot and chirps
		--> Coco meets Fido and chirps
		--> Coco meets Coco and chirps
	end


--- Using Traits: Generic `encounter` -----------------------------------------


module pets

public

trait #pet {
    (Self).name -> String
    (Self).<meets> (other: Self) -> String
}

encounter(a: P, b: P) -> String
	forall P: #pet
	=
    verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"


module cats-and-dogs
use pets (#pet)

public

Usual-Pet = Cat | Dog
Cat = struct { name: data String }
Dog = struct { name: data String }

Usual-Pet: #pet
Cat: #pet
Dog: #pet

(Cat).<meets> (other: Cat) -> String = "slinks"
(Cat).<meets> (other: Dog) -> String = "hisses"
(Dog).<meets> (other: Cat) -> String = "chases"
(Dog).<meets> (other: Dog) -> String = "sniffs"


module birds
use pets (#pet)
use cats-and-dogs (Cat, Dog)

public

Exotic-Pet = Cat | Dog | Bird
Bird = struct { name: data String }

Exotic-Pet: #pet
Bird: #pet

(Bird).<meets> (other: Cat) -> String { "chirps" }
(Bird).<meets> (other: Dog) -> String { "chirps" }
(Bird).<meets> (other: Bird) -> String { "chirps" }
(Cat).<meets> (other: Bird) -> String { "hunts" }
(Dog).<meets> (other: Bird) -> String { "barks" }


module usage
use pets (#pet)
use cats-and-dogs (Cat, Dog)
use exotic-pets (Bird)

public

main() -> Nil &io =
	do
		pets =
			Array(
				Cat("Spot"),
				Dog("Fido"),
				Bird("Coco"),
			)

		pets.foreach(a =>
			pets.foreach(b =>
				io.print(encounter(a, b))
			)
		)
		--> Spot meets Spot and slinks
		--> Spot meets Fido and hisses
		--> Spot meets Coco and hunts
		--> Fido meets Spot and chases
		--> Fido meets Fido and sniffs
		--> Fido meets Coco and barks
		--> Coco meets Spot and chirps
		--> Coco meets Fido and chirps
		--> Coco meets Coco and chirps
	end
