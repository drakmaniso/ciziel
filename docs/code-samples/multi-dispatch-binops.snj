/*
# Multiple dispatch using custom binary operators
*/


/*
## Simple Version: Non-generic `encounter`
*/


module cats-and-dogs


def Cat = struct { def name: String }
def Dog = struct { def name: String }


def (Cat) <meets> (other: Cat) -> String { "slinks" }
def (Cat) <meets> (other: Dog) -> String { "hisses" }
def (Dog) <meets> (other: Dog) -> String { "sniffs" }
def (Cat) <meets> (other: Cat) -> String { "chases" }


/*****/


module birds


use cats-and-birds (Cat, Dog)


def Bird = struct { def name: String }


def (Bird) <meets> (other: Bird) -> String { "chirps" }
def (Bird) <meets> (other: Cat) -> String { "chirps" }
def (Bird) <meets> (other: Dog) -> String { "chirps" }
def (Cat) <meets> (other: Bird) -> String { "hunts" }
def (Dog) <meets> (other: Bird) -> String { "barks" }


/*****/


module usage


use cats-and-dogs (Cat, Dog)
use birds (Bird)


let Pet = Cat | Dog | Bird


let encounter(a: Pet, b: Pet) -> String {
    let verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"
}


let example-encounter() -> Io[] {
    let pets =
        Array(
            Cat("Spot"),
            Dog("Fido"),
            Bird("Coco"),
        )

    Io.traverse(pets) {
        a => Io.traverse(pets) {
            b => Io.print(encounter(a, b))
        }
    }
    // Spot meets Spot and slinks
    // Spot meets Fido and hisses
    // Spot meets Coco and hunts
    // Fido meets Spot and chases
    // Fido meets Fido and sniffs
    // Fido meets Coco and barks
    // Coco meets Spot and chirps
    // Coco meets Fido and chirps
    // Coco meets Coco and chirps
}


let example-encounter(io!: Console) {
    let pets =
        Array(
            Cat("Spot"),
            Dog("Fido"),
            Bird("Coco"),
        )

    pets.fold(io!) {
        a => pets.fold(io!) {
            b => io!.print(encounter(a, b))
        }
    }
    // Spot meets Spot and slinks
    // Spot meets Fido and hisses
    // Spot meets Coco and hunts
    // Fido meets Spot and chases
    // Fido meets Fido and sniffs
    // Fido meets Coco and barks
    // Coco meets Spot and chirps
    // Coco meets Fido and chirps
    // Coco meets Coco and chirps
}


/*
## Using Traits: Generic `encounter`
*/


module pets


def #pet {
    has (Self).name: String
    has (Self) <meets> (other: Self) -> String
}


def encounter(a: P, b: P) -> String
    forall P #pet
{
    verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"
}


/*****/


module cats-and-dogs


use pets (#pet)


def Usual-Pet = Cat | Dog
def Cat(data name: String)
def Dog(data name: String)


def #pet for Usual-Pet, Cat, Dog
def (Cat) <meets> (other: Cat) -> String { "slinks" }
def (Cat) <meets> (other: Dog) -> String { "hisses" }
def (Dog) <meets> (other: Cat) -> String { "chases" }
def (Dog) <meets> (other: Dog) -> String { "sniffs" }


/*****/


module birds


use pets (#pet)
use cats-and-dogs (Cat, Dog)


def Exotic-Pet = Cat | Dog | Bird
def Bird(data name: String)


def #pet for Exotic-Pet, Bird
def (Bird) <meets> (other: Cat) -> String { "chirps" }
def (Bird) <meets> (other: Dog) -> String { "chirps" }
def (Bird) <meets> (other: Bird) -> String { "chirps" }
def (Cat) <meets> (other: Bird) -> String { "hunts" }
def (Dog) <meets> (other: Bird) -> String { "barks" }


/*****************************************************************************/


module main


use pets (#pet)
use cats-and-dogs (Cat, Dog)
use exotic-pets (Bird)


def main() -> Io[] {
    let pets =
        Array(
            Cat("Spot"),
            Dog("Fido"),
            Bird("Coco"),
        )

    Io.traverse(pets) {
        a => Io.traverse(pets) {
            b => Io.print(encounter(a, b))
        }
    }
    // Spot meets Spot and slinks
    // Spot meets Fido and hisses
    // Spot meets Coco and hunts
    // Fido meets Spot and chases
    // Fido meets Fido and sniffs
    // Fido meets Coco and barks
    // Coco meets Spot and chirps
    // Coco meets Fido and chirps
    // Coco meets Coco and chirps
}
