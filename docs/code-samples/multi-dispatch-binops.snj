/*
# Multiple dispatch using custom binary operators
*/


let Pet = Cat | Dog


let Cat {
    name: String
}


extend Cat {
    let <meets> (other: Cat) -> String {
        "slinks"
    }

    let <meets> (other: Dog) -> String {
        "hisses"
    }
}


let Dog {
    name: String
}


extend Dog {
    let <meets> (other: Dog) -> String {
        "sniffs"
    }

    let <meets> (other: Cat) -> String {
        "chases"
    }
}

let encounter(a: Pet, b: Pet) -> String {
    let verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"
}


let example-encounter() -> Io[] {
    let fido = Dog("Fido")
    let rex = Dog("Rex")
    let whiskers = Cat("Whiskers")
    let spot = Cat("Spot")

    Io.print(encounter(fido, rex))
    // Fido meets Rex and sniffs
    Io.print(encounter(fido, whiskers))
    // Fido meets Whiskers and chases
    Io.print(encounter(whiskers, rex))
    // Whiskers meets Rex and hisses
    Io.print(encounter(whiskers, spot))
    // Whiskers meets Spot and slinks

    let pets = Array(fido, whiskers)

    Io.traverse(pets) fun(pet) {
        Io.print("{pet.name}: {pet.type}")
    }
    // Fido: enum(Cat | Dog)
    // Whiskers: enum(Cat | Dog)

    Io.traverse(pets) fun(a) {
        Io.traverse(pets) fun(b) {
            Io.print(encounter(a, b))
        }
    }
    // Fido meets Fido and sniffs
    // Fido meets Whiskers and chases
    // Whiskers meets Fido and hisses
    // Whiskers meets Whiskers and slinks
}


/*
-------------------------------------------------------------------------------
*/


module additional-pet


def Bird {
    var name: String
}


extend Bird {
    def <meets> (other: Bird) -> String {
        "chirps"
    }

    def <meets> (other: Cat) -> String {
        "chirps"
    }

    def <meets> (other: Dog) -> String {
        "chirps"
    }

    def Bird.<meets> (left: Cat, right: Bird) -> String {
        "hunts"
    }

    def Bird.<meets> (left: Dog, right: Bird) -> String {
        "barks"
    }
}


/*
## Operators in Traits ########################################################
*/


module pets

def #pet {
    has name: String
}


/*
-------------------------------------------------------------------------------
*/


module usual-pets

use pets (#pet)


def Cat {
    var name: String
}

extend Cat as #pet


def Dog {
    var name: String
}

extend Dog as #pet


def #usual-meeter {
    has #pet
    has <meets> (other: Cat) -> String
    has <meets> (other: Dog) -> String
}

extend Cat as #usual-meeter {
    def <meets> (other: Cat) -> String {
        "slinks"
    }

    def <meets> (other: Dog) -> String {
        "hisses"
    }
}

extend Dog as #usual-meeter {
    def <meets> (other: Cat) -> String {
        "chases"
    }

    def <meets> (other: Dog) -> String {
        "sniffs"
    }
}


def Usual-Pet = Cat | Dog


// NOTE: It's impossible to define encounter using traits instead of unions.
def encounter(a: Usual-Pet, b: Usual-Pet) -> String {
    verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"
}


/*
-------------------------------------------------------------------------------
*/


module bird-pets

use pets (#pet)
use usual-pets (Cat, Dog, #usual-meeter)


def Bird {
    var name: String
}


extend Bird as #usual-meeter {
    def <meets> (other: Cat) -> String {
        "chirps"
    }

    def <meets> (other: Dog) -> String {
        "chirps"
    }
}


def #bird-meeter {
    has <meets> (other: Bird) -> String
}


extend Bird as #bird-meeter {
    def <meets> (other: Bird) -> String {
        "chirps"
    }
}


extend Cat as #bird-meeter {
    def <meets> (other: Bird) -> String {
        "hunts"
    }
}


extend Dog as #bird-meeter {
    def <meets> (other: Bird) -> String {
        "barks"
    }
}


def Pet = Cat | Dog | Bird


def encounter(a: Pet, b: Pet) -> String {
    verb = a <meets> b
    "{a.name} meets {b.name} and {verb}"
}
