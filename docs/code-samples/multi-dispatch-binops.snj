-- Multiple dispatch using custom binary operators ----------------------------

public Pet = enum { Cat, Dog }

public Cat = struct { name: String }
public (Cat) 'meets (other: Cat) -> String = "slinks"
public (Cat) 'meets (other: Dog) -> String = "hisses"

public Dog = struct { name: String }
public (Dog) 'meets (other: Dog) -> String = "sniffs"
public (Dog) 'meets (other: Cat) -> String = "chases"

public encounter(a: Pet, b: Pet) -> String =
    let verb = a 'meets b
    "{a.name} meets {b.name} and {verb}"


-- Note: would a generic version of encounter be possible?

public #pet =
    has Self { name: String, ... }
    has (Self) 'meets (other: #pet) -> String
    has (other: #pet) 'meets (Self) -> String

public genericEncounter(a: A, b: B) -> String
    forall A #pet, B #pet
=
    let verb = a 'meets b
    return "{a.name} meets {b.name} and {verb}"


-- Combined with the expression problem: --------------------------------------

module pets

public #pet =
    has Self(name: String, ...)
    has (Self) 'meets (other: #pet) -> String
    has (other: #pet) 'meets (Self) -> String

public encounter(a: A, b: B) -> String
    forall A #per, B #pet
=
    let verb = a 'meets b
    "{a.name} meets {b.name} and {verb}"

--

module cats

use pets (#pet)

public Cat =
    struct { name: String }
    implement #pet

public (Cat) 'meets (other: Cat) -> String = "slinks"

--

module dogs

use pets (#pet)
use cats (Cat)

public Dog =
    struct { name: String }
    implement #pet

public (Dog) 'meets (other: Dog) -> String = "sniffs"
public (Dog) 'meets (other: Cat) -> String = "chases"
public (Cat) 'meets (other: Dog) -> String = "hisses"

--

module test

use pets (#pet)
use dogs (Dog)
use cats (Cat)

public example_encounter() -> Io[] =
    Io.do {
        let fido = Dog("Fido")
        let rex = Dog("Rex")
        let whiskers = Cat("Whiskers")
        let spot = Cat("Spot")

        Io.print(encounter(fido, rex))
        --> Fido meets Rex and sniffs
        Io.print(encounter(fido, whiskers))
        --> Fido meets Whiskers and chases
        Io.print(encounter(whiskers, rex))
        --> Whiskers meets Rex and hisses
        Io.print(encounter(whiskers, spot))
        --> Whiskers meets Spot and slinks

        let pets = Array(fido, whiskers)
        Io.wrap(
            pets.map(fun(pet) ->
                Io.print("{pet.name}: {pet.type}")
            )
        )
        --> Fido: enum(Cat | Dog)
        --> Whiskers: enum(Cat | Dog)

        Io.wrap(
            pets.map(fun(a) ->
                pets.map(fun(b) ->
                    Io.print(encounter(a, b))
                )
            )
        )
        --> Fido meets Fido and sniffs
        --> Fido meets Whiskers and chases
        --> Whiskers meets Fido and hisses
        --> Whiskers meets Whiskers and slinks
    }