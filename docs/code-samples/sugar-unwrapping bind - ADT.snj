---- Unwrapping Bind ----------------------------------------------------------


fun example-1(numbers: Array[Int]) -> Option[Int] =
	first ?= numbers.at(0)
	second ?= numbers.at(1)
	Some(first + second)


fun example-1-desugared(numbers: Array[Int]) -> Option[Int] =
	case numbers.at(0).unwrapped
	of Ok(first) then
		case numbers.at(1).unwrapped
		of Ok(second) then
			Some(first + second)
		of Err(e) then e
		end
	of Err(e) then e
	end


fun example-2(numbers: Array[String]) -> Result[Int, String] =
	first ?= numbers.at(0).ok-or("empty array")
	a ?= Int.parse(first).map-err(e => "parse error: {e}")
	second ?= numbers.at(1).ok-or("array too small")
	b ?= Int.parse(second).map-err(e => "parse error: {e}")
	Ok(a + b)


fun example-2-desugared(numbers: Array[String]) -> Result[Int, String] =
	case numbers.at(0).ok-or("empty array").unwrapped
	of Ok(first) then
		case Int.parse(first).map-err(e => "parse error: {e}").unwrapped
		of Ok(a) then
			case numbers.at(1).ok-or("array too small").unwrapped
			of Ok(second) then
				case Int.parse(second).map-err(e => "parse error: {e}").unwrapped
				of Ok(b) then
					Ok(a + b)
				of Err(e) then e
				end
			of Err(e) then e
			end
		of Err(e) then e
		end
	of Err(e) then e
	end


fun example-3(numbers: Array[String]) -> Result[Int, String] =
	first ?= numbers.at(0) !! => "array is empty"
	a ?= Int.parse(first) !! e => "parse error: {e}"
	second ?= numbers.at(1) !! => "array is too small"
	b ?= Int.parse(second) !! e => "parse error: {e}"
	Ok(a + b)


fun example-3-desugard(numbers: Array[String]) -> Result[Int, String] =
	case numbers.at(0) !! => "array is empty"
	of Ok(first) then
		case Int.parse(first) !! e => "parse error: {e}"
		of Ok(a) then
			case numbers.at(1) !! => "array is too small"
			of Ok(second) then
				case Int.parse(second) !! e => "parse error: {e}"
				of Ok(b) then
					Ok(a + b)
				of e then e
				end
			of e then e
			end
		of e then e
		end
	of e then e
	end


---- Chaining Operator --------------------------------------------------------


fun example-3(numbers: Array[String]) -> Int | None =
	numbers.at(0)?.to-Int?.abs


fun example-3-desugared(numbers: Array[String]) -> Int | None =
	case numbers.at(0).unwrapped
	of Ok(s) then
		case s.to-Int.unwrapped
		of Ok(n) then n.abs
		of Err(e) then e
		end
	of Err(e) then e
	end


---- Short-Circuit Operator --------------------------------------------------------


fun example-3(numbers: Array[String]) -> Int | None =
	math::abs(Int.parse(numbers[0]?)?)


fun example-3-desugared(numbers: Array[String]) -> Int | None =
	case numbers.at(0)
	of s: String then
		case Int.parse(s)
		of n: Int then math::abs(n)
		of a then a
		end
	of a then a
	end


---- Refutable Bind with failure wrapping -------------------------------------


<<
From a Rust RFC:
	fn get_count_item(s: &str) -> (u64, &str) {
		let mut it = s.split(' ');
		let (Some(count_str), Some(item)) = (it.next(), it.next()) else {
			panic!("Can't segment count item pair: '{s}'");
		};
		let Ok(count) = u64::from_str(count_str) else {
			panic!("Can't parse integer: '{count_str}'");
		};
		(count, item)
	}
>>


fun get-count-item(s: String) -> Result[(Int, String), as None | as Int.Parse-Error] =
	it = s.split(Char " ")
	count-str ?= it.peek
	it' = it.next
	item ?= it'.peek
	count ?= Int.parse(count-str)

	(count, item)


type My-Error =
	| Segment-Error
	| Parse-Error(cause: Int.Parse-Error)


fun get-count-item(s: String) -> Result[(Int, String), My-Error] =
	it = s.split(Char " ")
	count-str ?= it.item !! Segment-Error
	it' = it.next
	item ?= it'.item !! Segment-Error
	count ?= Int.parse(count-str) !!! e => Parse-Error(e)

	(count, item)
