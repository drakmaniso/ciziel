[[ ## CONSTRUCTORS ######################################################### ]]


let Foo(let a: Int, let b: Bool)


[[ implicitly declares the field getters: ]]


extend Foo {
    let .a -> Int
    let .b -> Bool
}


[[ and the functional update functions: ]]


extend Foo {
    let .with(a: Int) -> Foo {
        Foo(a = a, b = self.b)
    }

    let .with(b: Bool) -> Foo {
        Foo(a = self.a, b = b)
    }

    let .with(a: Int, b: Bool) -> Foo {
        Foo(a = a, b = b)
    }
}


[[ ## ASSOCIATED FUNCTIONS ################################################# ]]


extend Foo {
    let ::bar(a: Int, b: Bool) -> String {
        "foobar"
    }
}


[[ desugars to an associated constant: ]]


extend Foo {
    let ::bar: \(Int, Bool) -> String =
        \(a, b) {
            "foobar"
        }
}


[[ ## METHODS ############################################################## ]]


extend Foo {
    let .baz(a: Int, b: Bool) -> String {
        "foobaz"
    }
}


[[ desugars to an associated function: ]]


extend Foo {
    let ::baz(self: Foo, a: Int, b: Bool) -> String {
        "foobaz"
    }
}


[[ which desugars to an associated constant: ]]


extend Foo {
    let ::baz: \(Foo, Int, Bool) -> String =
        \(a, b) {
            "foobaz"
        }
}


[[ ## PROPERTY ACCESS ###################################################### ]]


my-foo.prop()


[[ desugars to: (assuming `Foo` is the type of `my-foo`) ]]


Foo::prop(my-foo)


[[ ## METHOD CALLS ######################################################### ]]


my-foo.baz(1, True)


[[ desugars to: (assuming `Foo` is the type of `my-foo`) ]]


Foo::baz(my-foo, 1, True)
