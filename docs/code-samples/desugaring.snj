[[ ## CONSTRUCTORS ######################################################### ]]


let Foo(let a: Int, let b: Bool)


[[ implicitly declares the field getters: ]]


for Foo {
    let .a -> Int
    let .b -> Bool
}


[[ and the functional update functions: ]]


for Foo {
    let .with(a: Int) -> Foo {
        Foo(a = a, b = self.b)
    }

    let .with(b: Bool) -> Foo {
        Foo(a = self.a, b = b)
    }

    let .with(a: Int, b: Bool) -> Foo {
        Foo(a = a, b = b)
    }
}


[[ ## ASSOCIATED FUNCTIONS ################################################# ]]


for Foo {
    let ::bar(a: Int, b: Bool) -> String {
        "foobar"
    }
}


[[ desugars to an associated constant: ]]


for Foo {
    let ::bar: fun(Int, Bool) -> String =
        \ a, b {
            "foobar"
        }
}


[[ ## METHODS ############################################################## ]]


for Foo {
    let .baz(a: Int, b: Bool) -> String {
        "foobaz"
    }
}


[[ desugars to an associated function: ]]


for Foo {
    let ::baz(self: Foo, a: Int, b: Bool) -> String {
        "foobaz"
    }
}


[[ which desugars to an associated constant: ]]


for Foo {
    let ::baz: fun(Foo, Int, Bool) -> String =
        \ a, b {
            "foobaz"
        }
}


[[ ## METHOD CALLS ######################################################### ]]


let my-foo = Foo(1, True)
my-foo.baz


[[ desugars to: ]]


Foo::my-method(my-foo)


