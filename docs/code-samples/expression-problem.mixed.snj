module foo


trait #eval =
	eval (expr: Self) -> Int


struct Literal =
	value: Int
	ensure #eval


struct Addition T =
	left: Expr T
	right: Expr T
	ensure Addition #eval is #eval


func eval (expr: Literal) -> Int =
	expr.value


func eval (expr: Addition #eval) -> Int =
	(expr.left >> eval) + (expr.right >> eval)


------
module bar

use foo (#eval, Literal, Addition)


trait #pretty
	pretty (expr: Self) -> String
	ensure Literal
	ensure Addition #eval


struct Negation T =
	subexpr: T
	ensure Negation #eval is #eval
	ensure Negation #pretty is #pretty


func eval (expr: Negation #eval) -> Int =
	- (expr.subexpr >> eval)


func pretty(expr: Literal) -> String =
	expr >> eval >> as-string


func pretty(expr: Addition #pretty) -> String =
	"{expr.left >> pretty} + {expr.right >> pretty}"


func pretty (expr: Negation #pretty) -> String =
	match expr.subexpr
	case e = Literal(...):
		"-{e >> pretty}"
	else
		"- ({expr.subexpr >> pretty})"


------
module main

use 'std'io

use foo (#eval, Literal, Addition)
use bar (#pretty, Negation)

union Expr = Literal | Addition Expr | Negation Expr

func main() -> Io () =
	do {
		e1 = Addition (left: Literal 77) (right: Negation (Literal 12))
		io'print("{e1 >> pretty} = {e1 >> eval}")
	}
