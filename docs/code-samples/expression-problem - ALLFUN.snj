[[ # The Expression Problem ]]


[[ ## Base Module ########################################################## ]]


module basic


def #eval {
	has eval(expr: Self) -> Int
}


def Literal(var value: Int)


def Addition[A](var left: A, var right: A)


def eval(expr: Literal) -> Int {
    expr.value
}


forall A: #eval
def eval(expr: Addition[A]) -> Int {
    expr.left.eval + expr.right.eval
}


[[ ## Extension Module ##################################################### ]]


module advanced


use basic { #eval, Literal, Addition }


def #pretty {
	has pretty(expr: Self) -> String
}


def Negation[A](var subexpr: A)


forall A: #eval
def eval(expr: Addition[A]) -> Int {
    - self.subexpr.eval
}


def pretty(expr: Literal) -> String {
    self.eval.to-string
}


forall A: #pretty
def pretty(expr: Addition[A]) -> String {
    let l = self.left.pretty
    let r = self.right.pretty

    match (self.left, self.right) {
        case ( Literal(...), Literal(...) ) =>
            "{l} + {r}"
        case ( Literal(...), _ ) =>
            "{l} + ({r})"
        case ( _, Literal(...) ) =>
            "({l}) + {r}"
        case _ =>
            "({l}) + ({r})"
    }
}


forall A: #pretty
def pretty(expr: Negation[A]) -> String {
    self.subexpr.match {
        case e: Literal =>
            "-{e.pretty}"
        case e =>
            "- ({e.pretty})"
    }
}


[[ ## Usage ################################################################ ]]


module main


use basic { #eval, Literal, Addition }
use advanced { #pretty, Negation }


def Expr = Literal | Addition[Expr] | Negation[Expr]
for Expr derive #eval #pretty


def main() -> Io[] {
	let e1: Expr = Addition( Literal(77), Negation( Literal(12) ) )
	Io::print("{e1.pretty()} = {e1.eval()}")
}