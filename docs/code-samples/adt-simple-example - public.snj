module geom
use std::vec { Point }


pub union Shape(
    | Circle
    | BBox
    | Square
    | Rectangle
    | Polygon
)


pub struct Circle(
    var center: Point,
    var radius: Float64,
)


pub struct Triangle(
    var a: Point,
    var b: Point,
    var c: Point,
)


pub struct Rectangle(
    var origin: Point,
    var width: Float64,
    var height: Float64,
    pub angle: Float64,
)


pub struct BBox(
    pub min: Point,
    pub max: Point,
)


pub struct Polygon(
    pub ...points: Array[Point],
)


pub trait #shape {
    func .perimeter -> Float64
    func .area -> Float64
}


pub trait #movable {
    func .move-to(destination: Point) -> Self
}


pub trait #scalable {
    func .scale-by(factor: Float64) -> Self
}


pub trait #origin {
    func Self(origin: Point, ...)
}


forall A: #origin
extend A as #movable {
    pub func .move-to(destination: Point) -> A {
        self.with(origin = destination)
    }
}


forall S1: #origin, S2: #origin
pub func switch-places(shape-1: S1, shape-2: S2) -> (S1, S2) {
    let o1 = shape-1.origin
    let o2 = shape-2.origin
    ( shape-1.with(origin = o2), shape-2.with(origin = o1) )
}


[[ ## Circle ################################################################ ]]


extend Circle {
    pub func ::bounding-of(points: Array[Point]) -> Circle {
        func welzl(points, boundary) {
            match points {
            case _ and boundary.length == 3 =>
                trivial(boundary)

            case Array() =>
                trivial(boundary)

            case Array(p, rest) => 
                let d = welzl(points.remove(p), boundary)
                if d.encloses(p) {
                    d
                } else {
                    welzl(points.remove(p), boundary.push(p))
                }
            }
        }

        welzl(points, [])
    }

    func .diameter -> Float64 {
        self.radius * 2
    }
}


extend Circle as #shape {
    pub func .perimeter -> Float64 {
        math::pi * self.diameter
    }

    pub func .area -> Float64 {
        math::pi * (self.radius ** 2)
    }
}


extend Circle as #origin
extend Circle as #movable


extend Circle as #scalable {
    pub func .scale-by(factor: Float64) -> Circle {
        self.with(radius = self.radius * factor)
    }
}


[[ ## BBox ################################################################## ]]


extend BBox {
    pub func ::new(a: Point, b: Point) -> BBox {
        let (x-min, x-max) = (a.x, b.x).sorted()
        let (y-min, y-max) = (a.y, b.y).sorted()
        
        BBox(
            min = Point(x-min, y-min),
            max = Point(x-max, y-max),
        )
    }


    pub func .width -> Float64 { self.max.x - self.min.x }
    pub func .height -> Float64 { self.max.y - self.min.y }
    pub func .size -> Vec2 { Vec2(self.width, self.height) }


    pub func .perimeter -> Float64 {
        (2 * self.width) + (2 * self.height)
    }


    pub func .area -> Float64 {
        self.width * self.height
    }
}


extend BBox as #movable {    
    pub func .move-to(destination: Point) -> BBox {
        self.with(
            min = destination
            max = destination + self.size
        )
    }
}


extend BBox as #scalable {    
    pub func .scale-by(factor: Float64) -> BBox {
        let delta = (factor * self.size) - self.size
        self.with(
            min = self.min - (delta / 2)
            max = self.max + (delta / 2)
        )
    }
}


extend Polygon {
    pub operator self[index: Int] -> Point {
        self.points[index]
    }
}
