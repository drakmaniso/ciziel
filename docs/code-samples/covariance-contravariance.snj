/*
# Covariance and Contravariance

Adapted from a [blog article]
(https://quuxplusone.github.io/blog/2019/01/20/covariance-and-contravariance/).
*/


/*
## Unions #####################################################################

With unions, only covariance works.
*/


let Cat


let (Cat).make-noise -> Io[] {
    Io.print("meow!")
}


let Horse


let (Horse).make-noise -> Io[] {
    Io.print("neigh!")
}


let (Horse).ride -> Io[] {
    Io.print("Ok, sure.")
}


let Animal = Cat | Horse


has (Animal).make-noise(self) -> Io[]


/* Breeders: covariance */


let Cat-Breeder


let (Cat-Breeder).produce -> Cat {
    Cat
}


let Horse-Breeder


let (Horse-Breeder).produce -> Horse {
    Horse
}


let Animal-Breeder = Cat-Breeder | Horse-Breeder


has (Animal-Breeder).produce -> Animal


/* Doctors: contravariance */


let Cat-Doctor


let (Cat-Doctor).treat(patient: Cat) -> Io[] {
    Io.print("All done.")
}


let Horse-Doctor


let (Horse-Doctor).treat(patient: Horse) -> Io[] {
    Io.print("All done.")
}


let Animal-Doctor = Cat-Doctor | Horse-Doctor


/*
`Animal-Doctor` has no `treat` method, because it cannot be unified!

```
has (Animal-Doctor).treat(self, patient: ???) -> Io[]
```
*/


let produce-and-treat(breeder: Animal-Breeder, doctor: Animal-Doctor) -> Io[] {
    let animal = breeder.produce
    animal.make-noise
    match animal, doctor {
        case c: Cat, d: Cat-Doctor =>
            d.treat(c)
        case h: Horse, d: Horse-Doctor =>
            d.treat(h)
        case Cat, Horse-Doctor =>
            std::panic("This doctor cannot treat a cat!")
        case Horse, Cat-Doctor =>
            std::panic("This doctor cannot treat a horse!")
    }
}


/*
## Traits #####################################################################

With traits, both covariance and contravariance works.
*/


let Cat
let Horse


let #animal {
    has (Self).make-noise -> Io[]
}


let #animal for Cat, Horse


let (Cat).make-noise -> Io[] {
    Io.print("meow!")
}


let (Horse).make-noise -> Io[] {
    Io.print("neigh!")
}


let (Horse).ride -> Io[] {
    Io.print("Ok, sure.")
}


// Breeders: covariance


let Cat-Breeder
let Horse-Breeder


let #animal-breeder {
    has Self.Animal
    has (Self).produce -> Self.Animal
}


let #animal-breeder for Cat-Breeder, Horse-Breeder


let Cat-Breeder.Animal = Cat
let (Cat-Breeder).produce -> Cat {
    Cat
}


let Horse-Breeder.Animal = Horse
let (Horse-Breeder).produce -> Horse {
    Horse
}


// Doctors: contravariance


let Cat-Doctor
let Horse-Doctor


let #animal-doctor {
    has Self.Animal
    has (Self).treat(patient: Self.Animal) -> Io[]
}


def #animal-doctor for Cat-Doctor, Horse-Doctor


let Cat-Doctor.Animal = Cat
let (Cat-Doctor).treat(patient: Cat) -> Io[] {
    Io.print("All done.")
}


let Horse-Doctor.Animal = Horse
let (Horse-Doctor).treat(patient: Horse) -> Io[] {
    Io.print("All done.")
}


let produce-and-treat(breeder: B, doctor: D) -> Io[]
    forall
        B #animal-breeder,
        D #animal-doctor,
        B.Animal == D.Animal
{
    let animal = breeder.produce
    animal.make-noise
    doctor.treat(animal)
}
