<<
# Covariance and Contravariance

Adapted from a [blog article]
(https://quuxplusone.github.io/blog/2019/01/20/covariance-and-contravariance/).
>>


-- Unions ---------------------------------------------------------------------


<< With unions, only covariance works. >>


type Animal = Cat | Horse
struct Cat
struct Horse


fun (Cat).make-noise -> Nil &io =
    io.print("meow!")


fun (Horse).make-noise -> Nil &io =
    io.print("neigh!")


dispatch (Animal).make-noise(self) -> Nil &io


<< Breeders: covariance >>


type Animal-Breeder = Cat-Breeder | Horse-Breeder
struct Cat-Breeder
struct Horse-Breeder


fun (Cat-Breeder).produce -> Cat =
    Cat


fun (Horse-Breeder).produce -> Horse =
    Horse


dispatch (Animal-Breeder).produce -> Animal


<< Doctors: contravariance >>


type Animal-Doctor = Cat-Doctor | Horse-Doctor
struct Cat-Doctor
struct Horse-Doctor


fun (Cat-Doctor).treat(patient: Cat) -> Nil &io =
    io.print("All done.")


fun (Horse-Doctor).treat(patient: Horse) -> Nil &io =
    io.print("All done.")


<<
`Animal-Doctor` has no `treat` method, because it cannot be dispatched!

    ```
    dispatch (Animal-Doctor).treat(self, patient: ???) -> Nil &io
    ```
>>


fun produce-and-treat(breeder: Animal-Breeder, doctor: Animal-Doctor) -> Nil &io =
    animal = breeder.produce
    do animal.make-noise

    do case (animal, doctor)
	of (c: Cat, d: Cat-Doctor) then
		d.treat(c)
	of (h: Horse, d: Horse-Doctor) then
		d.treat(h)
	of (Cat, Horse-Doctor) then
		panic("This doctor cannot treat a cat!")
	of (Horse, Cat-Doctor) then
		panic("This doctor cannot treat a horse!")
	end

	Nil


-- Traits ---------------------------------------------------------------------


<< With traits, both covariance and contravariance works. >>


struct Cat
struct Horse


trait #animal {
    fun (Self).make-noise -> Nil &io
}


trait #animal for Cat
trait #animal for Horse


fun (Cat).make-noise -> Nil &io =
    io.print("meow!")


fun (Horse).make-noise -> Nil &io =
    io.print("neigh!")


fun (Horse).ride -> Nil &io =
    io.print("Ok, sure.")


// Breeders: covariance


struct Cat-Breeder
struct Horse-Breeder


trait #animal-breeder {
    type Self.Animal
    fun (Self).produce -> Self.Animal
}


trait #animal-breeder for Cat-Breeder
trait #animal-breeder for Horse-Breeder


type Cat-Breeder.Animal = Cat
fun (Cat-Breeder).produce -> Cat =
    Cat


type Horse-Breeder.Animal = Horse
fun (Horse-Breeder).produce -> Horse =
    Horse


// Doctors: contravariance


type Cat-Doctor
type Horse-Doctor


trait #animal-doctor {
    type Self.Animal
    fun (Self).treat(patient: Self.Animal) -> Nil &io
}


trait #animal-doctor for Cat-Doctor
trait #animal-doctor for Horse-Doctor


type Cat-Doctor.Animal = Cat
fun (Cat-Doctor).treat(patient: Cat) -> Nil &io =
    io.print("All done.")


type Horse-Doctor.Animal = Horse
fun (Horse-Doctor).treat(patient: Horse) -> Nil &io =
    io.print("All done.")


forall
	B #animal-breeder,
	D #animal-doctor,
	B.Animal == D.Animal
fun produce-and-treat(breeder: B, doctor: D) -> Nil &io =
    let animal = breeder.produce
    do animal.make-noise

    doctor.treat(animal)
